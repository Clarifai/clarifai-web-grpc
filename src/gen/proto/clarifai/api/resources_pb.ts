// @generated by protoc-gen-es v0.1.0 with parameter "target=ts"
// @generated from file proto/clarifai/api/resources.proto (package clarifai.api, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {BoolValue, Message, proto3, protoInt64, Struct, Timestamp, UInt64Value, Value} from "@bufbuild/protobuf";
import {Status} from "./status/status_pb.js";
import {MatrixUint64} from "./utils/matrix_pb.js";

/**
 * @generated from enum clarifai.api.DatasetVersionMetricsGroupType
 */
export enum DatasetVersionMetricsGroupType {
  /**
   * @generated from enum value: DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET = 0;
   */
  DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET = 0,

  /**
   * Group data examples by input type.
   * Examples: images, videos, text, audio.
   *
   * @generated from enum value: INPUT_TYPE = 2;
   */
  INPUT_TYPE = 2,

  /**
   * Group data examples by concept ID.
   * Examples: inputs with cat concept, inputs with dog concept.
   *
   * @generated from enum value: CONCEPT_ID = 10;
   */
  CONCEPT_ID = 10,

  /**
   * Group data examples by concepts count.
   * Examples: inputs with 20 concepts, inputs with 21 concepts.
   *
   * @generated from enum value: CONCEPTS_COUNT = 11;
   */
  CONCEPTS_COUNT = 11,

  /**
   * Group data examples by bounding boxes count.
   * Examples: inputs with 20 bounding boxes, inputs with 21 bounding boxes.
   *
   * @generated from enum value: BOUNDING_BOXES_COUNT = 20;
   */
  BOUNDING_BOXES_COUNT = 20,

  /**
   * Group data examples by polygons count.
   * Examples: inputs with 20 polygons, inputs with 21 polygons.
   *
   * @generated from enum value: POLYGONS_COUNT = 21;
   */
  POLYGONS_COUNT = 21,

  /**
   * Group data examples by points count.
   * Examples: inputs with 20 points, inputs with 21 points.
   *
   * @generated from enum value: POINTS_COUNT = 22;
   */
  POINTS_COUNT = 22,

  /**
   * Group data examples by masks count.
   * Examples: inputs with 20 masks, inputs with 21 masks.
   *
   * @generated from enum value: MASKS_COUNT = 23;
   */
  MASKS_COUNT = 23,

  /**
   * Group data examples by pixels count.
   * In order to reduce the number of groups, we use bins.
   * Examples for bin size = 400: inputs with [200000, 200400) pixels, inputs with [200400, 200800) pixels.
   *
   * @generated from enum value: PIXELS_COUNT = 30;
   */
  PIXELS_COUNT = 30,

  /**
   * Group data examples by aspect ratio.
   * In order to reduce the number of groups, we use bins.
   * Examples for bin size = 0.1: inputs with [0.5, 0.6) aspect ratio, inputs with [0.6, 0.7) aspect ratio.
   *
   * @generated from enum value: ASPECT_RATIO = 31;
   */
  ASPECT_RATIO = 31,
}
// Retrieve enum metadata with: proto3.getEnumType(DatasetVersionMetricsGroupType)
proto3.util.setEnumType(DatasetVersionMetricsGroupType, "clarifai.api.DatasetVersionMetricsGroupType", [
  { no: 0, name: "DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET" },
  { no: 2, name: "INPUT_TYPE" },
  { no: 10, name: "CONCEPT_ID" },
  { no: 11, name: "CONCEPTS_COUNT" },
  { no: 20, name: "BOUNDING_BOXES_COUNT" },
  { no: 21, name: "POLYGONS_COUNT" },
  { no: 22, name: "POINTS_COUNT" },
  { no: 23, name: "MASKS_COUNT" },
  { no: 30, name: "PIXELS_COUNT" },
  { no: 31, name: "ASPECT_RATIO" },
]);

/**
 * @generated from enum clarifai.api.DatasetVersionExportFormat
 */
export enum DatasetVersionExportFormat {
  /**
   * @generated from enum value: DATASET_VERSION_EXPORT_FORMAT_NOT_SET = 0;
   */
  DATASET_VERSION_EXPORT_FORMAT_NOT_SET = 0,

  /**
   * CLARIFAI_DATA_EXAMPLE is the proprietary Clarifai Data Example format. It
   * is a ZIP-archive containing batches of serialized DataExample protobuf
   * messages.
   *
   * @generated from enum value: CLARIFAI_DATA_EXAMPLE = 1;
   */
  CLARIFAI_DATA_EXAMPLE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DatasetVersionExportFormat)
proto3.util.setEnumType(DatasetVersionExportFormat, "clarifai.api.DatasetVersionExportFormat", [
  { no: 0, name: "DATASET_VERSION_EXPORT_FORMAT_NOT_SET" },
  { no: 1, name: "CLARIFAI_DATA_EXAMPLE" },
]);

/**
 * ExpirationAction
 *
 * @generated from enum clarifai.api.ExpirationAction
 */
export enum ExpirationAction {
  /**
   * @generated from enum value: EXPIRATION_ACTION_NOT_SET = 0;
   */
  EXPIRATION_ACTION_NOT_SET = 0,

  /**
   * Progressively delay the execution of operations
   *
   * @generated from enum value: DELAY = 1;
   */
  DELAY = 1,

  /**
   * Cease functioning
   *
   * @generated from enum value: EXPIRY = 2;
   */
  EXPIRY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExpirationAction)
proto3.util.setEnumType(ExpirationAction, "clarifai.api.ExpirationAction", [
  { no: 0, name: "EXPIRATION_ACTION_NOT_SET" },
  { no: 1, name: "DELAY" },
  { no: 2, name: "EXPIRY" },
]);

/**
 * LicenseScope
 *
 * @generated from enum clarifai.api.LicenseScope
 */
export enum LicenseScope {
  /**
   * @generated from enum value: LICENSE_SCOPE_NOT_SET = 0;
   */
  LICENSE_SCOPE_NOT_SET = 0,

  /**
   * @generated from enum value: PREDICT = 1;
   */
  PREDICT = 1,

  /**
   * @generated from enum value: TRAIN = 2;
   */
  TRAIN = 2,

  /**
   * @generated from enum value: SEARCH = 3;
   */
  SEARCH = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LicenseScope)
proto3.util.setEnumType(LicenseScope, "clarifai.api.LicenseScope", [
  { no: 0, name: "LICENSE_SCOPE_NOT_SET" },
  { no: 1, name: "PREDICT" },
  { no: 2, name: "TRAIN" },
  { no: 3, name: "SEARCH" },
]);

/**
 * @generated from enum clarifai.api.DataType
 */
export enum DataType {
  /**
   * Default value, should not be used
   *
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: STRING = 1;
   */
  STRING = 1,

  /**
   * @generated from enum value: UINT8 = 2;
   */
  UINT8 = 2,

  /**
   * @generated from enum value: INT32 = 3;
   */
  INT32 = 3,

  /**
   * @generated from enum value: INT64 = 4;
   */
  INT64 = 4,

  /**
   * @generated from enum value: FP32 = 5;
   */
  FP32 = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(DataType)
proto3.util.setEnumType(DataType, "clarifai.api.DataType", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "STRING" },
  { no: 2, name: "UINT8" },
  { no: 3, name: "INT32" },
  { no: 4, name: "INT64" },
  { no: 5, name: "FP32" },
]);

/**
 * For the concept-threshold model type we use these comparison.
 * This is in the "concept_threshold_type" field of "infer_params" in the output config of
 * the model.
 * The json value can either be the integer field number:
 *   {"infer_params": {"concept_threshold_type": 3}}
 * Or the string field name:
 *   {"infer_params": {"concept_threshold_type": "LESS_THAN"}}
 *
 * @generated from enum clarifai.api.ValueComparator
 */
export enum ValueComparator {
  /**
   * @generated from enum value: CONCEPT_THRESHOLD_NOT_SET = 0;
   */
  CONCEPT_THRESHOLD_NOT_SET = 0,

  /**
   * input > value
   *
   * @generated from enum value: GREATER_THAN = 1;
   */
  GREATER_THAN = 1,

  /**
   * input >= value
   *
   * @generated from enum value: GREATER_THAN_OR_EQUAL = 2;
   */
  GREATER_THAN_OR_EQUAL = 2,

  /**
   * input < value
   *
   * @generated from enum value: LESS_THAN = 3;
   */
  LESS_THAN = 3,

  /**
   * input <= value
   *
   * @generated from enum value: LESS_THAN_OR_EQUAL = 4;
   */
  LESS_THAN_OR_EQUAL = 4,

  /**
   * input == value
   *
   * @generated from enum value: EQUAL = 5;
   */
  EQUAL = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ValueComparator)
proto3.util.setEnumType(ValueComparator, "clarifai.api.ValueComparator", [
  { no: 0, name: "CONCEPT_THRESHOLD_NOT_SET" },
  { no: 1, name: "GREATER_THAN" },
  { no: 2, name: "GREATER_THAN_OR_EQUAL" },
  { no: 3, name: "LESS_THAN" },
  { no: 4, name: "LESS_THAN_OR_EQUAL" },
  { no: 5, name: "EQUAL" },
]);

/**
 * This is expected to match EvaluationType in proto/predictor/predictor.proto
 *
 * @generated from enum clarifai.api.EvaluationType
 */
export enum EvaluationType {
  /**
   * default
   *
   * @generated from enum value: Classification = 0;
   */
  Classification = 0,

  /**
   * @generated from enum value: Detection = 1;
   */
  Detection = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EvaluationType)
proto3.util.setEnumType(EvaluationType, "clarifai.api.EvaluationType", [
  { no: 0, name: "Classification" },
  { no: 1, name: "Detection" },
]);

/**
 * APIEventType
 *
 * @generated from enum clarifai.api.APIEventType
 */
export enum APIEventType {
  /**
   * @generated from enum value: API_EVENT_TYPE_NOT_SET = 0;
   */
  API_EVENT_TYPE_NOT_SET = 0,

  /**
   * On Prem event types
   *
   * @generated from enum value: ON_PREM_PREDICT = 1;
   */
  ON_PREM_PREDICT = 1,

  /**
   * @generated from enum value: ON_PREM_TRAIN = 2;
   */
  ON_PREM_TRAIN = 2,

  /**
   * @generated from enum value: ON_PREM_SEARCH = 3;
   */
  ON_PREM_SEARCH = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(APIEventType)
proto3.util.setEnumType(APIEventType, "clarifai.api.APIEventType", [
  { no: 0, name: "API_EVENT_TYPE_NOT_SET" },
  { no: 1, name: "ON_PREM_PREDICT" },
  { no: 2, name: "ON_PREM_TRAIN" },
  { no: 3, name: "ON_PREM_SEARCH" },
]);

/**
 * UsageIntervalType
 *
 * @generated from enum clarifai.api.UsageIntervalType
 */
export enum UsageIntervalType {
  /**
   * undef UsageIntervalType is so that the interval field can be forced to be included
   *
   * @generated from enum value: undef = 0;
   */
  undef = 0,

  /**
   * @generated from enum value: day = 1;
   */
  day = 1,

  /**
   * @generated from enum value: month = 2;
   */
  month = 2,

  /**
   * @generated from enum value: year = 3;
   */
  year = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(UsageIntervalType)
proto3.util.setEnumType(UsageIntervalType, "clarifai.api.UsageIntervalType", [
  { no: 0, name: "undef" },
  { no: 1, name: "day" },
  { no: 2, name: "month" },
  { no: 3, name: "year" },
]);

/**
 * RoleType
 *
 * @generated from enum clarifai.api.RoleType
 */
export enum RoleType {
  /**
   * @generated from enum value: TEAM = 0;
   */
  TEAM = 0,

  /**
   * @generated from enum value: ORG = 1;
   */
  ORG = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RoleType)
proto3.util.setEnumType(RoleType, "clarifai.api.RoleType", [
  { no: 0, name: "TEAM" },
  { no: 1, name: "ORG" },
]);

/**
 * StatValueAggType
 *
 * @generated from enum clarifai.api.StatValueAggType
 */
export enum StatValueAggType {
  /**
   * @generated from enum value: SUM = 0;
   */
  SUM = 0,

  /**
   * @generated from enum value: AVG = 1;
   */
  AVG = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(StatValueAggType)
proto3.util.setEnumType(StatValueAggType, "clarifai.api.StatValueAggType", [
  { no: 0, name: "SUM" },
  { no: 1, name: "AVG" },
]);

/**
 * StatTimeAggType
 *
 * @generated from enum clarifai.api.StatTimeAggType
 */
export enum StatTimeAggType {
  /**
   * @generated from enum value: NO_TIME_AGG = 0;
   */
  NO_TIME_AGG = 0,

  /**
   * @generated from enum value: YEAR = 1;
   */
  YEAR = 1,

  /**
   * @generated from enum value: MONTH = 2;
   */
  MONTH = 2,

  /**
   * @generated from enum value: WEEK = 3;
   */
  WEEK = 3,

  /**
   * @generated from enum value: DAY = 4;
   */
  DAY = 4,

  /**
   * @generated from enum value: HOUR = 5;
   */
  HOUR = 5,

  /**
   * @generated from enum value: MINUTE = 6;
   */
  MINUTE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(StatTimeAggType)
proto3.util.setEnumType(StatTimeAggType, "clarifai.api.StatTimeAggType", [
  { no: 0, name: "NO_TIME_AGG" },
  { no: 1, name: "YEAR" },
  { no: 2, name: "MONTH" },
  { no: 3, name: "WEEK" },
  { no: 4, name: "DAY" },
  { no: 5, name: "HOUR" },
  { no: 6, name: "MINUTE" },
]);

/**
 * ValidationErrorType
 *
 * @generated from enum clarifai.api.ValidationErrorType
 */
export enum ValidationErrorType {
  /**
   * @generated from enum value: VALIDATION_ERROR_TYPE_NOT_SET = 0;
   */
  VALIDATION_ERROR_TYPE_NOT_SET = 0,

  /**
   * @generated from enum value: RESTRICTED = 1;
   */
  RESTRICTED = 1,

  /**
   * @generated from enum value: DATABASE = 2;
   */
  DATABASE = 2,

  /**
   * @generated from enum value: FORMAT = 3;
   */
  FORMAT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ValidationErrorType)
proto3.util.setEnumType(ValidationErrorType, "clarifai.api.ValidationErrorType", [
  { no: 0, name: "VALIDATION_ERROR_TYPE_NOT_SET" },
  { no: 1, name: "RESTRICTED" },
  { no: 2, name: "DATABASE" },
  { no: 3, name: "FORMAT" },
]);

/**
 * Annotation of an asset with metadata
 *
 * @generated from message clarifai.api.Annotation
 */
export class Annotation extends Message<Annotation> {
  /**
   * The ID for the annotation
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * ID of the input this annotation is tied to
   *
   * @generated from field: string input_id = 2;
   */
  inputId = "";

  /**
   * The data passed along in this annotation.
   *
   * @generated from field: clarifai.api.Data data = 3;
   */
  data?: Data;

  /**
   * task_id is deprecated in annotation_info. Use task_id
   *
   * @generated from field: google.protobuf.Struct annotation_info = 13;
   */
  annotationInfo?: Struct;

  /**
   * ID of the user this annotation is created by
   *
   * @generated from field: string user_id = 15;
   */
  userId = "";

  /**
   * ID of the model version this annotation is created by
   *
   * @generated from field: string model_version_id = 16;
   */
  modelVersionId = "";

  /**
   * DEPRECATED.
   *
   * @generated from field: string embed_model_version_id = 14 [deprecated = true];
   * @deprecated
   */
  embedModelVersionId = "";

  /**
   * Annotation Status
   *
   * @generated from field: clarifai.api.status.Status status = 7;
   */
  status?: Status;

  /**
   * When the annotation was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the annotation was modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 9;
   */
  modifiedAt?: Timestamp;

  /**
   * Whether or not this annotation is trusted
   * Will be deprecated
   *
   * @generated from field: bool trusted = 10 [deprecated = true];
   * @deprecated
   */
  trusted = false;

  /**
   * Is this the input level annotation.
   *
   * @generated from field: bool input_level = 17;
   */
  inputLevel = false;

  /**
   * Consensus review related information, e.g.
   * * annotation group
   * * id of annotation parent, in case the annotation was split from another annotation
   *
   * @generated from field: google.protobuf.Struct consensus_info = 18;
   */
  consensusInfo?: Struct;

  /**
   * The id of the task annotation belongs to
   *
   * @generated from field: string task_id = 19;
   */
  taskId = "";

  constructor(data?: PartialMessage<Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "data", kind: "message", T: Data },
    { no: 13, name: "annotation_info", kind: "message", T: Struct },
    { no: 15, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "embed_model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "status", kind: "message", T: Status },
    { no: 8, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "modified_at", kind: "message", T: Timestamp },
    { no: 10, name: "trusted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "input_level", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "consensus_info", kind: "message", T: Struct },
    { no: 19, name: "task_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Annotation {
    return new Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: Annotation | PlainMessage<Annotation> | undefined, b: Annotation | PlainMessage<Annotation> | undefined): boolean {
    return proto3.util.equals(Annotation, a, b);
  }
}

/**
 * Application with tasks and datasets
 *
 * @generated from message clarifai.api.App
 */
export class App extends Message<App> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string default_language = 3;
   */
  defaultLanguage = "";

  /**
   * @generated from field: string default_workflow_id = 4;
   */
  defaultWorkflowId = "";

  /**
   * why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
   * This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
   *
   * @generated from field: string user_id = 5;
   */
  userId = "";

  /**
   * When the app was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  /**
   * When the app was last modified
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 17;
   */
  modifiedAt?: Timestamp;

  /**
   * if user accept legal consent for face recognition
   *
   * @generated from field: uint32 legal_consent_status = 7;
   */
  legalConsentStatus = 0;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 13;
   */
  metadata?: Struct;

  /**
   * short description about the app.
   *
   * @generated from field: string description = 14;
   */
  description = "";

  /**
   * Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
   *
   * @generated from field: uint32 sample_ms = 15;
   */
  sampleMs = 0;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 16;
   */
  visibility?: Visibility;

  /**
   * data tier id this app is using.
   *
   * @generated from field: string data_tier_id = 18;
   */
  dataTierId = "";

  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostAppStars/DeleteAppStars endpoints to star/unstar an app
   *
   * @generated from field: bool is_starred = 19;
   */
  isStarred = false;

  /**
   * How many users have starred the app (only showed on get/list requests)
   * Computed value, not editable
   *
   * @generated from field: int32 star_count = 20;
   */
  starCount = 0;

  /**
   * Notes for the application
   * This field should be used for in-depth notes and supports up to 64Kbs.
   *
   * @generated from field: string notes = 21;
   */
  notes = "";

  constructor(data?: PartialMessage<App>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.App";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "default_language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "default_workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    { no: 17, name: "modified_at", kind: "message", T: Timestamp },
    { no: 7, name: "legal_consent_status", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "metadata", kind: "message", T: Struct },
    { no: 14, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "sample_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 16, name: "visibility", kind: "message", T: Visibility },
    { no: 18, name: "data_tier_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "is_starred", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "star_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 21, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): App {
    return new App().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): App {
    return new App().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): App {
    return new App().fromJsonString(jsonString, options);
  }

  static equals(a: App | PlainMessage<App> | undefined, b: App | PlainMessage<App> | undefined): boolean {
    return proto3.util.equals(App, a, b);
  }
}

/**
 * App query
 *
 * @generated from message clarifai.api.AppQuery
 */
export class AppQuery extends Message<AppQuery> {
  /**
   * Query by application name. This supports wildcard queries like "gen*" to match "general" as an example.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<AppQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AppQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppQuery {
    return new AppQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppQuery {
    return new AppQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppQuery {
    return new AppQuery().fromJsonString(jsonString, options);
  }

  static equals(a: AppQuery | PlainMessage<AppQuery> | undefined, b: AppQuery | PlainMessage<AppQuery> | undefined): boolean {
    return proto3.util.equals(AppQuery, a, b);
  }
}

/**
 * Collaborator - invited user, who shares an access to an application
 *
 * @generated from message clarifai.api.Collaborator
 */
export class Collaborator extends Message<Collaborator> {
  /**
   * id of this collaborator
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * the app this collaborator has access to
   * FIXME(zeiler): this should be in the user_app_id.app_id already from the endpoint.
   *
   * @generated from field: clarifai.api.App app = 2;
   */
  app?: App;

  /**
   * who is this collaborator
   *
   * @generated from field: clarifai.api.User user = 3;
   */
  user?: User;

  /**
   * the permission this collaborator
   *
   * @generated from field: repeated string scopes = 4;
   */
  scopes: string[] = [];

  /**
   * @generated from field: repeated string endpoints = 5;
   */
  endpoints: string[] = [];

  /**
   * When the app was shared with. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  /**
   * When the collaborator was updated.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 7;
   */
  modifiedAt?: Timestamp;

  /**
   * When the collaborator was removed from app.
   *
   * @generated from field: google.protobuf.Timestamp deleted_at = 8;
   */
  deletedAt?: Timestamp;

  constructor(data?: PartialMessage<Collaborator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Collaborator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "app", kind: "message", T: App },
    { no: 3, name: "user", kind: "message", T: User },
    { no: 4, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    { no: 7, name: "modified_at", kind: "message", T: Timestamp },
    { no: 8, name: "deleted_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collaborator {
    return new Collaborator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collaborator {
    return new Collaborator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collaborator {
    return new Collaborator().fromJsonString(jsonString, options);
  }

  static equals(a: Collaborator | PlainMessage<Collaborator> | undefined, b: Collaborator | PlainMessage<Collaborator> | undefined): boolean {
    return proto3.util.equals(Collaborator, a, b);
  }
}

/**
 * collaboration includes an app you're invited to work on.
 *
 * @generated from message clarifai.api.Collaboration
 */
export class Collaboration extends Message<Collaboration> {
  /**
   * the application
   *
   * @generated from field: clarifai.api.App app = 1;
   */
  app?: App;

  /**
   * the app owner's info(including user_unique_id, first_name, last_name, primary_email)
   *
   * @generated from field: clarifai.api.User app_owner = 2;
   */
  appOwner?: User;

  /**
   * the low-level scope users are shared with for this collaboration
   *
   * @generated from field: repeated string scopes = 3;
   */
  scopes: string[] = [];

  /**
   * the endpoint-level scopes users are shared with for this collaboration
   *
   * @generated from field: repeated string endpoints = 4;
   */
  endpoints: string[] = [];

  /**
   * when is the collaboration created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<Collaboration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Collaboration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app", kind: "message", T: App },
    { no: 2, name: "app_owner", kind: "message", T: User },
    { no: 3, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collaboration {
    return new Collaboration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collaboration {
    return new Collaboration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collaboration {
    return new Collaboration().fromJsonString(jsonString, options);
  }

  static equals(a: Collaboration | PlainMessage<Collaboration> | undefined, b: Collaboration | PlainMessage<Collaboration> | undefined): boolean {
    return proto3.util.equals(Collaboration, a, b);
  }
}

/**
 * Audio asset struct
 *
 * @generated from message clarifai.api.Audio
 */
export class Audio extends Message<Audio> {
  /**
   * This is a URL to a publicly accessible image file. The platform will download this file server
   * side and then process.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * The base64 field is using image file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   *
   * @generated from field: bytes base64 = 2;
   */
  base64 = new Uint8Array(0);

  /**
   * If True then you will be allowed to have multiple urls.
   *
   * @generated from field: bool allow_duplicate_url = 4;
   */
  allowDuplicateUrl = false;

  /**
   * The hosted field lists original audio hosted in Clarifai storage. This field is currently used
   * only in response.
   *
   * @generated from field: clarifai.api.HostedURL hosted = 5;
   */
  hosted?: HostedURL;

  /**
   * audio info
   *
   * @generated from field: clarifai.api.AudioInfo audio_info = 6;
   */
  audioInfo?: AudioInfo;

  constructor(data?: PartialMessage<Audio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Audio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base64", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "allow_duplicate_url", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "hosted", kind: "message", T: HostedURL },
    { no: 6, name: "audio_info", kind: "message", T: AudioInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Audio {
    return new Audio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Audio {
    return new Audio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Audio {
    return new Audio().fromJsonString(jsonString, options);
  }

  static equals(a: Audio | PlainMessage<Audio> | undefined, b: Audio | PlainMessage<Audio> | undefined): boolean {
    return proto3.util.equals(Audio, a, b);
  }
}

/**
 * @generated from message clarifai.api.AudioInfo
 */
export class AudioInfo extends Message<AudioInfo> {
  /**
   * audio format
   *
   * @generated from field: string audio_format = 1;
   */
  audioFormat = "";

  /**
   * sample rate
   *
   * @generated from field: int32 sample_rate = 2;
   */
  sampleRate = 0;

  /**
   * audio track duration in seconds
   *
   * @generated from field: float duration_seconds = 3;
   */
  durationSeconds = 0;

  /**
   * audio track bit rate
   *
   * @generated from field: int32 bit_rate = 4;
   */
  bitRate = 0;

  constructor(data?: PartialMessage<AudioInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AudioInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "audio_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sample_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "duration_seconds", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "bit_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioInfo {
    return new AudioInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioInfo {
    return new AudioInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioInfo {
    return new AudioInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AudioInfo | PlainMessage<AudioInfo> | undefined, b: AudioInfo | PlainMessage<AudioInfo> | undefined): boolean {
    return proto3.util.equals(AudioInfo, a, b);
  }
}

/**
 * Track proto encodes information of a track over a number of frames
 *
 * @generated from message clarifai.api.Track
 */
export class Track extends Message<Track> {
  /**
   * track id
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * This is a recursive definition which can contain all the concepts,
   * embeddings, etc. that are computed within this track.
   *
   * @generated from field: clarifai.api.Data data = 2;
   */
  data?: Data;

  /**
   * @generated from field: clarifai.api.TimeInfo time_info = 4;
   */
  timeInfo?: TimeInfo;

  /**
   * @generated from field: float quality = 5;
   */
  quality = 0;

  constructor(data?: PartialMessage<Track>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Track";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data", kind: "message", T: Data },
    { no: 4, name: "time_info", kind: "message", T: TimeInfo },
    { no: 5, name: "quality", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Track {
    return new Track().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Track {
    return new Track().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Track {
    return new Track().fromJsonString(jsonString, options);
  }

  static equals(a: Track | PlainMessage<Track> | undefined, b: Track | PlainMessage<Track> | undefined): boolean {
    return proto3.util.equals(Track, a, b);
  }
}

/**
 * BillingCycle for billing purposes - old billing
 *
 * @generated from message clarifai.api.BillingCycle
 */
export class BillingCycle extends Message<BillingCycle> {
  /**
   * When the billing cycle starts. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp start_date = 1;
   */
  startDate?: Timestamp;

  /**
   * When the billing cycle ends.
   *
   * @generated from field: google.protobuf.Timestamp end_date = 2;
   */
  endDate?: Timestamp;

  /**
   * @generated from field: int32 cycle_id = 3;
   */
  cycleId = 0;

  constructor(data?: PartialMessage<BillingCycle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.BillingCycle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_date", kind: "message", T: Timestamp },
    { no: 2, name: "end_date", kind: "message", T: Timestamp },
    { no: 3, name: "cycle_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BillingCycle {
    return new BillingCycle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BillingCycle {
    return new BillingCycle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BillingCycle {
    return new BillingCycle().fromJsonString(jsonString, options);
  }

  static equals(a: BillingCycle | PlainMessage<BillingCycle> | undefined, b: BillingCycle | PlainMessage<BillingCycle> | undefined): boolean {
    return proto3.util.equals(BillingCycle, a, b);
  }
}

/**
 * UsageCycle for billing purposes
 *
 * @generated from message clarifai.api.UsageCycle
 */
export class UsageCycle extends Message<UsageCycle> {
  /**
   * When the billing cycle starts. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp start_date = 1;
   */
  startDate?: Timestamp;

  /**
   * When the usage cycle ends.
   *
   * @generated from field: google.protobuf.Timestamp end_date = 2;
   */
  endDate?: Timestamp;

  /**
   * @generated from field: string cycle_id = 3;
   */
  cycleId = "";

  /**
   * @generated from field: int32 cycle_epoch = 4;
   */
  cycleEpoch = 0;

  constructor(data?: PartialMessage<UsageCycle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UsageCycle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_date", kind: "message", T: Timestamp },
    { no: 2, name: "end_date", kind: "message", T: Timestamp },
    { no: 3, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cycle_epoch", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageCycle {
    return new UsageCycle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageCycle {
    return new UsageCycle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageCycle {
    return new UsageCycle().fromJsonString(jsonString, options);
  }

  static equals(a: UsageCycle | PlainMessage<UsageCycle> | undefined, b: UsageCycle | PlainMessage<UsageCycle> | undefined): boolean {
    return proto3.util.equals(UsageCycle, a, b);
  }
}

/**
 * InvoiceItem
 *
 * @generated from message clarifai.api.InvoiceItem
 */
export class InvoiceItem extends Message<InvoiceItem> {
  /**
   * @generated from field: string op_type = 1;
   */
  opType = "";

  /**
   * @generated from field: string bill_type = 2;
   */
  billType = "";

  /**
   * @generated from field: double price_per_op = 3;
   */
  pricePerOp = 0;

  /**
   * @generated from field: double count = 4;
   */
  count = 0;

  /**
   * @generated from field: double dollars = 5;
   */
  dollars = 0;

  /**
   * @generated from field: string notes = 6;
   */
  notes = "";

  constructor(data?: PartialMessage<InvoiceItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InvoiceItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bill_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price_per_op", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "count", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "dollars", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvoiceItem {
    return new InvoiceItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvoiceItem {
    return new InvoiceItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvoiceItem {
    return new InvoiceItem().fromJsonString(jsonString, options);
  }

  static equals(a: InvoiceItem | PlainMessage<InvoiceItem> | undefined, b: InvoiceItem | PlainMessage<InvoiceItem> | undefined): boolean {
    return proto3.util.equals(InvoiceItem, a, b);
  }
}

/**
 * Cluster data
 *
 * @generated from message clarifai.api.Cluster
 */
export class Cluster extends Message<Cluster> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Number of annotations tied to the cluster in the app
   *
   * @generated from field: uint32 count = 2;
   */
  count = 0;

  /**
   * The score assigned to this cluster.
   * For List Clusters endpoint, this represents percentage of inputs in the app assigned to this cluster.
   *
   * @generated from field: float score = 3;
   */
  score = 0;

  /**
   * Representative hits for cluster (for now we only return 1)
   *
   * @generated from field: repeated clarifai.api.Hit hits = 4;
   */
  hits: Hit[] = [];

  /**
   * @generated from field: repeated float projection = 5;
   */
  projection: number[] = [];

  constructor(data?: PartialMessage<Cluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Cluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "hits", kind: "message", T: Hit, repeated: true },
    { no: 5, name: "projection", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cluster {
    return new Cluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJsonString(jsonString, options);
  }

  static equals(a: Cluster | PlainMessage<Cluster> | undefined, b: Cluster | PlainMessage<Cluster> | undefined): boolean {
    return proto3.util.equals(Cluster, a, b);
  }
}

/**
 * Color data
 *
 * @generated from message clarifai.api.Color
 */
export class Color extends Message<Color> {
  /**
   * @generated from field: string raw_hex = 1;
   */
  rawHex = "";

  /**
   * @generated from field: clarifai.api.W3C w3c = 2;
   */
  w3c?: W3C;

  /**
   * @generated from field: float value = 3;
   */
  value = 0;

  constructor(data?: PartialMessage<Color>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Color";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "raw_hex", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "w3c", kind: "message", T: W3C },
    { no: 3, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Color {
    return new Color().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Color {
    return new Color().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Color {
    return new Color().fromJsonString(jsonString, options);
  }

  static equals(a: Color | PlainMessage<Color> | undefined, b: Color | PlainMessage<Color> | undefined): boolean {
    return proto3.util.equals(Color, a, b);
  }
}

/**
 * @generated from message clarifai.api.W3C
 */
export class W3C extends Message<W3C> {
  /**
   * @generated from field: string hex = 1;
   */
  hex = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<W3C>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.W3C";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hex", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): W3C {
    return new W3C().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): W3C {
    return new W3C().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): W3C {
    return new W3C().fromJsonString(jsonString, options);
  }

  static equals(a: W3C | PlainMessage<W3C> | undefined, b: W3C | PlainMessage<W3C> | undefined): boolean {
    return proto3.util.equals(W3C, a, b);
  }
}

/**
 * Common message to identify the app in a url endpoint.
 *
 * @generated from message clarifai.api.UserAppIDSet
 */
export class UserAppIDSet extends Message<UserAppIDSet> {
  /**
   * Note user_id 'me' is reserved - it is the alias for the id of authorized user
   *
   * @generated from field: string user_id = 1;
   */
  userId = "";

  /**
   * @generated from field: string app_id = 2;
   */
  appId = "";

  constructor(data?: PartialMessage<UserAppIDSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserAppIDSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserAppIDSet {
    return new UserAppIDSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserAppIDSet {
    return new UserAppIDSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserAppIDSet {
    return new UserAppIDSet().fromJsonString(jsonString, options);
  }

  static equals(a: UserAppIDSet | PlainMessage<UserAppIDSet> | undefined, b: UserAppIDSet | PlainMessage<UserAppIDSet> | undefined): boolean {
    return proto3.util.equals(UserAppIDSet, a, b);
  }
}

/**
 * PatchAction
 *
 * @generated from message clarifai.api.PatchAction
 */
export class PatchAction extends Message<PatchAction> {
  /**
   * The operation to perform on the patched metadata given a path
   * For now only operations 'overwrite', 'delete, and 'merge' is supported
   *
   * @generated from field: string op = 1;
   */
  op = "";

  /**
   * If the action is 'merge' and there is a conflict, how to resolve it.
   * The options are
   * 'overwrite_by_id', 'remove_by_id', 'merge_by_id','overwrite', 'append' and 'do_nothing'
   * Note that for conflict resolutions '*_by_id' to work on a list, the list should contain
   * objects with an 'id' field which will be used to uniquely identify each field. For example
   * Patching existing json
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": 2
   *     }
   *   ]
   * }
   * with op 'merge' and merge_conflict_resolution 'overwrite_by_id'
   * {
   *   "tag": [
   *     {
   *       "id": "2",
   *       "data": 3
   *     }
   *   ]
   * }
   * would produce
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": 3
   *     }
   *   ]
   * }
   * while with merge_conflict_resolution 'remove_by_id' it would produce
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     }
   *   ]
   * }
   * 
   * Option 'append' will simply create a list on conflicts. For example in above example
   * the final result would be
   * {
   *   "tag": [
   *     {
   *       "id": "1",
   *       "data": 1
   *     },
   *     {
   *       "id": "2",
   *       "data": [2, 3]
   *     }
   *   ]
   * }
   *
   * @generated from field: string merge_conflict_resolution = 2;
   */
  mergeConflictResolution = "";

  /**
   * Path for the change. For example 'tag[1].data' is a valid path in above example.
   * Default path is root level i.e. ''.
   *
   * @generated from field: string path = 3;
   */
  path = "";

  constructor(data?: PartialMessage<PatchAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PatchAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "merge_conflict_resolution", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PatchAction {
    return new PatchAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PatchAction {
    return new PatchAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PatchAction {
    return new PatchAction().fromJsonString(jsonString, options);
  }

  static equals(a: PatchAction | PlainMessage<PatchAction> | undefined, b: PatchAction | PlainMessage<PatchAction> | undefined): boolean {
    return proto3.util.equals(PatchAction, a, b);
  }
}

/**
 * Concept or tag
 *
 * @generated from message clarifai.api.Concept
 */
export class Concept extends Message<Concept> {
  /**
   * The concept's unique id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The name of the concept in the given language.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Used to indicate presence (1.0) or not (0.0) of this concept when making a request.
   * This is also the prediction probability when returning predictions from our API.
   * For convenience we use the default of 1.0 when making requests so the concept you provide is
   * is treated as a positive (1.0) and not a negative (which would be value == 0.0).
   *
   * @generated from field: float value = 3;
   */
  value = 0;

  /**
   * When the concept was created. The format is https://www.ietf.org/rfc/rfc3339.txt .
   * Example: "2006-01-02T15:04:05.999999Z". This field is used only in a response.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  /**
   * The language in which the concept name is in. This is *ONLY* used in the response and setting
   * it in a request is ignored since the default language of your app is used when creating
   * or patching a Concept. To set other languages for your concept use the ConceptLanguage object
   * and its corresponding endpoints.
   *
   * @generated from field: string language = 5;
   */
  language = "";

  /**
   * The application id that this concept is within. This can be ignored by most users.
   *
   * @generated from field: string app_id = 6;
   */
  appId = "";

  /**
   * The definition for the concept. Similar to name. This can be ignored by most users.
   *
   * @generated from field: string definition = 7;
   */
  definition = "";

  /**
   * The vocabulary that this concept belongs to. This is useful if you have different unique sets
   * of concepts that you can separate out based on this field. For example "age_appearance" vs
   * "gender_appearance" in a list of concept returned from the demographics model.
   *
   * @generated from field: string vocab_id = 8;
   */
  vocabId = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 9;
   */
  visibility?: Visibility;

  /**
   * The user the concept belongs to.
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * Information about keypoints for this concept
   *
   * @generated from field: clarifai.api.KeypointInfo keypoint_info = 11;
   */
  keypointInfo?: KeypointInfo;

  constructor(data?: PartialMessage<Concept>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Concept";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "created_at", kind: "message", T: Timestamp },
    { no: 5, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "definition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "vocab_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "visibility", kind: "message", T: Visibility },
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "keypoint_info", kind: "message", T: KeypointInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Concept {
    return new Concept().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Concept {
    return new Concept().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Concept {
    return new Concept().fromJsonString(jsonString, options);
  }

  static equals(a: Concept | PlainMessage<Concept> | undefined, b: Concept | PlainMessage<Concept> | undefined): boolean {
    return proto3.util.equals(Concept, a, b);
  }
}

/**
 * @generated from message clarifai.api.KeypointInfo
 */
export class KeypointInfo extends Message<KeypointInfo> {
  /**
   * Names of the keypoints
   *
   * @generated from field: repeated string keypoint_names = 1;
   */
  keypointNames: string[] = [];

  /**
   * Defines the connections between keypoint_names. Each value represents the index in keypoint_names.
   *
   * @generated from field: repeated clarifai.api.KeypointEdge skeleton = 2;
   */
  skeleton: KeypointEdge[] = [];

  constructor(data?: PartialMessage<KeypointInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.KeypointInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keypoint_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "skeleton", kind: "message", T: KeypointEdge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeypointInfo {
    return new KeypointInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeypointInfo {
    return new KeypointInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeypointInfo {
    return new KeypointInfo().fromJsonString(jsonString, options);
  }

  static equals(a: KeypointInfo | PlainMessage<KeypointInfo> | undefined, b: KeypointInfo | PlainMessage<KeypointInfo> | undefined): boolean {
    return proto3.util.equals(KeypointInfo, a, b);
  }
}

/**
 * @generated from message clarifai.api.KeypointEdge
 */
export class KeypointEdge extends Message<KeypointEdge> {
  /**
   * @generated from field: uint32 k1 = 1;
   */
  k1 = 0;

  /**
   * @generated from field: uint32 k2 = 2;
   */
  k2 = 0;

  constructor(data?: PartialMessage<KeypointEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.KeypointEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "k1", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "k2", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeypointEdge {
    return new KeypointEdge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeypointEdge {
    return new KeypointEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeypointEdge {
    return new KeypointEdge().fromJsonString(jsonString, options);
  }

  static equals(a: KeypointEdge | PlainMessage<KeypointEdge> | undefined, b: KeypointEdge | PlainMessage<KeypointEdge> | undefined): boolean {
    return proto3.util.equals(KeypointEdge, a, b);
  }
}

/**
 * ConceptCount
 *
 * @generated from message clarifai.api.ConceptCount
 */
export class ConceptCount extends Message<ConceptCount> {
  /**
   * The concept's unique id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The name of the concept.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The total count for concepts labeled for all asset statues (processing, to_process, processed, error)
   *
   * @generated from field: clarifai.api.ConceptTypeCount concept_type_count = 3;
   */
  conceptTypeCount?: ConceptTypeCount;

  /**
   * The detail count for different assets status
   *
   * @generated from field: clarifai.api.DetailConceptCount detail_concept_count = 4;
   */
  detailConceptCount?: DetailConceptCount;

  constructor(data?: PartialMessage<ConceptCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "concept_type_count", kind: "message", T: ConceptTypeCount },
    { no: 4, name: "detail_concept_count", kind: "message", T: DetailConceptCount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptCount {
    return new ConceptCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptCount {
    return new ConceptCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptCount {
    return new ConceptCount().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptCount | PlainMessage<ConceptCount> | undefined, b: ConceptCount | PlainMessage<ConceptCount> | undefined): boolean {
    return proto3.util.equals(ConceptCount, a, b);
  }
}

/**
 * ConceptTypeCount
 *
 * @generated from message clarifai.api.ConceptTypeCount
 */
export class ConceptTypeCount extends Message<ConceptTypeCount> {
  /**
   * The number of inputs that have a concept with a value of 1.0 (indicating presence of the
   * concept in an input).
   *
   * @generated from field: uint32 positive = 1;
   */
  positive = 0;

  /**
   * The number of inputs that have a concept with a value of 0.0 (indicating absence of the
   * concept in an input).
   *
   * @generated from field: uint32 negative = 2;
   */
  negative = 0;

  constructor(data?: PartialMessage<ConceptTypeCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptTypeCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positive", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "negative", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptTypeCount {
    return new ConceptTypeCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptTypeCount {
    return new ConceptTypeCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptTypeCount {
    return new ConceptTypeCount().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptTypeCount | PlainMessage<ConceptTypeCount> | undefined, b: ConceptTypeCount | PlainMessage<ConceptTypeCount> | undefined): boolean {
    return proto3.util.equals(ConceptTypeCount, a, b);
  }
}

/**
 * DetailConceptCount
 *
 * @generated from message clarifai.api.DetailConceptCount
 */
export class DetailConceptCount extends Message<DetailConceptCount> {
  /**
   * The concept count for processed assets
   *
   * @generated from field: clarifai.api.ConceptTypeCount processed = 1;
   */
  processed?: ConceptTypeCount;

  /**
   * The concept count for to process assets
   *
   * @generated from field: clarifai.api.ConceptTypeCount to_process = 2;
   */
  toProcess?: ConceptTypeCount;

  /**
   * The concept count for assets with status error
   *
   * @generated from field: clarifai.api.ConceptTypeCount errors = 3;
   */
  errors?: ConceptTypeCount;

  /**
   * The concept count for processing assets
   *
   * @generated from field: clarifai.api.ConceptTypeCount processing = 4;
   */
  processing?: ConceptTypeCount;

  constructor(data?: PartialMessage<DetailConceptCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DetailConceptCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processed", kind: "message", T: ConceptTypeCount },
    { no: 2, name: "to_process", kind: "message", T: ConceptTypeCount },
    { no: 3, name: "errors", kind: "message", T: ConceptTypeCount },
    { no: 4, name: "processing", kind: "message", T: ConceptTypeCount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DetailConceptCount {
    return new DetailConceptCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DetailConceptCount {
    return new DetailConceptCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DetailConceptCount {
    return new DetailConceptCount().fromJsonString(jsonString, options);
  }

  static equals(a: DetailConceptCount | PlainMessage<DetailConceptCount> | undefined, b: DetailConceptCount | PlainMessage<DetailConceptCount> | undefined): boolean {
    return proto3.util.equals(DetailConceptCount, a, b);
  }
}

/**
 * ConceptQuery
 *
 * @generated from message clarifai.api.ConceptQuery
 */
export class ConceptQuery extends Message<ConceptQuery> {
  /**
   * The name of the concept to search.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * (optional) The language of the concept name in a search. Defaults to English.
   *
   * @generated from field: string language = 2;
   */
  language = "";

  /**
   * (optional) The id of workflow. If no id is provided, then application base workflow is used.
   *
   * @generated from field: string workflow_id = 3;
   */
  workflowId = "";

  constructor(data?: PartialMessage<ConceptQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptQuery {
    return new ConceptQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptQuery {
    return new ConceptQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptQuery {
    return new ConceptQuery().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptQuery | PlainMessage<ConceptQuery> | undefined, b: ConceptQuery | PlainMessage<ConceptQuery> | undefined): boolean {
    return proto3.util.equals(ConceptQuery, a, b);
  }
}

/**
 * This represents a relation (i.e. edge) between the subject concept and the object concept
 *
 * @generated from message clarifai.api.ConceptRelation
 */
export class ConceptRelation extends Message<ConceptRelation> {
  /**
   * ID of the concept relation
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The subject concept (i.e. source) of the concept relation
   *
   * @generated from field: clarifai.api.Concept subject_concept = 2;
   */
  subjectConcept?: Concept;

  /**
   * The subject concept (i.e. destination) of the concept relation
   *
   * @generated from field: clarifai.api.Concept object_concept = 3;
   */
  objectConcept?: Concept;

  /**
   * The predicate (i.e. edge) linking the subject and the object
   * Both subject_concept and object_concept are concepts.
   * The predicate is the type of relationship.
   * That predicate acts on the subject.
   * 
   * There are three current types of predicates:
   * 1) "hyponym"
   * 2) "hypernym"
   * 3) "synonym"
   * 
   * 1) For example, 'hyponym' is a type of predicate which represents 'is_a_kind_of' relation so
   * the following relationship:
   * 'honey' (subject), 'hyponym' (predicate), 'food' (object)
   * Can more easily be read as:
   * 'honey' 'is a kind of' 'food'
   * 
   * 
   * 2) The 'hypernym' relation is the opposite of 'hyponym' and when you add one of the
   * relationships the opposite will automatically appear for you in queries.
   * 
   * The 'hypernym' can be read as 'is a parent of' so:
   * 'food' (subject), 'hypernym' (predicate), 'honey' (object)
   * Can more easily be read as:
   * 'food' is a parent of 'honey'
   * 
   * 3) The 'synonym' relation defines two concepts that essential mean the same thing. This
   * is more like a "is" relationship. So for example a 'synonym' relationship could be:
   * "puppy" is "pup"
   * The reverse is also true once the former is added so:
   * "pup" is "puppy"
   * will appear in queries as well.
   *
   * @generated from field: string predicate = 4;
   */
  predicate = "";

  /**
   * The knowledge graph id that this edge belongs to. If using the app's global knowledge graph
   * and not a specific one then this should be the empty string "".
   *
   * @generated from field: string knowledge_graph_id = 5;
   */
  knowledgeGraphId = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 6;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<ConceptRelation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptRelation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subject_concept", kind: "message", T: Concept },
    { no: 3, name: "object_concept", kind: "message", T: Concept },
    { no: 4, name: "predicate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "knowledge_graph_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptRelation {
    return new ConceptRelation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptRelation {
    return new ConceptRelation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptRelation {
    return new ConceptRelation().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptRelation | PlainMessage<ConceptRelation> | undefined, b: ConceptRelation | PlainMessage<ConceptRelation> | undefined): boolean {
    return proto3.util.equals(ConceptRelation, a, b);
  }
}

/**
 * A Knowledge Graph is a logical subsets of edges in the overall Concept Graph
 *
 * @generated from message clarifai.api.KnowledgeGraph
 */
export class KnowledgeGraph extends Message<KnowledgeGraph> {
  /**
   * ID of the knowledge graph
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Name of the knowledge graph
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Human readable description of the knowledge graph
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The app that contains the images that correspond to the concepts in the knowledge graph
   *
   * @generated from field: string examples_app_id = 4;
   */
  examplesAppId = "";

  /**
   * The app that contains the sample images that we want to show the customer for the concepts in the knowledge graph
   *
   * @generated from field: string sampled_examples_app_id = 5;
   */
  sampledExamplesAppId = "";

  constructor(data?: PartialMessage<KnowledgeGraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.KnowledgeGraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "examples_app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sampled_examples_app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KnowledgeGraph {
    return new KnowledgeGraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KnowledgeGraph {
    return new KnowledgeGraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KnowledgeGraph {
    return new KnowledgeGraph().fromJsonString(jsonString, options);
  }

  static equals(a: KnowledgeGraph | PlainMessage<KnowledgeGraph> | undefined, b: KnowledgeGraph | PlainMessage<KnowledgeGraph> | undefined): boolean {
    return proto3.util.equals(KnowledgeGraph, a, b);
  }
}

/**
 * ConceptMapping
 *
 * @generated from message clarifai.api.ConceptMapping
 */
export class ConceptMapping extends Message<ConceptMapping> {
  /**
   * The customer's concept (i.e. the source concept)
   *
   * @generated from field: clarifai.api.Concept concept = 1;
   */
  concept?: Concept;

  /**
   * The concept that is being suggested (i.e. the destination concept)
   *
   * @generated from field: clarifai.api.Concept suggested_concept = 2;
   */
  suggestedConcept?: Concept;

  /**
   * Flag represented whether or not the customer confirmed this mapping
   *
   * @generated from field: bool customer_confirmed = 3;
   */
  customerConfirmed = false;

  /**
   * When the record was last created or modified
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<ConceptMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concept", kind: "message", T: Concept },
    { no: 2, name: "suggested_concept", kind: "message", T: Concept },
    { no: 3, name: "customer_confirmed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptMapping {
    return new ConceptMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptMapping {
    return new ConceptMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptMapping {
    return new ConceptMapping().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptMapping | PlainMessage<ConceptMapping> | undefined, b: ConceptMapping | PlainMessage<ConceptMapping> | undefined): boolean {
    return proto3.util.equals(ConceptMapping, a, b);
  }
}

/**
 * ConceptMappingJob
 *
 * @generated from message clarifai.api.ConceptMappingJob
 */
export class ConceptMappingJob extends Message<ConceptMappingJob> {
  /**
   * The id of the knowledge graph being used for this concept mapping job
   *
   * @generated from field: string knowledge_graph_id = 1;
   */
  knowledgeGraphId = "";

  /**
   * The ids of the concepts being mapped
   *
   * @generated from field: repeated string concept_ids = 2;
   */
  conceptIds: string[] = [];

  constructor(data?: PartialMessage<ConceptMappingJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptMappingJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "knowledge_graph_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "concept_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptMappingJob {
    return new ConceptMappingJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptMappingJob {
    return new ConceptMappingJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptMappingJob {
    return new ConceptMappingJob().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptMappingJob | PlainMessage<ConceptMappingJob> | undefined, b: ConceptMappingJob | PlainMessage<ConceptMappingJob> | undefined): boolean {
    return proto3.util.equals(ConceptMappingJob, a, b);
  }
}

/**
 * This represents a link to an outside source for the given concept.
 * The values from here are sticked into Concept message into the name and definition fields when
 * returning from the API in your default language. The "id" field here becomes the "language"
 * field of the Concept message which is a little weird.
 *
 * @generated from message clarifai.api.ConceptLanguage
 */
export class ConceptLanguage extends Message<ConceptLanguage> {
  /**
   * This is the language code for the language such as "en".
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The type of the outside source.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The ID that is referenced in the source.
   *
   * @generated from field: string definition = 3;
   */
  definition = "";

  constructor(data?: PartialMessage<ConceptLanguage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptLanguage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "definition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptLanguage {
    return new ConceptLanguage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptLanguage {
    return new ConceptLanguage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptLanguage {
    return new ConceptLanguage().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptLanguage | PlainMessage<ConceptLanguage> | undefined, b: ConceptLanguage | PlainMessage<ConceptLanguage> | undefined): boolean {
    return proto3.util.equals(ConceptLanguage, a, b);
  }
}

/**
 * This represents a link to an outside source for the given concept.
 *
 * @generated from message clarifai.api.ConceptReference
 */
export class ConceptReference extends Message<ConceptReference> {
  /**
   * The link's unique id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The type of the outside source.
   *
   * @generated from field: string source = 2;
   */
  source = "";

  /**
   * The ID that is referenced in the source.
   *
   * @generated from field: string source_id = 3;
   */
  sourceId = "";

  /**
   * A url (if available) to the outside source. Usually built from the foreign_id
   *
   * @generated from field: string source_url = 4;
   */
  sourceUrl = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 5;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<ConceptReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConceptReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "source_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConceptReference {
    return new ConceptReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConceptReference {
    return new ConceptReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConceptReference {
    return new ConceptReference().fromJsonString(jsonString, options);
  }

  static equals(a: ConceptReference | PlainMessage<ConceptReference> | undefined, b: ConceptReference | PlainMessage<ConceptReference> | undefined): boolean {
    return proto3.util.equals(ConceptReference, a, b);
  }
}

/**
 * Data
 *
 * @generated from message clarifai.api.Data
 */
export class Data extends Message<Data> {
  /**
   * Input and output images.
   *
   * @generated from field: clarifai.api.Image image = 1;
   */
  image?: Image;

  /**
   * Input and output videos.
   *
   * @generated from field: clarifai.api.Video video = 2;
   */
  video?: Video;

  /**
   * A list of concepts.
   *
   * @generated from field: repeated clarifai.api.Concept concepts = 3;
   */
  concepts: Concept[] = [];

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: Struct;

  /**
   * Geography information.
   *
   * @generated from field: clarifai.api.Geo geo = 6;
   */
  geo?: Geo;

  /**
   * The dominant colors within an image.
   *
   * @generated from field: repeated clarifai.api.Color colors = 7;
   */
  colors: Color[] = [];

  /**
   * Clustering centroids for inputs.
   *
   * @generated from field: repeated clarifai.api.Cluster clusters = 8;
   */
  clusters: Cluster[] = [];

  /**
   * Embedding vectors representing each input.
   *
   * @generated from field: repeated clarifai.api.Embedding embeddings = 9;
   */
  embeddings: Embedding[] = [];

  /**
   * For recursing into localized regions of an input.
   *
   * @generated from field: repeated clarifai.api.Region regions = 11;
   */
  regions: Region[] = [];

  /**
   * For temporal content like video.
   *
   * @generated from field: repeated clarifai.api.Frame frames = 12;
   */
  frames: Frame[] = [];

  /**
   * Input, output or annotation text.
   *
   * @generated from field: clarifai.api.Text text = 13;
   */
  text?: Text;

  /**
   * Input and output audio.
   *
   * @generated from field: clarifai.api.Audio audio = 14;
   */
  audio?: Audio;

  /**
   * Track information.
   *
   * @generated from field: repeated clarifai.api.Track tracks = 15;
   */
  tracks: Track[] = [];

  /**
   * Time segments information.
   *
   * @generated from field: repeated clarifai.api.TimeSegment time_segments = 16;
   */
  timeSegments: TimeSegment[] = [];

  /**
   * Holds score, rank, and user, app, input IDs and search hit data
   *
   * @generated from field: repeated clarifai.api.Hit hits = 17;
   */
  hits: Hit[] = [];

  /**
   * Heatmap as 2d image
   *
   * @generated from field: repeated clarifai.api.Image heatmaps = 18;
   */
  heatmaps: Image[] = [];

  constructor(data?: PartialMessage<Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "message", T: Image },
    { no: 2, name: "video", kind: "message", T: Video },
    { no: 3, name: "concepts", kind: "message", T: Concept, repeated: true },
    { no: 5, name: "metadata", kind: "message", T: Struct },
    { no: 6, name: "geo", kind: "message", T: Geo },
    { no: 7, name: "colors", kind: "message", T: Color, repeated: true },
    { no: 8, name: "clusters", kind: "message", T: Cluster, repeated: true },
    { no: 9, name: "embeddings", kind: "message", T: Embedding, repeated: true },
    { no: 11, name: "regions", kind: "message", T: Region, repeated: true },
    { no: 12, name: "frames", kind: "message", T: Frame, repeated: true },
    { no: 13, name: "text", kind: "message", T: Text },
    { no: 14, name: "audio", kind: "message", T: Audio },
    { no: 15, name: "tracks", kind: "message", T: Track, repeated: true },
    { no: 16, name: "time_segments", kind: "message", T: TimeSegment, repeated: true },
    { no: 17, name: "hits", kind: "message", T: Hit, repeated: true },
    { no: 18, name: "heatmaps", kind: "message", T: Image, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto3.util.equals(Data, a, b);
  }
}

/**
 * A region within the data.
 *
 * @generated from message clarifai.api.Region
 */
export class Region extends Message<Region> {
  /**
   * A unique id for the region.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The details about the location of the region.
   *
   * @generated from field: clarifai.api.RegionInfo region_info = 2;
   */
  regionInfo?: RegionInfo;

  /**
   * A recursive definition of the data within the Region. For example, this will contain
   * data.concepts if the region also has annotations or predictions of concepts within it.
   *
   * @generated from field: clarifai.api.Data data = 3;
   */
  data?: Data;

  /**
   * This is the confidence score of the overall Region.
   *
   * @generated from field: float value = 4;
   */
  value = 0;

  /**
   * For tracking algorithsm and annotations we tie regions together with this track id.
   *
   * @generated from field: string track_id = 5;
   */
  trackId = "";

  constructor(data?: PartialMessage<Region>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Region";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region_info", kind: "message", T: RegionInfo },
    { no: 3, name: "data", kind: "message", T: Data },
    { no: 4, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "track_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Region {
    return new Region().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Region {
    return new Region().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Region {
    return new Region().fromJsonString(jsonString, options);
  }

  static equals(a: Region | PlainMessage<Region> | undefined, b: Region | PlainMessage<Region> | undefined): boolean {
    return proto3.util.equals(Region, a, b);
  }
}

/**
 * The information of the location of the Region.
 *
 * @generated from message clarifai.api.RegionInfo
 */
export class RegionInfo extends Message<RegionInfo> {
  /**
   * Details of the region's rectangular bounding box.
   *
   * @generated from field: clarifai.api.BoundingBox bounding_box = 1;
   */
  boundingBox?: BoundingBox;

  /**
   * Details of the region's segmentation mask.
   *
   * @generated from field: clarifai.api.Mask mask = 4;
   */
  mask?: Mask;

  /**
   * A polygon of points.
   *
   * @generated from field: clarifai.api.Polygon polygon = 5;
   */
  polygon?: Polygon;

  /**
   * A landmark point location.
   *
   * @generated from field: clarifai.api.Point point = 6;
   */
  point?: Point;

  /**
   * Span char sequence for NLP.
   *
   * @generated from field: clarifai.api.Span span = 7;
   */
  span?: Span;

  /**
   * Token char sequence for NLP.
   *
   * @generated from field: clarifai.api.Token token = 8;
   */
  token?: Token;

  /**
   * The locations of detected keypoints, which are to be used in conjunction with the detected concept's skeleton to connect the keypoint locations.
   * These will be in the same order as the respective keypoint_names inside the concept.
   *
   * @generated from field: repeated clarifai.api.Point keypoint_locations = 9;
   */
  keypointLocations: Point[] = [];

  constructor(data?: PartialMessage<RegionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.RegionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bounding_box", kind: "message", T: BoundingBox },
    { no: 4, name: "mask", kind: "message", T: Mask },
    { no: 5, name: "polygon", kind: "message", T: Polygon },
    { no: 6, name: "point", kind: "message", T: Point },
    { no: 7, name: "span", kind: "message", T: Span },
    { no: 8, name: "token", kind: "message", T: Token },
    { no: 9, name: "keypoint_locations", kind: "message", T: Point, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegionInfo {
    return new RegionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegionInfo {
    return new RegionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegionInfo {
    return new RegionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RegionInfo | PlainMessage<RegionInfo> | undefined, b: RegionInfo | PlainMessage<RegionInfo> | undefined): boolean {
    return proto3.util.equals(RegionInfo, a, b);
  }
}

/**
 * Rectangular bounding box for a region.
 *
 * @generated from message clarifai.api.BoundingBox
 */
export class BoundingBox extends Message<BoundingBox> {
  /**
   * The top left of the bounding box normalized to the data dimension to be within [0-1.0]
   *
   * @generated from field: float top_row = 1;
   */
  topRow = 0;

  /**
   * The left column of the bounding box normalized to the data dimension to be within [0-1.0]
   *
   * @generated from field: float left_col = 2;
   */
  leftCol = 0;

  /**
   * The bottom row of the bounding box normalized to the data dimension to be within [0-1.0]
   *
   * @generated from field: float bottom_row = 3;
   */
  bottomRow = 0;

  /**
   * The right col of the bounding box normalized to the data dimension to be within [0-1.0]
   *
   * @generated from field: float right_col = 4;
   */
  rightCol = 0;

  constructor(data?: PartialMessage<BoundingBox>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.BoundingBox";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top_row", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "left_col", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "bottom_row", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "right_col", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoundingBox {
    return new BoundingBox().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoundingBox {
    return new BoundingBox().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoundingBox {
    return new BoundingBox().fromJsonString(jsonString, options);
  }

  static equals(a: BoundingBox | PlainMessage<BoundingBox> | undefined, b: BoundingBox | PlainMessage<BoundingBox> | undefined): boolean {
    return proto3.util.equals(BoundingBox, a, b);
  }
}

/**
 * The information of the location of the Frame.
 *
 * @generated from message clarifai.api.FrameInfo
 */
export class FrameInfo extends Message<FrameInfo> {
  /**
   * The index of the frame. Keep in mind that this depends on the sampling rate used during
   * processing.
   *
   * @generated from field: uint32 index = 1;
   */
  index = 0;

  /**
   * time in the video in milliseconds. This is independent of the sampling rates used during
   * processing.
   *
   * @generated from field: uint32 time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<FrameInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.FrameInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrameInfo {
    return new FrameInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrameInfo {
    return new FrameInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrameInfo {
    return new FrameInfo().fromJsonString(jsonString, options);
  }

  static equals(a: FrameInfo | PlainMessage<FrameInfo> | undefined, b: FrameInfo | PlainMessage<FrameInfo> | undefined): boolean {
    return proto3.util.equals(FrameInfo, a, b);
  }
}

/**
 * A Frame of time-series Data such as a Video.
 *
 * @generated from message clarifai.api.Frame
 */
export class Frame extends Message<Frame> {
  /**
   * Information aboue frame such as number and time.
   *
   * @generated from field: clarifai.api.FrameInfo frame_info = 1;
   */
  frameInfo?: FrameInfo;

  /**
   * A recursive definition of the data within the Frame. For example, this will contain
   * data.concepts if the Frame also has annotations or predictions of concepts within it.
   * This can also have data.regions for annotation or predictions of detection regions, which can
   * then recursively have their data field filled in as well.
   *
   * @generated from field: clarifai.api.Data data = 2;
   */
  data?: Data;

  /**
   * An ID for the frame.
   *
   * @generated from field: string id = 3;
   */
  id = "";

  constructor(data?: PartialMessage<Frame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Frame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "frame_info", kind: "message", T: FrameInfo },
    { no: 2, name: "data", kind: "message", T: Data },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Frame {
    return new Frame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Frame {
    return new Frame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Frame {
    return new Frame().fromJsonString(jsonString, options);
  }

  static equals(a: Frame | PlainMessage<Frame> | undefined, b: Frame | PlainMessage<Frame> | undefined): boolean {
    return proto3.util.equals(Frame, a, b);
  }
}

/**
 * Segmentation mask.
 *
 * @generated from message clarifai.api.Mask
 */
export class Mask extends Message<Mask> {
  /**
   * The image of the mask in a non-raster format.
   *
   * @generated from field: clarifai.api.Image image = 2;
   */
  image?: Image;

  constructor(data?: PartialMessage<Mask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Mask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "image", kind: "message", T: Image },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mask {
    return new Mask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mask {
    return new Mask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mask {
    return new Mask().fromJsonString(jsonString, options);
  }

  static equals(a: Mask | PlainMessage<Mask> | undefined, b: Mask | PlainMessage<Mask> | undefined): boolean {
    return proto3.util.equals(Mask, a, b);
  }
}

/**
 * Polygon
 *
 * @generated from message clarifai.api.Polygon
 */
export class Polygon extends Message<Polygon> {
  /**
   * A list of points connected together to form the polygon.
   *
   * @generated from field: repeated clarifai.api.Point points = 1;
   */
  points: Point[] = [];

  constructor(data?: PartialMessage<Polygon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Polygon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: Point, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Polygon {
    return new Polygon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Polygon {
    return new Polygon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Polygon {
    return new Polygon().fromJsonString(jsonString, options);
  }

  static equals(a: Polygon | PlainMessage<Polygon> | undefined, b: Polygon | PlainMessage<Polygon> | undefined): boolean {
    return proto3.util.equals(Polygon, a, b);
  }
}

/**
 * Point
 *
 * @generated from message clarifai.api.Point
 */
export class Point extends Message<Point> {
  /**
   * The row location of the point. This has a [0.0-1.0] range with 0.0 being top row and 1.0
   * being the bottom row.
   *
   * @generated from field: float row = 1;
   */
  row = 0;

  /**
   * The column location of the point. This has a [0.0-1.0] range with 0.0 being left col and 1.0
   * being the right col.
   *
   * @generated from field: float col = 2;
   */
  col = 0;

  /**
   * Depth if applicable for the point.
   *
   * @generated from field: float z = 3;
   */
  z = 0;

  /**
   * @generated from field: clarifai.api.Point.Visibility visibility = 4;
   */
  visibility = Point_Visibility.NOT_SET;

  constructor(data?: PartialMessage<Point>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Point";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "col", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "z", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "visibility", kind: "enum", T: proto3.getEnumType(Point_Visibility) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Point {
    return new Point().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJsonString(jsonString, options);
  }

  static equals(a: Point | PlainMessage<Point> | undefined, b: Point | PlainMessage<Point> | undefined): boolean {
    return proto3.util.equals(Point, a, b);
  }
}

/**
 * Whether this point is visible or occluded
 *
 * @generated from enum clarifai.api.Point.Visibility
 */
export enum Point_Visibility {
  /**
   * Visibility of the point is not set
   *
   * @generated from enum value: NOT_SET = 0;
   */
  NOT_SET = 0,

  /**
   * Point is visible
   *
   * @generated from enum value: VISIBLE = 1;
   */
  VISIBLE = 1,

  /**
   * Point is occluded
   *
   * @generated from enum value: NOT_VISIBLE = 2;
   */
  NOT_VISIBLE = 2,

  /**
   * Point is not in the image
   *
   * @generated from enum value: NOT_PRESENT = 3;
   */
  NOT_PRESENT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Point_Visibility)
proto3.util.setEnumType(Point_Visibility, "clarifai.api.Point.Visibility", [
  { no: 0, name: "NOT_SET" },
  { no: 1, name: "VISIBLE" },
  { no: 2, name: "NOT_VISIBLE" },
  { no: 3, name: "NOT_PRESENT" },
]);

/**
 * @generated from message clarifai.api.Span
 */
export class Span extends Message<Span> {
  /**
   * @generated from field: uint32 char_start = 1;
   */
  charStart = 0;

  /**
   * @generated from field: uint32 char_end = 2;
   */
  charEnd = 0;

  /**
   * @generated from field: string raw_text = 3;
   */
  rawText = "";

  constructor(data?: PartialMessage<Span>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Span";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "char_start", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "char_end", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "raw_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span {
    return new Span().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJsonString(jsonString, options);
  }

  static equals(a: Span | PlainMessage<Span> | undefined, b: Span | PlainMessage<Span> | undefined): boolean {
    return proto3.util.equals(Span, a, b);
  }
}

/**
 * @generated from message clarifai.api.Token
 */
export class Token extends Message<Token> {
  /**
   * @generated from field: uint32 char_start = 1;
   */
  charStart = 0;

  /**
   * @generated from field: uint32 char_end = 2;
   */
  charEnd = 0;

  /**
   * @generated from field: string raw_text = 3;
   */
  rawText = "";

  constructor(data?: PartialMessage<Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "char_start", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "char_end", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "raw_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Token {
    return new Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJsonString(jsonString, options);
  }

  static equals(a: Token | PlainMessage<Token> | undefined, b: Token | PlainMessage<Token> | undefined): boolean {
    return proto3.util.equals(Token, a, b);
  }
}

/**
 * Embedding
 *
 * @generated from message clarifai.api.Embedding
 */
export class Embedding extends Message<Embedding> {
  /**
   * @generated from field: repeated float vector = 1 [packed = true];
   */
  vector: number[] = [];

  /**
   * @generated from field: uint32 num_dimensions = 2;
   */
  numDimensions = 0;

  constructor(data?: PartialMessage<Embedding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Embedding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "num_dimensions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Embedding {
    return new Embedding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Embedding {
    return new Embedding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Embedding {
    return new Embedding().fromJsonString(jsonString, options);
  }

  static equals(a: Embedding | PlainMessage<Embedding> | undefined, b: Embedding | PlainMessage<Embedding> | undefined): boolean {
    return proto3.util.equals(Embedding, a, b);
  }
}

/**
 * GeoPoint
 *
 * @generated from message clarifai.api.GeoPoint
 */
export class GeoPoint extends Message<GeoPoint> {
  /**
   * @generated from field: float longitude = 1;
   */
  longitude = 0;

  /**
   * @generated from field: float latitude = 2;
   */
  latitude = 0;

  constructor(data?: PartialMessage<GeoPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.GeoPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "longitude", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "latitude", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPoint {
    return new GeoPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPoint | PlainMessage<GeoPoint> | undefined, b: GeoPoint | PlainMessage<GeoPoint> | undefined): boolean {
    return proto3.util.equals(GeoPoint, a, b);
  }
}

/**
 * GeoLimit
 *
 * @generated from message clarifai.api.GeoLimit
 */
export class GeoLimit extends Message<GeoLimit> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: float value = 2;
   */
  value = 0;

  constructor(data?: PartialMessage<GeoLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.GeoLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoLimit {
    return new GeoLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoLimit {
    return new GeoLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoLimit {
    return new GeoLimit().fromJsonString(jsonString, options);
  }

  static equals(a: GeoLimit | PlainMessage<GeoLimit> | undefined, b: GeoLimit | PlainMessage<GeoLimit> | undefined): boolean {
    return proto3.util.equals(GeoLimit, a, b);
  }
}

/**
 * GeoBoxedPoint
 *
 * @generated from message clarifai.api.GeoBoxedPoint
 */
export class GeoBoxedPoint extends Message<GeoBoxedPoint> {
  /**
   * @generated from field: clarifai.api.GeoPoint geo_point = 1;
   */
  geoPoint?: GeoPoint;

  constructor(data?: PartialMessage<GeoBoxedPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.GeoBoxedPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "geo_point", kind: "message", T: GeoPoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoBoxedPoint {
    return new GeoBoxedPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoBoxedPoint {
    return new GeoBoxedPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoBoxedPoint {
    return new GeoBoxedPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GeoBoxedPoint | PlainMessage<GeoBoxedPoint> | undefined, b: GeoBoxedPoint | PlainMessage<GeoBoxedPoint> | undefined): boolean {
    return proto3.util.equals(GeoBoxedPoint, a, b);
  }
}

/**
 * Geo
 *
 * @generated from message clarifai.api.Geo
 */
export class Geo extends Message<Geo> {
  /**
   * @generated from field: clarifai.api.GeoPoint geo_point = 1;
   */
  geoPoint?: GeoPoint;

  /**
   * @generated from field: clarifai.api.GeoLimit geo_limit = 2;
   */
  geoLimit?: GeoLimit;

  /**
   * NOTE: inconsistency: should have been geo_boxed_points
   *
   * @generated from field: repeated clarifai.api.GeoBoxedPoint geo_box = 3;
   */
  geoBox: GeoBoxedPoint[] = [];

  constructor(data?: PartialMessage<Geo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Geo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "geo_point", kind: "message", T: GeoPoint },
    { no: 2, name: "geo_limit", kind: "message", T: GeoLimit },
    { no: 3, name: "geo_box", kind: "message", T: GeoBoxedPoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Geo {
    return new Geo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Geo {
    return new Geo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Geo {
    return new Geo().fromJsonString(jsonString, options);
  }

  static equals(a: Geo | PlainMessage<Geo> | undefined, b: Geo | PlainMessage<Geo> | undefined): boolean {
    return proto3.util.equals(Geo, a, b);
  }
}

/**
 * Image
 *
 * @generated from message clarifai.api.Image
 */
export class Image extends Message<Image> {
  /**
   * This is a URL to a publicly accessible image file. The platform will download this file server
   * side and then process.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * The base64 field is using image file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   *
   * @generated from field: bytes base64 = 2;
   */
  base64 = new Uint8Array(0);

  /**
   * @generated from field: bool allow_duplicate_url = 4;
   */
  allowDuplicateUrl = false;

  /**
   * The hosted field lists images in different sizes hosted in Clarifai storage.
   *
   * @generated from field: clarifai.api.HostedURL hosted = 5;
   */
  hosted?: HostedURL;

  /**
   * image info
   *
   * @generated from field: clarifai.api.ImageInfo image_info = 6;
   */
  imageInfo?: ImageInfo;

  constructor(data?: PartialMessage<Image>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Image";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base64", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "allow_duplicate_url", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "hosted", kind: "message", T: HostedURL },
    { no: 6, name: "image_info", kind: "message", T: ImageInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Image {
    return new Image().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Image {
    return new Image().fromJsonString(jsonString, options);
  }

  static equals(a: Image | PlainMessage<Image> | undefined, b: Image | PlainMessage<Image> | undefined): boolean {
    return proto3.util.equals(Image, a, b);
  }
}

/**
 * @generated from message clarifai.api.ImageInfo
 */
export class ImageInfo extends Message<ImageInfo> {
  /**
   * width
   *
   * @generated from field: int32 width = 1;
   */
  width = 0;

  /**
   * height
   *
   * @generated from field: int32 height = 2;
   */
  height = 0;

  /**
   * image format
   *
   * @generated from field: string format = 3;
   */
  format = "";

  /**
   * image color mode
   *
   * @generated from field: string color_mode = 4;
   */
  colorMode = "";

  constructor(data?: PartialMessage<ImageInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ImageInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "width", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "color_mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageInfo {
    return new ImageInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageInfo {
    return new ImageInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageInfo {
    return new ImageInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ImageInfo | PlainMessage<ImageInfo> | undefined, b: ImageInfo | PlainMessage<ImageInfo> | undefined): boolean {
    return proto3.util.equals(ImageInfo, a, b);
  }
}

/**
 * HostedURL
 *
 * @generated from message clarifai.api.HostedURL
 */
export class HostedURL extends Message<HostedURL> {
  /**
   * Prefix of the URL of every hosted image.
   *
   * @generated from field: string prefix = 1;
   */
  prefix = "";

  /**
   * Suffix of an image stored in different sizes.
   *
   * @generated from field: string suffix = 2;
   */
  suffix = "";

  /**
   * The sizes field lists which images of the different sizes are hosted in our storage. The URL
   * of each hosted image can be obtained by joining the prefix, one of the sizes and suffix.
   *
   * @generated from field: repeated string sizes = 3;
   */
  sizes: string[] = [];

  /**
   * The crossorigin property of html media tag
   * For Secure Data Hosting this needs to be set to 'use-credentials'
   *
   * @generated from field: string crossorigin = 4;
   */
  crossorigin = "";

  constructor(data?: PartialMessage<HostedURL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.HostedURL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "suffix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sizes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "crossorigin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostedURL {
    return new HostedURL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostedURL {
    return new HostedURL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostedURL {
    return new HostedURL().fromJsonString(jsonString, options);
  }

  static equals(a: HostedURL | PlainMessage<HostedURL> | undefined, b: HostedURL | PlainMessage<HostedURL> | undefined): boolean {
    return proto3.util.equals(HostedURL, a, b);
  }
}

/**
 * Input
 *
 * @generated from message clarifai.api.Input
 */
export class Input extends Message<Input> {
  /**
   * The ID for the input
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The data passed along in this input.
   *
   * @generated from field: clarifai.api.Data data = 2;
   */
  data?: Data;

  /**
   * When the input was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  /**
   * When the input was modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 5;
   */
  modifiedAt?: Timestamp;

  /**
   * This is the status at a per Input level which allows for
   * partial failures.
   *
   * @generated from field: clarifai.api.status.Status status = 6;
   */
  status?: Status;

  /**
   * List of dataset IDs that this input is part of
   * Currently, this field is ONLY used in search.
   *
   * @generated from field: repeated string dataset_ids = 7;
   */
  datasetIds: string[] = [];

  constructor(data?: PartialMessage<Input>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Input";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data", kind: "message", T: Data },
    { no: 4, name: "created_at", kind: "message", T: Timestamp },
    { no: 5, name: "modified_at", kind: "message", T: Timestamp },
    { no: 6, name: "status", kind: "message", T: Status },
    { no: 7, name: "dataset_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Input {
    return new Input().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJsonString(jsonString, options);
  }

  static equals(a: Input | PlainMessage<Input> | undefined, b: Input | PlainMessage<Input> | undefined): boolean {
    return proto3.util.equals(Input, a, b);
  }
}

/**
 * NOTE: inconsistency: this is weird mix of plural and singular words.
 *
 * @generated from message clarifai.api.InputCount
 */
export class InputCount extends Message<InputCount> {
  /**
   * @generated from field: uint32 processed = 1;
   */
  processed = 0;

  /**
   * @generated from field: uint32 to_process = 2;
   */
  toProcess = 0;

  /**
   * @generated from field: uint32 errors = 3;
   */
  errors = 0;

  /**
   * @generated from field: uint32 processing = 4;
   */
  processing = 0;

  /**
   * @generated from field: uint32 reindexed = 5;
   */
  reindexed = 0;

  /**
   * @generated from field: uint32 to_reindex = 6;
   */
  toReindex = 0;

  /**
   * @generated from field: uint32 reindex_errors = 7;
   */
  reindexErrors = 0;

  /**
   * @generated from field: uint32 reindexing = 8;
   */
  reindexing = 0;

  constructor(data?: PartialMessage<InputCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InputCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processed", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "to_process", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "errors", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "processing", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "reindexed", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "to_reindex", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "reindex_errors", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "reindexing", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputCount {
    return new InputCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputCount {
    return new InputCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputCount {
    return new InputCount().fromJsonString(jsonString, options);
  }

  static equals(a: InputCount | PlainMessage<InputCount> | undefined, b: InputCount | PlainMessage<InputCount> | undefined): boolean {
    return proto3.util.equals(InputCount, a, b);
  }
}

/**
 * Dataset
 *
 * @generated from message clarifai.api.Dataset
 */
export class Dataset extends Message<Dataset> {
  /**
   * The ID for the dataset
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the dataset was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * When the dataset was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * The app the dataset belongs to.
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * The user the dataset belongs to.
   *
   * @generated from field: string user_id = 5;
   */
  userId = "";

  /**
   * Description of the dataset
   *
   * @generated from field: string description = 7;
   */
  description = "";

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 8;
   */
  metadata?: Struct;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 9;
   */
  visibility?: Visibility;

  /**
   * Default annotation filter used for this dataset.
   *
   * @generated from field: clarifai.api.AnnotationFilter default_annotation_filter = 12;
   */
  defaultAnnotationFilter?: AnnotationFilter;

  /**
   * Notes for the dataset
   * This field should be used for in-depth notes and supports up to 64Kbs.
   *
   * @generated from field: string notes = 11;
   */
  notes = "";

  /**
   * Dataset version associated with this dataset.
   *
   * @generated from field: clarifai.api.DatasetVersion version = 13;
   */
  version?: DatasetVersion;

  constructor(data?: PartialMessage<Dataset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Dataset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "metadata", kind: "message", T: Struct },
    { no: 9, name: "visibility", kind: "message", T: Visibility },
    { no: 12, name: "default_annotation_filter", kind: "message", T: AnnotationFilter },
    { no: 11, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "version", kind: "message", T: DatasetVersion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Dataset {
    return new Dataset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Dataset {
    return new Dataset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Dataset {
    return new Dataset().fromJsonString(jsonString, options);
  }

  static equals(a: Dataset | PlainMessage<Dataset> | undefined, b: Dataset | PlainMessage<Dataset> | undefined): boolean {
    return proto3.util.equals(Dataset, a, b);
  }
}

/**
 * AnnotationFilter is used to create a new dataset version.
 * For now, the filter is simply a wrapper over a Search.
 * In the future, we may add extra fields to customize the filtering.
 *
 * @generated from message clarifai.api.AnnotationFilter
 */
export class AnnotationFilter extends Message<AnnotationFilter> {
  /**
   * The ID for the annotation filter
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the annotation filter was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * When the annotation filter was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * The user the annotation filter belongs to.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * The app the annotation filter belongs to.
   *
   * @generated from field: string app_id = 5;
   */
  appId = "";

  /**
   * The saved search that this filter uses.
   *
   * @generated from field: clarifai.api.Search saved_search = 8;
   */
  savedSearch?: Search;

  constructor(data?: PartialMessage<AnnotationFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AnnotationFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "saved_search", kind: "message", T: Search },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotationFilter {
    return new AnnotationFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotationFilter {
    return new AnnotationFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotationFilter {
    return new AnnotationFilter().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotationFilter | PlainMessage<AnnotationFilter> | undefined, b: AnnotationFilter | PlainMessage<AnnotationFilter> | undefined): boolean {
    return proto3.util.equals(AnnotationFilter, a, b);
  }
}

/**
 * DatasetInput
 *
 * @generated from message clarifai.api.DatasetInput
 */
export class DatasetInput extends Message<DatasetInput> {
  /**
   * When the input was added to the dataset.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * The input data.
   *
   * @generated from field: clarifai.api.Input input = 2;
   */
  input?: Input;

  constructor(data?: PartialMessage<DatasetInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "created_at", kind: "message", T: Timestamp },
    { no: 2, name: "input", kind: "message", T: Input },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetInput {
    return new DatasetInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetInput {
    return new DatasetInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetInput {
    return new DatasetInput().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetInput | PlainMessage<DatasetInput> | undefined, b: DatasetInput | PlainMessage<DatasetInput> | undefined): boolean {
    return proto3.util.equals(DatasetInput, a, b);
  }
}

/**
 * DatasetVersion
 *
 * @generated from message clarifai.api.DatasetVersion
 */
export class DatasetVersion extends Message<DatasetVersion> {
  /**
   * The ID for the dataset version
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the dataset version was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * When the dataset version was modified.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * The app the dataset version belongs to.
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * The user the dataset version belongs to.
   *
   * @generated from field: string user_id = 5;
   */
  userId = "";

  /**
   * The dataset the dataset version belongs to.
   *
   * @generated from field: string dataset_id = 6;
   */
  datasetId = "";

  /**
   * Data config reveals how the dataset version is generated.
   *
   * @generated from oneof clarifai.api.DatasetVersion.data_config
   */
  dataConfig: {
    /**
     * The dataset version will be generated based on a single annotation filter.
     *
     * @generated from field: clarifai.api.AnnotationFilterConfig annotation_filter_config = 15;
     */
    value: AnnotationFilterConfig;
    case: "annotationFilterConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Status for this dataset version.
   *
   * @generated from field: clarifai.api.status.Status status = 8;
   */
  status?: Status;

  /**
   * Description of the dataset version
   *
   * @generated from field: string description = 10;
   */
  description = "";

  /**
   * Dataset version metrics
   *
   * @generated from field: map<string, clarifai.api.DatasetVersionMetrics> metrics = 16;
   */
  metrics: { [key: string]: DatasetVersionMetrics } = {};

  /**
   * Dataset version exports
   *
   * @generated from field: clarifai.api.DatasetVersionExportInfo export_info = 17;
   */
  exportInfo?: DatasetVersionExportInfo;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 12;
   */
  metadata?: Struct;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 13;
   */
  visibility?: Visibility;

  /**
   * The embedding models to return embeddings for. If empty, no embeddings are returned.
   *
   * @generated from field: repeated string embed_model_version_ids = 14;
   */
  embedModelVersionIds: string[] = [];

  constructor(data?: PartialMessage<DatasetVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dataset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "annotation_filter_config", kind: "message", T: AnnotationFilterConfig, oneof: "data_config" },
    { no: 8, name: "status", kind: "message", T: Status },
    { no: 10, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "metrics", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: DatasetVersionMetrics} },
    { no: 17, name: "export_info", kind: "message", T: DatasetVersionExportInfo },
    { no: 12, name: "metadata", kind: "message", T: Struct },
    { no: 13, name: "visibility", kind: "message", T: Visibility },
    { no: 14, name: "embed_model_version_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetVersion {
    return new DatasetVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetVersion {
    return new DatasetVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetVersion {
    return new DatasetVersion().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetVersion | PlainMessage<DatasetVersion> | undefined, b: DatasetVersion | PlainMessage<DatasetVersion> | undefined): boolean {
    return proto3.util.equals(DatasetVersion, a, b);
  }
}

/**
 * @generated from message clarifai.api.AnnotationFilterConfig
 */
export class AnnotationFilterConfig extends Message<AnnotationFilterConfig> {
  /**
   * @generated from field: clarifai.api.AnnotationFilter annotation_filter = 1;
   */
  annotationFilter?: AnnotationFilter;

  constructor(data?: PartialMessage<AnnotationFilterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AnnotationFilterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_filter", kind: "message", T: AnnotationFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotationFilterConfig {
    return new AnnotationFilterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotationFilterConfig {
    return new AnnotationFilterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotationFilterConfig {
    return new AnnotationFilterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotationFilterConfig | PlainMessage<AnnotationFilterConfig> | undefined, b: AnnotationFilterConfig | PlainMessage<AnnotationFilterConfig> | undefined): boolean {
    return proto3.util.equals(AnnotationFilterConfig, a, b);
  }
}

/**
 * @generated from message clarifai.api.DatasetVersionMetrics
 */
export class DatasetVersionMetrics extends Message<DatasetVersionMetrics> {
  /**
   * Number of inputs
   *
   * @generated from field: google.protobuf.UInt64Value inputs_count = 1;
   */
  inputsCount?: bigint;

  /**
   * Number of unlabeled inputs
   * An input is considered unlabeled if it there are no annotations with positive labels for that input.
   *
   * @generated from field: google.protobuf.UInt64Value unlabeled_inputs_count = 6;
   */
  unlabeledInputsCount?: bigint;

  /**
   * Number of inputs that have metadata
   *
   * @generated from field: google.protobuf.UInt64Value inputs_with_metadata_count = 8;
   */
  inputsWithMetadataCount?: bigint;

  /**
   * Number of inputs that have geo information
   *
   * @generated from field: google.protobuf.UInt64Value inputs_with_geo_count = 9;
   */
  inputsWithGeoCount?: bigint;

  /**
   * Number of regions
   *
   * @generated from field: google.protobuf.UInt64Value regions_count = 20;
   */
  regionsCount?: bigint;

  /**
   * The matrix shows where the regions are located.
   * Example: If the matrix has 2x2 dimensions, then
   * * region_location_matrix[0][0] = the number of regions that appear in the top left corner, i.e. [0,0]..(0.5,0.5)
   * * region_location_matrix[0][1] = the number of regions that appear in the top right corner, i.e. [0,0.5]..[0.5,1]
   * * region_location_matrix[1][0] = the number of regions that appear in the bottom left corner, i.e. [0.5,0]..[1,0.5)
   * * region_location_matrix[1][1] = the number of regions that appear in the bottom right corner, i.e. [0.5,0.5]..[1,1]
   *
   * @generated from field: MatrixUint64 region_location_matrix = 21;
   */
  regionLocationMatrix?: MatrixUint64;

  /**
   * Number of bounding boxes
   *
   * @generated from field: google.protobuf.UInt64Value bounding_boxes_count = 22;
   */
  boundingBoxesCount?: bigint;

  /**
   * Number of polygons
   *
   * @generated from field: google.protobuf.UInt64Value polygons_count = 23;
   */
  polygonsCount?: bigint;

  /**
   * Number of points
   *
   * @generated from field: google.protobuf.UInt64Value points_count = 24;
   */
  pointsCount?: bigint;

  /**
   * Number of masks
   *
   * @generated from field: google.protobuf.UInt64Value masks_count = 25;
   */
  masksCount?: bigint;

  /**
   * Number of inputs that have regions attached
   * Note that this is not a recursive count: if an input contains frames that contains regions, then the region_frames_count is increased, but region_inputs_count is not increased.
   *
   * @generated from field: google.protobuf.UInt64Value region_inputs_count = 60;
   */
  regionInputsCount?: bigint;

  /**
   * Number of frames that have regions attached
   *
   * @generated from field: google.protobuf.UInt64Value region_frames_count = 61;
   */
  regionFramesCount?: bigint;

  /**
   * Number of frames
   *
   * @generated from field: google.protobuf.UInt64Value frames_count = 30;
   */
  framesCount?: bigint;

  /**
   * Number of inputs that have frames attached
   *
   * @generated from field: google.protobuf.UInt64Value frame_inputs_count = 70;
   */
  frameInputsCount?: bigint;

  /**
   * Number of embeddings
   *
   * @generated from field: google.protobuf.UInt64Value embeddings_count = 40;
   */
  embeddingsCount?: bigint;

  /**
   * Number of positive tags added at input-level
   *
   * @generated from field: google.protobuf.UInt64Value positive_input_tags_count = 50;
   */
  positiveInputTagsCount?: bigint;

  /**
   * Number of positive tags added at region-level
   *
   * @generated from field: google.protobuf.UInt64Value positive_region_tags_count = 51;
   */
  positiveRegionTagsCount?: bigint;

  /**
   * Number of positive tags added at frame-level
   *
   * @generated from field: google.protobuf.UInt64Value positive_frame_tags_count = 52;
   */
  positiveFrameTagsCount?: bigint;

  constructor(data?: PartialMessage<DatasetVersionMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetVersionMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputs_count", kind: "message", T: UInt64Value },
    { no: 6, name: "unlabeled_inputs_count", kind: "message", T: UInt64Value },
    { no: 8, name: "inputs_with_metadata_count", kind: "message", T: UInt64Value },
    { no: 9, name: "inputs_with_geo_count", kind: "message", T: UInt64Value },
    { no: 20, name: "regions_count", kind: "message", T: UInt64Value },
    { no: 21, name: "region_location_matrix", kind: "message", T: MatrixUint64 },
    { no: 22, name: "bounding_boxes_count", kind: "message", T: UInt64Value },
    { no: 23, name: "polygons_count", kind: "message", T: UInt64Value },
    { no: 24, name: "points_count", kind: "message", T: UInt64Value },
    { no: 25, name: "masks_count", kind: "message", T: UInt64Value },
    { no: 60, name: "region_inputs_count", kind: "message", T: UInt64Value },
    { no: 61, name: "region_frames_count", kind: "message", T: UInt64Value },
    { no: 30, name: "frames_count", kind: "message", T: UInt64Value },
    { no: 70, name: "frame_inputs_count", kind: "message", T: UInt64Value },
    { no: 40, name: "embeddings_count", kind: "message", T: UInt64Value },
    { no: 50, name: "positive_input_tags_count", kind: "message", T: UInt64Value },
    { no: 51, name: "positive_region_tags_count", kind: "message", T: UInt64Value },
    { no: 52, name: "positive_frame_tags_count", kind: "message", T: UInt64Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetVersionMetrics {
    return new DatasetVersionMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetVersionMetrics {
    return new DatasetVersionMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetVersionMetrics {
    return new DatasetVersionMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetVersionMetrics | PlainMessage<DatasetVersionMetrics> | undefined, b: DatasetVersionMetrics | PlainMessage<DatasetVersionMetrics> | undefined): boolean {
    return proto3.util.equals(DatasetVersionMetrics, a, b);
  }
}

/**
 * @generated from message clarifai.api.DatasetVersionMetricsGroup
 */
export class DatasetVersionMetricsGroup extends Message<DatasetVersionMetricsGroup> {
  /**
   * @generated from field: string parent_path = 1;
   */
  parentPath = "";

  /**
   * @generated from field: clarifai.api.DatasetVersionMetricsGroupType type = 2;
   */
  type = DatasetVersionMetricsGroupType.DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET;

  /**
   * @generated from field: google.protobuf.Value value = 3;
   */
  value?: Value;

  /**
   * @generated from field: clarifai.api.DatasetVersionMetrics metrics = 4;
   */
  metrics?: DatasetVersionMetrics;

  constructor(data?: PartialMessage<DatasetVersionMetricsGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetVersionMetricsGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(DatasetVersionMetricsGroupType) },
    { no: 3, name: "value", kind: "message", T: Value },
    { no: 4, name: "metrics", kind: "message", T: DatasetVersionMetrics },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetVersionMetricsGroup {
    return new DatasetVersionMetricsGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetVersionMetricsGroup {
    return new DatasetVersionMetricsGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetVersionMetricsGroup {
    return new DatasetVersionMetricsGroup().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetVersionMetricsGroup | PlainMessage<DatasetVersionMetricsGroup> | undefined, b: DatasetVersionMetricsGroup | PlainMessage<DatasetVersionMetricsGroup> | undefined): boolean {
    return proto3.util.equals(DatasetVersionMetricsGroup, a, b);
  }
}

/**
 * DatasetVersionExportInfo contains information about all exports of a dataset version.
 * 
 * If the dataset version has not been exported in a format, then the DatasetVersionExport
 * field for that format is empty instead of having a "not exported" status.
 *
 * @generated from message clarifai.api.DatasetVersionExportInfo
 */
export class DatasetVersionExportInfo extends Message<DatasetVersionExportInfo> {
  /**
   * clarifai_data_example is a CLARIFAI_DATA_EXAMPLE export of the dataset version.
   *
   * @generated from field: clarifai.api.DatasetVersionExport clarifai_data_example = 1;
   */
  clarifaiDataExample?: DatasetVersionExport;

  constructor(data?: PartialMessage<DatasetVersionExportInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetVersionExportInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clarifai_data_example", kind: "message", T: DatasetVersionExport },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetVersionExportInfo {
    return new DatasetVersionExportInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetVersionExportInfo {
    return new DatasetVersionExportInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetVersionExportInfo {
    return new DatasetVersionExportInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetVersionExportInfo | PlainMessage<DatasetVersionExportInfo> | undefined, b: DatasetVersionExportInfo | PlainMessage<DatasetVersionExportInfo> | undefined): boolean {
    return proto3.util.equals(DatasetVersionExportInfo, a, b);
  }
}

/**
 * DatasetVersionExport contains metadata for a single dataset version export.
 *
 * @generated from message clarifai.api.DatasetVersionExport
 */
export class DatasetVersionExport extends Message<DatasetVersionExport> {
  /**
   * format is the format of the dataset version export.
   *
   * @generated from field: clarifai.api.DatasetVersionExportFormat format = 1;
   */
  format = DatasetVersionExportFormat.DATASET_VERSION_EXPORT_FORMAT_NOT_SET;

  /**
   * status is the current status of the dataset version export.
   *
   * @generated from field: clarifai.api.status.Status status = 2;
   */
  status?: Status;

  /**
   * url is the URL from where the dataset version export can be downloaded.
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * size is the size of the dataset version export in number of bytes.
   *
   * @generated from field: uint64 size = 4;
   */
  size = protoInt64.zero;

  constructor(data?: PartialMessage<DatasetVersionExport>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetVersionExport";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "format", kind: "enum", T: proto3.getEnumType(DatasetVersionExportFormat) },
    { no: 2, name: "status", kind: "message", T: Status },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetVersionExport {
    return new DatasetVersionExport().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetVersionExport {
    return new DatasetVersionExport().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetVersionExport {
    return new DatasetVersionExport().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetVersionExport | PlainMessage<DatasetVersionExport> | undefined, b: DatasetVersionExport | PlainMessage<DatasetVersionExport> | undefined): boolean {
    return proto3.util.equals(DatasetVersionExport, a, b);
  }
}

/**
 * WorkflowResultsSimilarity
 *
 * @generated from message clarifai.api.WorkflowResultsSimilarity
 */
export class WorkflowResultsSimilarity extends Message<WorkflowResultsSimilarity> {
  /**
   * The input with the specific data compare against all pool results
   *
   * @generated from field: clarifai.api.Input probe_input = 1;
   */
  probeInput?: Input;

  /**
   * @generated from field: repeated clarifai.api.Hit pool_results = 2;
   */
  poolResults: Hit[] = [];

  constructor(data?: PartialMessage<WorkflowResultsSimilarity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowResultsSimilarity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "probe_input", kind: "message", T: Input },
    { no: 2, name: "pool_results", kind: "message", T: Hit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowResultsSimilarity {
    return new WorkflowResultsSimilarity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowResultsSimilarity {
    return new WorkflowResultsSimilarity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowResultsSimilarity {
    return new WorkflowResultsSimilarity().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowResultsSimilarity | PlainMessage<WorkflowResultsSimilarity> | undefined, b: WorkflowResultsSimilarity | PlainMessage<WorkflowResultsSimilarity> | undefined): boolean {
    return proto3.util.equals(WorkflowResultsSimilarity, a, b);
  }
}

/**
 * Key
 *
 * @generated from message clarifai.api.Key
 */
export class Key extends Message<Key> {
  /**
   * The id of this key, it is used for authorization.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The type of key, it can be api_key or personal_access_token, the default value is api_key
   *
   * @generated from field: string type = 8;
   */
  type = "";

  /**
   * The description
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The low-level scopes this key has
   *
   * @generated from field: repeated string scopes = 3;
   */
  scopes: string[] = [];

  /**
   * The endpoint-level scopes this key has
   *
   * @generated from field: repeated string endpoints = 7;
   */
  endpoints: string[] = [];

  /**
   * The apps that this key give you access to, it is empty if this key is personal_access_token
   * API key can only give you access to a single app.
   *
   * @generated from field: repeated clarifai.api.App apps = 4;
   */
  apps: App[] = [];

  /**
   * When the key was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * When does the key expires, the key won't expire if this is empty
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: Timestamp;

  /**
   * list of idp ids at which key is currently authorized
   *
   * @generated from field: repeated string authorized_idp_ids = 9;
   */
  authorizedIdpIds: string[] = [];

  constructor(data?: PartialMessage<Key>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Key";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "apps", kind: "message", T: App, repeated: true },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "expires_at", kind: "message", T: Timestamp },
    { no: 9, name: "authorized_idp_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Key {
    return new Key().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJsonString(jsonString, options);
  }

  static equals(a: Key | PlainMessage<Key> | undefined, b: Key | PlainMessage<Key> | undefined): boolean {
    return proto3.util.equals(Key, a, b);
  }
}

/**
 * LicenseLimit
 *
 * @generated from message clarifai.api.LicenseLimit
 */
export class LicenseLimit extends Message<LicenseLimit> {
  /**
   * @generated from field: clarifai.api.Model model = 1;
   */
  model?: Model;

  /**
   * Expiration date, if different from the one in the license file (optional)
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 2;
   */
  expiresAt?: Timestamp;

  /**
   * Maximum number of operations allowed.
   *
   * @generated from field: int64 max_operation_count = 3;
   */
  maxOperationCount = protoInt64.zero;

  /**
   * the status of this license limit
   *
   * @generated from field: clarifai.api.status.Status status = 4;
   */
  status?: Status;

  constructor(data?: PartialMessage<LicenseLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LicenseLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model", kind: "message", T: Model },
    { no: 2, name: "expires_at", kind: "message", T: Timestamp },
    { no: 3, name: "max_operation_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseLimit {
    return new LicenseLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseLimit {
    return new LicenseLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseLimit {
    return new LicenseLimit().fromJsonString(jsonString, options);
  }

  static equals(a: LicenseLimit | PlainMessage<LicenseLimit> | undefined, b: LicenseLimit | PlainMessage<LicenseLimit> | undefined): boolean {
    return proto3.util.equals(LicenseLimit, a, b);
  }
}

/**
 * License
 *
 * @generated from message clarifai.api.License
 */
export class License extends Message<License> {
  /**
   * License Key, ID of license from users' perspective
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The operations allowed under the license (instead of repeated field we could create combined scopes eg PREDICT_TRAIN)
   *
   * @generated from field: clarifai.api.LicenseScope scope = 2;
   */
  scope = LicenseScope.LICENSE_SCOPE_NOT_SET;

  /**
   * Expiration date and time (optional). Can work by itself and/or in conjunction with the maximum number of operations
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;

  /**
   * Action to be taken in case deployment expires
   *
   * @generated from field: clarifai.api.ExpirationAction expiration_action = 4;
   */
  expirationAction = ExpirationAction.EXPIRATION_ACTION_NOT_SET;

  /**
   * Array of models covered by the license
   *
   * @generated from field: repeated clarifai.api.LicenseLimit limits = 5;
   */
  limits: LicenseLimit[] = [];

  /**
   * the status of this license
   *
   * @generated from field: clarifai.api.status.Status status = 6;
   */
  status?: Status;

  /**
   * If the license is off-line license, if yes, on prem instance will not validate it with platform.
   *
   * @generated from field: bool is_offline = 7;
   */
  isOffline = false;

  constructor(data?: PartialMessage<License>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.License";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "scope", kind: "enum", T: proto3.getEnumType(LicenseScope) },
    { no: 3, name: "expires_at", kind: "message", T: Timestamp },
    { no: 4, name: "expiration_action", kind: "enum", T: proto3.getEnumType(ExpirationAction) },
    { no: 5, name: "limits", kind: "message", T: LicenseLimit, repeated: true },
    { no: 6, name: "status", kind: "message", T: Status },
    { no: 7, name: "is_offline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License {
    return new License().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License {
    return new License().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License {
    return new License().fromJsonString(jsonString, options);
  }

  static equals(a: License | PlainMessage<License> | undefined, b: License | PlainMessage<License> | undefined): boolean {
    return proto3.util.equals(License, a, b);
  }
}

/**
 * This is the Model object which represents a created model in the platform.
 * Each model has a particular type denoted by the model_type_id.
 * When creating a Model with PostModels the following happens:
 *  - if the ModelType is trainable, then a new ModelVersion is created that is
 *    - UNTRAINED status by default
 *    - TRAINED status if a ModelVersion was included with PretrainedModelConfig in PostModels
 *  - if the ModelType is not trainable, then a new ModelVersion is created with TRAINED status.
 * To modify config settings like OutputInfo for the Model you an use PatchModels. This will
 * also create a new ModelVersion, potentially UNTRAINED following the same rules as above.
 * The fields that are patchable include Model.name, Model.display_name and Model.output_info
 * (except the Model.output_info.type and Model.output_info.type_ext).
 *
 * @generated from message clarifai.api.Model
 */
export class Model extends Message<Model> {
  /**
   * The model's ID. Must be unique within a particular app and URL-friendly.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * DEPRECATED: Please use the model id to name the model.
   *
   * @generated from field: string name = 2 [deprecated = true];
   * @deprecated
   */
  name = "";

  /**
   * When the model was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   *  the following from the API:
   *  "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * When was the most recent model version created at
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 19;
   */
  modifiedAt?: Timestamp;

  /**
   * The app the model belongs to.
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * Info about the model's output and configuration.
   *
   * @generated from field: clarifai.api.OutputInfo output_info = 5;
   */
  outputInfo?: OutputInfo;

  /**
   * A particular version of the model, e.g., to specify the version when creating a workflow.
   *
   * @generated from field: clarifai.api.ModelVersion model_version = 6;
   */
  modelVersion?: ModelVersion;

  /**
   * DEPRECATED: Please use the model id to name the model.
   *
   * @generated from field: string display_name = 7 [deprecated = true];
   * @deprecated
   */
  displayName = "";

  /**
   * The user id that the model belongs to.
   *
   * @generated from field: string user_id = 9;
   */
  userId = "";

  /**
   * Info about the models' input and configuration of them.
   *
   * @generated from field: clarifai.api.InputInfo input_info = 12;
   */
  inputInfo?: InputInfo;

  /**
   * Configuration for the training process of this model.
   *
   * @generated from field: clarifai.api.TrainInfo train_info = 13;
   */
  trainInfo?: TrainInfo;

  /**
   * The default evaluation info. Can be overwritten by eval request.
   *
   * @generated from field: clarifai.api.EvalInfo default_eval_info = 30;
   */
  defaultEvalInfo?: EvalInfo;

  /**
   * The ModelType.Id that is used for this model. This is used for all versions and you cannot
   * change model_type_id between versions of the same model.
   *
   * @generated from field: string model_type_id = 14;
   */
  modelTypeId = "";

  /**
   * The task the model was trained to do
   *
   * @generated from field: string task = 26;
   */
  task = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 15;
   */
  visibility?: Visibility;

  /**
   * Short description about this model
   *
   * @generated from field: string description = 16;
   */
  description = "";

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 17;
   */
  metadata?: Struct;

  /**
   * @generated from field: google.protobuf.Struct presets = 27;
   */
  presets?: Struct;

  /**
   * Notes for the model
   * This field should be used for in-depth notes and supports up to 64Kbs.
   *
   * @generated from field: string notes = 18;
   */
  notes = "";

  /**
   * Tags from toolkits category
   *
   * @generated from field: repeated string toolkits = 20;
   */
  toolkits: string[] = [];

  /**
   * Tags from use_cases category
   *
   * @generated from field: repeated string use_cases = 21;
   */
  useCases: string[] = [];

  /**
   * Tags from languages category.
   *
   * @generated from field: repeated string languages = 25;
   */
  languages: string[] = [];

  /**
   * Tags from languages category with names, only used in responses.
   *
   * @generated from field: repeated clarifai.api.FullTag languages_full = 31;
   */
  languagesFull: FullTag[] = [];

  /**
   * @generated from field: repeated string check_consents = 32;
   */
  checkConsents: string[] = [];

  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostModelStars/DeleteModelStars endpoints to star/unstar a model
   *
   * @generated from field: bool is_starred = 22;
   */
  isStarred = false;

  /**
   * How many users have starred the model (only showed on get/list requests)
   * Computed value, not editable
   *
   * @generated from field: int32 star_count = 23;
   */
  starCount = 0;

  /**
   * Configuration used to import model from third-party toolkits
   *
   * @generated from field: clarifai.api.ImportInfo import_info = 24;
   */
  importInfo?: ImportInfo;

  /**
   * Whether it's recommended that this model is used within a workflow
   *
   * @generated from field: google.protobuf.BoolValue workflow_recommended = 29;
   */
  workflowRecommended?: boolean;

  constructor(data?: PartialMessage<Model>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Model";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 19, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "output_info", kind: "message", T: OutputInfo },
    { no: 6, name: "model_version", kind: "message", T: ModelVersion },
    { no: 7, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "input_info", kind: "message", T: InputInfo },
    { no: 13, name: "train_info", kind: "message", T: TrainInfo },
    { no: 30, name: "default_eval_info", kind: "message", T: EvalInfo },
    { no: 14, name: "model_type_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 26, name: "task", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "visibility", kind: "message", T: Visibility },
    { no: 16, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "metadata", kind: "message", T: Struct },
    { no: 27, name: "presets", kind: "message", T: Struct },
    { no: 18, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "toolkits", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 21, name: "use_cases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 25, name: "languages", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 31, name: "languages_full", kind: "message", T: FullTag, repeated: true },
    { no: 32, name: "check_consents", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 22, name: "is_starred", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 23, name: "star_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 24, name: "import_info", kind: "message", T: ImportInfo },
    { no: 29, name: "workflow_recommended", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Model {
    return new Model().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJsonString(jsonString, options);
  }

  static equals(a: Model | PlainMessage<Model> | undefined, b: Model | PlainMessage<Model> | undefined): boolean {
    return proto3.util.equals(Model, a, b);
  }
}

/**
 * A link to a html/markdown/text file that stores reference material tied to a model.
 *
 * @generated from message clarifai.api.ModelReference
 */
export class ModelReference extends Message<ModelReference> {
  /**
   * Id of the reference
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The id of the model this Model reference is tied to.
   *
   * @generated from field: string model_id = 2;
   */
  modelId = "";

  /**
   * address of resource
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * name of link
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * To handle arbitrary json metadata:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<ModelReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelReference {
    return new ModelReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelReference {
    return new ModelReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelReference {
    return new ModelReference().fromJsonString(jsonString, options);
  }

  static equals(a: ModelReference | PlainMessage<ModelReference> | undefined, b: ModelReference | PlainMessage<ModelReference> | undefined): boolean {
    return proto3.util.equals(ModelReference, a, b);
  }
}

/**
 * ModelVersionInputExample
 *
 * @generated from message clarifai.api.ModelVersionInputExample
 */
export class ModelVersionInputExample extends Message<ModelVersionInputExample> {
  /**
   * user unique id
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * external id of model
   *
   * @generated from field: string model_id = 2;
   */
  modelId = "";

  /**
   * external id of model version
   *
   * @generated from field: string model_version_id = 3;
   */
  modelVersionId = "";

  /**
   * data to store as example input for model
   *
   * @generated from field: clarifai.api.Data data = 4;
   */
  data?: Data;

  /**
   * name of link for display
   *
   * @generated from field: string name = 5;
   */
  name = "";

  /**
   * description of link contents
   *
   * @generated from field: string description = 6;
   */
  description = "";

  constructor(data?: PartialMessage<ModelVersionInputExample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelVersionInputExample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "data", kind: "message", T: Data },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelVersionInputExample {
    return new ModelVersionInputExample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelVersionInputExample {
    return new ModelVersionInputExample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelVersionInputExample {
    return new ModelVersionInputExample().fromJsonString(jsonString, options);
  }

  static equals(a: ModelVersionInputExample | PlainMessage<ModelVersionInputExample> | undefined, b: ModelVersionInputExample | PlainMessage<ModelVersionInputExample> | undefined): boolean {
    return proto3.util.equals(ModelVersionInputExample, a, b);
  }
}

/**
 * OutputInfo defines some of the settings for each model version that PatchModels can effect. These
 * parameters control some of the training or inference operations that this model can do.
 * As the number of parameters continued to grow when we launched more ModelTypes we decided to move
 * to using the OutputInfo.params field which is a Struct (or JSON object if you're using
 * our JSON REST APIs). This allows each ModelType to define the set of fields, their default values
 * and description of each field so that we can display those in Portal and make the creation of
 * Model's very extensible. The OutputConfig object will eventually go away in favor of
 * infer_params struct.
 *
 * @generated from message clarifai.api.OutputInfo
 */
export class OutputInfo extends Message<OutputInfo> {
  /**
   * List of concepts or other output related data for the model.
   *
   * @generated from field: clarifai.api.Data data = 1;
   */
  data?: Data;

  /**
   * Model configuration...going away in favor of infer_params and train_params over time.
   * TO BE DEPRECATED
   *
   * @generated from field: clarifai.api.OutputConfig output_config = 2;
   */
  outputConfig?: OutputConfig;

  /**
   * For returning where to look for the Output info if not returning it.
   *
   * @generated from field: string message = 3;
   */
  message = "";

  /**
   * Map from the api.Data field names to the underlying model graph's outputs. When using a
   * PretrainedModelConfig the values in this map need to match the Triton config.pbtxt output names.
   *
   * @generated from field: google.protobuf.Struct fields_map = 6;
   */
  fieldsMap?: Struct;

  /**
   * For predicting with the various ModelType's we accept a Struct (JSON object) worth of args
   * that the ModelTypeField defines. During inference, the settings contained within are sent
   * to the model predictor to alter predictions from this Model.
   *
   * @generated from field: google.protobuf.Struct params = 7;
   */
  params?: Struct;

  constructor(data?: PartialMessage<OutputInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OutputInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Data },
    { no: 2, name: "output_config", kind: "message", T: OutputConfig },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "fields_map", kind: "message", T: Struct },
    { no: 7, name: "params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputInfo {
    return new OutputInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputInfo {
    return new OutputInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputInfo {
    return new OutputInfo().fromJsonString(jsonString, options);
  }

  static equals(a: OutputInfo | PlainMessage<OutputInfo> | undefined, b: OutputInfo | PlainMessage<OutputInfo> | undefined): boolean {
    return proto3.util.equals(OutputInfo, a, b);
  }
}

/**
 * InputInfo
 *
 * @generated from message clarifai.api.InputInfo
 */
export class InputInfo extends Message<InputInfo> {
  /**
   * Map from the api.Data field names to the underlying model graph's inputs. When using a
   * PretrainedModelConfig the values in this map need to match the Triton config.pbtxt input names.
   *
   * @generated from field: google.protobuf.Struct fields_map = 1;
   */
  fieldsMap?: Struct;

  /**
   * To control the inputs to the given model we allow a list of parameters
   * defined for each ModelType as a Struct (JSON object) here. During training or inference, the
   * settings contained within are sent to the training processor to alter the training process.
   *
   * @generated from field: google.protobuf.Struct params = 2;
   */
  params?: Struct;

  constructor(data?: PartialMessage<InputInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InputInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields_map", kind: "message", T: Struct },
    { no: 2, name: "params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputInfo {
    return new InputInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputInfo {
    return new InputInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputInfo {
    return new InputInfo().fromJsonString(jsonString, options);
  }

  static equals(a: InputInfo | PlainMessage<InputInfo> | undefined, b: InputInfo | PlainMessage<InputInfo> | undefined): boolean {
    return proto3.util.equals(InputInfo, a, b);
  }
}

/**
 * @generated from message clarifai.api.TrainInfo
 */
export class TrainInfo extends Message<TrainInfo> {
  /**
   * To control the training process when PostModelVersions is used we allow a list of parameters
   * defined for each ModelType as a Struct (JSON object) here. During training, the settings
   * contained within are sent to the training processor to alter the training process.
   *
   * @generated from field: google.protobuf.Struct params = 1;
   */
  params?: Struct;

  constructor(data?: PartialMessage<TrainInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TrainInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrainInfo {
    return new TrainInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrainInfo {
    return new TrainInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrainInfo {
    return new TrainInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TrainInfo | PlainMessage<TrainInfo> | undefined, b: TrainInfo | PlainMessage<TrainInfo> | undefined): boolean {
    return proto3.util.equals(TrainInfo, a, b);
  }
}

/**
 * @generated from message clarifai.api.EvalInfo
 */
export class EvalInfo extends Message<EvalInfo> {
  /**
   * To control the evaluation process.
   * Allow a list of parameters.
   *
   * @generated from field: google.protobuf.Struct params = 1;
   */
  params?: Struct;

  constructor(data?: PartialMessage<EvalInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EvalInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvalInfo {
    return new EvalInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvalInfo {
    return new EvalInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvalInfo {
    return new EvalInfo().fromJsonString(jsonString, options);
  }

  static equals(a: EvalInfo | PlainMessage<EvalInfo> | undefined, b: EvalInfo | PlainMessage<EvalInfo> | undefined): boolean {
    return proto3.util.equals(EvalInfo, a, b);
  }
}

/**
 * @generated from message clarifai.api.ImportInfo
 */
export class ImportInfo extends Message<ImportInfo> {
  /**
   * Used to configure model imports from third-party toolkits.
   *
   * @generated from field: google.protobuf.Struct params = 1;
   */
  params?: Struct;

  constructor(data?: PartialMessage<ImportInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ImportInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportInfo {
    return new ImportInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportInfo {
    return new ImportInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportInfo {
    return new ImportInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ImportInfo | PlainMessage<ImportInfo> | undefined, b: ImportInfo | PlainMessage<ImportInfo> | undefined): boolean {
    return proto3.util.equals(ImportInfo, a, b);
  }
}

/**
 * OutputConfig is a collection of parameters controlling either inference or training settings for
 * the given Model. This message will be deprecated over time in favor or infer_params and
 * train_params in OutputInfo which are cleaner and more extensible for many ModelTypes.
 *
 * @generated from message clarifai.api.OutputConfig
 */
export class OutputConfig extends Message<OutputConfig> {
  /**
   * For custom concept model training: whether the concept predictions must sum to 1.
   *
   * @generated from field: bool concepts_mutually_exclusive = 1;
   */
  conceptsMutuallyExclusive = false;

  /**
   * For custom concept model training: Whether negatives should only be sampled from within the app during
   * training, for custom models.
   *
   * @generated from field: bool closed_environment = 2;
   */
  closedEnvironment = false;

  /**
   * DEPRECATED: For custom models, this is the base model to use for image embeddings.
   * Default is general model.
   *
   * @generated from field: string existing_model_id = 3 [deprecated = true];
   * @deprecated
   */
  existingModelId = "";

  /**
   * For concept model predictions: Overrides the default_language for the app in a predict call.
   *
   * @generated from field: string language = 4;
   */
  language = "";

  /**
   * DEPRECATED: Hyper-parameters for custom training.
   * Use new hyper_params field instead.
   *
   * @generated from field: string hyper_parameters = 5 [deprecated = true];
   * @deprecated
   */
  hyperParameters = "";

  /**
   * For concept model predictions:  Maximum number of concepts in result. Defaults to 0 which under
   * the hood will return default of 20. We do a server side default in order to control this
   * feature in the future.
   *
   * @generated from field: uint32 max_concepts = 6;
   */
  maxConcepts = 0;

  /**
   * For concept model predictions: Minimum value of concept's probability score in result.
   * Defaults to 0.0 which means we won't do any thresholding as all probabilities will
   * likely be > 0.0.
   *
   * @generated from field: float min_value = 7;
   */
  minValue = 0;

  /**
   * For concept model predictions: Select concepts in result by name or by id
   *
   * @generated from field: repeated clarifai.api.Concept select_concepts = 8;
   */
  selectConcepts: Concept[] = [];

  /**
   * For custom concept model training: Training timeout of the model (in seconds)
   *
   * @generated from field: uint32 training_timeout = 9;
   */
  trainingTimeout = 0;

  /**
   * For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
   *
   * @generated from field: uint32 sample_ms = 10;
   */
  sampleMs = 0;

  /**
   * For custom model training: Hyperparameters for custom training
   *
   * @generated from field: google.protobuf.Struct hyper_params = 13;
   */
  hyperParams?: Struct;

  /**
   * For custom model training: this is the base model version to use for image embeddings.
   * This has to be one of the embed models in the app workflow.
   *
   * @generated from field: string embed_model_version_id = 14;
   */
  embedModelVersionId = "";

  /**
   * For custom model training: Use this flag to fail on missing positive examples
   * By default we fill in the missing with random examples
   *
   * @generated from field: bool fail_on_missing_positive_examples = 15;
   */
  failOnMissingPositiveExamples = false;

  /**
   * For custom model training: This is any additional metadata as a JSON object that we want
   * want to persist in the model's output config. This is a useful quick way to set fields for
   * introducing fields for new model types so we don't have to add a new proto field and DB field
   * each time. Please refer to the documentation or model implementation internally for more
   * details on what fields are supported for which models.
   * TODO(zeiler): remove this field after Portal is updated.
   *
   * @generated from field: google.protobuf.Struct model_metadata = 17 [deprecated = true];
   * @deprecated
   */
  modelMetadata?: Struct;

  constructor(data?: PartialMessage<OutputConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OutputConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concepts_mutually_exclusive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "closed_environment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "existing_model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "hyper_parameters", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "max_concepts", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "min_value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "select_concepts", kind: "message", T: Concept, repeated: true },
    { no: 9, name: "training_timeout", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "sample_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "hyper_params", kind: "message", T: Struct },
    { no: 14, name: "embed_model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "fail_on_missing_positive_examples", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "model_metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputConfig {
    return new OutputConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputConfig {
    return new OutputConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputConfig {
    return new OutputConfig().fromJsonString(jsonString, options);
  }

  static equals(a: OutputConfig | PlainMessage<OutputConfig> | undefined, b: OutputConfig | PlainMessage<OutputConfig> | undefined): boolean {
    return proto3.util.equals(OutputConfig, a, b);
  }
}

/**
 * ModelSpec is a definition of a Model type. This is used in model mode of portal
 * to list out the possible models that can be created and can be used to understand more about
 * the possible models in our platform.
 *
 * @generated from message clarifai.api.ModelType
 */
export class ModelType extends Message<ModelType> {
  /**
   * A unique identifies for this model type. This is differnt than the 'type' field below because
   * the 'type' can be re-used for differnet input and output combinations whereas 'id' is always
   * unique.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * title for this model in model gallery
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Description of this model type.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The list of input fields that this model accepts. These are the keys of the Model's
   * InputInfo.fields_map
   *
   * @generated from field: repeated string input_fields = 5;
   */
  inputFields: string[] = [];

  /**
   * The list of output fields that this model accepts. These are the keys of the Model's
   * OutputInfo.fields_map
   *
   * @generated from field: repeated string output_fields = 6;
   */
  outputFields: string[] = [];

  /**
   * Is this model trainable in our platform.
   *
   * @generated from field: bool trainable = 8;
   */
  trainable = false;

  /**
   * Is this model creatable. We have some pre-trained model types that users cannot create yet in
   * model mode.
   *
   * @generated from field: bool creatable = 9;
   */
  creatable = false;

  /**
   * Is this model type only for internal users at this time.
   *
   * @generated from field: bool internal_only = 10;
   */
  internalOnly = false;

  /**
   * The remaining fields are definitions of the configurable fields that exist.
   * Each field has path into the Model object such as "name" as a top level or "output_info.data"
   * if it's the Data object within the OutputInfo object. We decided to not break these up
   * into input_info, train_info and output_info related parameters and instead use the path
   * so that they are most flexible.
   *
   * @generated from field: repeated clarifai.api.ModelTypeField model_type_fields = 11;
   */
  modelTypeFields: ModelTypeField[] = [];

  /**
   * For sequence models we need to know when processing that they require temporal time frames
   * in sequential order. This will be true for model types like trackers as an example.
   *
   * @generated from field: bool requires_sequential_frames = 12;
   */
  requiresSequentialFrames = false;

  /**
   * Can this model be evaluated?
   *
   * @generated from field: bool evaluable = 13;
   */
  evaluable = false;

  /**
   * Expected input layers of an uploaded model
   *
   * @generated from field: repeated clarifai.api.ModelLayerInfo expected_input_layers = 16;
   */
  expectedInputLayers: ModelLayerInfo[] = [];

  /**
   * Expected output layers of an uploaded model
   *
   * @generated from field: repeated clarifai.api.ModelLayerInfo expected_output_layers = 17;
   */
  expectedOutputLayers: ModelLayerInfo[] = [];

  constructor(data?: PartialMessage<ModelType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "input_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "output_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "trainable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "creatable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "internal_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "model_type_fields", kind: "message", T: ModelTypeField, repeated: true },
    { no: 12, name: "requires_sequential_frames", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "evaluable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "expected_input_layers", kind: "message", T: ModelLayerInfo, repeated: true },
    { no: 17, name: "expected_output_layers", kind: "message", T: ModelLayerInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelType {
    return new ModelType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelType {
    return new ModelType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelType {
    return new ModelType().fromJsonString(jsonString, options);
  }

  static equals(a: ModelType | PlainMessage<ModelType> | undefined, b: ModelType | PlainMessage<ModelType> | undefined): boolean {
    return proto3.util.equals(ModelType, a, b);
  }
}

/**
 * @generated from message clarifai.api.ModelLayerInfo
 */
export class ModelLayerInfo extends Message<ModelLayerInfo> {
  /**
   * The api.Data field this layer will be parsed into
   *
   * @generated from field: string data_field_name = 1;
   */
  dataFieldName = "";

  /**
   * Description of the expected shape. Can support multiple support layer shapes.
   *
   * @generated from field: repeated clarifai.api.LayerShape shapes = 2;
   */
  shapes: LayerShape[] = [];

  /**
   * Brief description about the layer if needed
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Whether this layer should have a label_filename specified and provided
   *
   * @generated from field: bool requires_label_filename = 4;
   */
  requiresLabelFilename = false;

  constructor(data?: PartialMessage<ModelLayerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelLayerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shapes", kind: "message", T: LayerShape, repeated: true },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "requires_label_filename", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelLayerInfo {
    return new ModelLayerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelLayerInfo {
    return new ModelLayerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelLayerInfo {
    return new ModelLayerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ModelLayerInfo | PlainMessage<ModelLayerInfo> | undefined, b: ModelLayerInfo | PlainMessage<ModelLayerInfo> | undefined): boolean {
    return proto3.util.equals(ModelLayerInfo, a, b);
  }
}

/**
 * @generated from message clarifai.api.LayerShape
 */
export class LayerShape extends Message<LayerShape> {
  /**
   * Supported dimensions
   * Example: [-1,4] is a 2-dimensional array with the first dimension of variablesize, but second dimension with a static size: [[1,2,3,4],[4,5,6,7],...]
   *
   * @generated from field: repeated int32 dims = 1;
   */
  dims: number[] = [];

  /**
   * Max dimension size, applicable to layers that can have flexible sizes.
   *
   * @generated from field: repeated int32 max_dims = 2;
   */
  maxDims: number[] = [];

  /**
   * The triton data type
   *
   * @generated from field: clarifai.api.DataType data_type = 3;
   */
  dataType = DataType.UNDEFINED;

  /**
   * Description about the dimensions
   *
   * @generated from field: string description = 4;
   */
  description = "";

  constructor(data?: PartialMessage<LayerShape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LayerShape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dims", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 2, name: "max_dims", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 3, name: "data_type", kind: "enum", T: proto3.getEnumType(DataType) },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LayerShape {
    return new LayerShape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LayerShape {
    return new LayerShape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LayerShape {
    return new LayerShape().fromJsonString(jsonString, options);
  }

  static equals(a: LayerShape | PlainMessage<LayerShape> | undefined, b: LayerShape | PlainMessage<LayerShape> | undefined): boolean {
    return proto3.util.equals(LayerShape, a, b);
  }
}

/**
 * ModelTypeField stores a field value of a configurable type.
 *
 * @generated from message clarifai.api.ModelTypeField
 */
export class ModelTypeField extends Message<ModelTypeField> {
  /**
   * The path where the value of the field will be stored.
   * Example:
   * "output_info.data" would be the Data message in the OutputInfo message.
   * "output_info.output_config.language" is in the OutputConfig message within OutputInfo
   * "input_info.params" is in the params struct within InputInfo.
   * "output_info.params" is in the params struct within OutputInfo.
   * "train_info.params" is in the params struct within TrainInfo.
   * and so on.
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * The field for this field.
   *
   * @generated from field: clarifai.api.ModelTypeField.ModelTypeFieldType field_type = 2;
   */
  fieldType = ModelTypeField_ModelTypeFieldType.INVALID_MODEL_TYPE_FIELD_TYPE;

  /**
   * A default value. We use the Value field because we want to have structured data (just like
   * google.protobuf.Struct but this is just a single value).
   *
   * @generated from field: google.protobuf.Value default_value = 3;
   */
  defaultValue?: Value;

  /**
   * Description for this field.
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * Placeholder text for the UI element.
   *
   * @generated from field: string placeholder = 5;
   */
  placeholder = "";

  /**
   * List of options of the ENUM type and potentially additional fields they bring with them.
   *
   * @generated from field: repeated clarifai.api.ModelTypeEnumOption model_type_enum_options = 6;
   */
  modelTypeEnumOptions: ModelTypeEnumOption[] = [];

  /**
   * If this field should appear for internal users only.
   *
   * @generated from field: bool internal_only = 7;
   */
  internalOnly = false;

  /**
   * If this field is a required field. If True then during validation you won't be able to create
   * a model of this type with providing a value for this field. When False, the ModelType's
   * default_value will be used for this field.
   *
   * @generated from field: bool required = 8;
   */
  required = false;

  /**
   * If the field_type is RANGE, this must be filled in.
   *
   * @generated from field: clarifai.api.ModelTypeRangeInfo model_type_range_info = 9;
   */
  modelTypeRangeInfo?: ModelTypeRangeInfo;

  constructor(data?: PartialMessage<ModelTypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelTypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_type", kind: "enum", T: proto3.getEnumType(ModelTypeField_ModelTypeFieldType) },
    { no: 3, name: "default_value", kind: "message", T: Value },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "placeholder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "model_type_enum_options", kind: "message", T: ModelTypeEnumOption, repeated: true },
    { no: 7, name: "internal_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "model_type_range_info", kind: "message", T: ModelTypeRangeInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTypeField {
    return new ModelTypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTypeField {
    return new ModelTypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTypeField {
    return new ModelTypeField().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTypeField | PlainMessage<ModelTypeField> | undefined, b: ModelTypeField | PlainMessage<ModelTypeField> | undefined): boolean {
    return proto3.util.equals(ModelTypeField, a, b);
  }
}

/**
 * These are various types of fields that we have UIs for.
 *
 * @generated from enum clarifai.api.ModelTypeField.ModelTypeFieldType
 */
export enum ModelTypeField_ModelTypeFieldType {
  /**
   * @generated from enum value: INVALID_MODEL_TYPE_FIELD_TYPE = 0;
   */
  INVALID_MODEL_TYPE_FIELD_TYPE = 0,

  /**
   * @generated from enum value: BOOLEAN = 1;
   */
  BOOLEAN = 1,

  /**
   * @generated from enum value: STRING = 2;
   */
  STRING = 2,

  /**
   * @generated from enum value: NUMBER = 3;
   */
  NUMBER = 3,

  /**
   * For auto-completing to concepts in the app. This goes into an data.concepts field.
   *
   * @generated from enum value: ARRAY_OF_CONCEPTS = 4;
   */
  ARRAY_OF_CONCEPTS = 4,

  /**
   * For auto-completing to concepts in the app. This goes into an data.concepts field.
   *
   * @generated from enum value: ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5;
   */
  ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5,

  /**
   * A range for a float value.
   *
   * @generated from enum value: RANGE = 7;
   */
  RANGE = 7,

  /**
   * If ENUM is used then the "enum_options" field should also be filled in with the respective ID and description
   * for the different ENUM options.
   *
   * @generated from enum value: ENUM = 8;
   */
  ENUM = 8,

  /**
   * For listing collaborators of the app. The field is a string of the collaborator's user_id.
   *
   * @generated from enum value: COLLABORATORS = 9;
   */
  COLLABORATORS = 9,

  /**
   * For arbitrary json object: "{...}"
   *
   * @generated from enum value: JSON = 10;
   */
  JSON = 10,

  /**
   * Such as [1.0, 2.0, 3.5]
   *
   * @generated from enum value: ARRAY_OF_NUMBERS = 11;
   */
  ARRAY_OF_NUMBERS = 11,

  /**
   * For selecting the embed_model_version_id for context based models.
   * This is a string type in the API request.
   *
   * @generated from enum value: WORKFLOW_EMBED_MODELS = 12;
   */
  WORKFLOW_EMBED_MODELS = 12,

  /**
   * Such as ['a', 'b', 'cantaloupe']
   *
   * @generated from enum value: ARRAY_OF_STRINGS = 13;
   */
  ARRAY_OF_STRINGS = 13,

  /**
   * If RECURSIVE_ENUM is used then the "enum_options" field should also be filled in with the respective ID and description
   * for the different RECURSIVE_ENUM options, as well as model_type_fields for each enum choice.
   *
   * @generated from enum value: RECURSIVE_ENUM = 14;
   */
  RECURSIVE_ENUM = 14,

  /**
   * For blocks of code that need to be specified by the user for setup or execution during workflow runs.
   *
   * @generated from enum value: PYTHON_CODE = 15;
   */
  PYTHON_CODE = 15,

  /**
   * For selecting a dataset id in model parameters. String in API request.
   *
   * @generated from enum value: DATASET_ID = 16;
   */
  DATASET_ID = 16,

  /**
   * For selecting a dataset version id. String.
   *
   * @generated from enum value: DATASET_VERSION_ID = 17;
   */
  DATASET_VERSION_ID = 17,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelTypeField_ModelTypeFieldType)
proto3.util.setEnumType(ModelTypeField_ModelTypeFieldType, "clarifai.api.ModelTypeField.ModelTypeFieldType", [
  { no: 0, name: "INVALID_MODEL_TYPE_FIELD_TYPE" },
  { no: 1, name: "BOOLEAN" },
  { no: 2, name: "STRING" },
  { no: 3, name: "NUMBER" },
  { no: 4, name: "ARRAY_OF_CONCEPTS" },
  { no: 5, name: "ARRAY_OF_CONCEPTS_WITH_THRESHOLD" },
  { no: 7, name: "RANGE" },
  { no: 8, name: "ENUM" },
  { no: 9, name: "COLLABORATORS" },
  { no: 10, name: "JSON" },
  { no: 11, name: "ARRAY_OF_NUMBERS" },
  { no: 12, name: "WORKFLOW_EMBED_MODELS" },
  { no: 13, name: "ARRAY_OF_STRINGS" },
  { no: 14, name: "RECURSIVE_ENUM" },
  { no: 15, name: "PYTHON_CODE" },
  { no: 16, name: "DATASET_ID" },
  { no: 17, name: "DATASET_VERSION_ID" },
]);

/**
 * ModelTypeRangeInfo
 *
 * @generated from message clarifai.api.ModelTypeRangeInfo
 */
export class ModelTypeRangeInfo extends Message<ModelTypeRangeInfo> {
  /**
   * The start of the range as a float.
   *
   * @generated from field: float min = 1;
   */
  min = 0;

  /**
   * The end of the range as a float.
   *
   * @generated from field: float max = 2;
   */
  max = 0;

  /**
   * An optional step size for the range. If provided then only values at that step size will be
   * rounded to. For example if step is 0.02 then 0.0245 will round to 0.02.
   *
   * @generated from field: float step = 3;
   */
  step = 0;

  constructor(data?: PartialMessage<ModelTypeRangeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelTypeRangeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "step", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTypeRangeInfo {
    return new ModelTypeRangeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTypeRangeInfo {
    return new ModelTypeRangeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTypeRangeInfo {
    return new ModelTypeRangeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTypeRangeInfo | PlainMessage<ModelTypeRangeInfo> | undefined, b: ModelTypeRangeInfo | PlainMessage<ModelTypeRangeInfo> | undefined): boolean {
    return proto3.util.equals(ModelTypeRangeInfo, a, b);
  }
}

/**
 * ModelTypeEnumOption
 *
 * @generated from message clarifai.api.ModelTypeEnumOption
 */
export class ModelTypeEnumOption extends Message<ModelTypeEnumOption> {
  /**
   * The unique value of the enum option.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * List of other ID values that are equivalent with this ID.
   * This allows the user to choose this option by multiple IDs.
   * Example: if enum is "Phone Number Prefix", you could add an option that is selectable by two values:
   * 1. ID: "Estonia"
   * 2. Alias: 37
   *
   * @generated from field: repeated clarifai.api.ModelTypeEnumOptionAlias aliases = 5;
   */
  aliases: ModelTypeEnumOptionAlias[] = [];

  /**
   * Optional description for this enum option.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * These are additional fields that are specific to this enum choice. This allows
   * us to use enums to control configuration settings as well.
   *
   * @generated from field: repeated clarifai.api.ModelTypeField model_type_fields = 3;
   */
  modelTypeFields: ModelTypeField[] = [];

  /**
   * If this enum option should be internal only.
   *
   * @generated from field: bool internal_only = 4;
   */
  internalOnly = false;

  constructor(data?: PartialMessage<ModelTypeEnumOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelTypeEnumOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "aliases", kind: "message", T: ModelTypeEnumOptionAlias, repeated: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_type_fields", kind: "message", T: ModelTypeField, repeated: true },
    { no: 4, name: "internal_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTypeEnumOption {
    return new ModelTypeEnumOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTypeEnumOption {
    return new ModelTypeEnumOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTypeEnumOption {
    return new ModelTypeEnumOption().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTypeEnumOption | PlainMessage<ModelTypeEnumOption> | undefined, b: ModelTypeEnumOption | PlainMessage<ModelTypeEnumOption> | undefined): boolean {
    return proto3.util.equals(ModelTypeEnumOption, a, b);
  }
}

/**
 * @generated from message clarifai.api.ModelTypeEnumOptionAlias
 */
export class ModelTypeEnumOptionAlias extends Message<ModelTypeEnumOptionAlias> {
  /**
   * Integer alias for id.
   *
   * @generated from field: int64 id_int = 1;
   */
  idInt = protoInt64.zero;

  /**
   * String that can contain wild cards and the regex needs to match.
   *
   * @generated from field: string wildcard_string = 2;
   */
  wildcardString = "";

  constructor(data?: PartialMessage<ModelTypeEnumOptionAlias>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelTypeEnumOptionAlias";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id_int", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "wildcard_string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTypeEnumOptionAlias {
    return new ModelTypeEnumOptionAlias().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTypeEnumOptionAlias {
    return new ModelTypeEnumOptionAlias().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTypeEnumOptionAlias {
    return new ModelTypeEnumOptionAlias().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTypeEnumOptionAlias | PlainMessage<ModelTypeEnumOptionAlias> | undefined, b: ModelTypeEnumOptionAlias | PlainMessage<ModelTypeEnumOptionAlias> | undefined): boolean {
    return proto3.util.equals(ModelTypeEnumOptionAlias, a, b);
  }
}

/**
 * ModelQuery
 *
 * @generated from message clarifai.api.ModelQuery
 */
export class ModelQuery extends Message<ModelQuery> {
  /**
   * The name ofthe field. This supports wilcard queries like "gen*" to match "general" as an example.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
   * supported.
   *
   * @generated from field: string model_type_id = 3;
   */
  modelTypeId = "";

  constructor(data?: PartialMessage<ModelQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_type_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelQuery {
    return new ModelQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelQuery {
    return new ModelQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelQuery {
    return new ModelQuery().fromJsonString(jsonString, options);
  }

  static equals(a: ModelQuery | PlainMessage<ModelQuery> | undefined, b: ModelQuery | PlainMessage<ModelQuery> | undefined): boolean {
    return proto3.util.equals(ModelQuery, a, b);
  }
}

/**
 * ModelVersion
 *
 * @generated from message clarifai.api.ModelVersion
 */
export class ModelVersion extends Message<ModelVersion> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the version was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * The status of the version (whether it's untrained, training, trained, etc.).
   *
   * @generated from field: clarifai.api.status.Status status = 3;
   */
  status?: Status;

  /**
   * @generated from field: uint32 active_concept_count = 4;
   */
  activeConceptCount = 0;

  /**
   * @generated from field: clarifai.api.EvalMetrics metrics = 5;
   */
  metrics?: EvalMetrics;

  /**
   * number of inputs in the model version
   *
   * @generated from field: uint32 total_input_count = 6;
   */
  totalInputCount = 0;

  /**
   * @generated from field: clarifai.api.PretrainedModelConfig pretrained_model_config = 7;
   */
  pretrainedModelConfig?: PretrainedModelConfig;

  /**
   * Detailed training stats.
   *
   * @generated from field: clarifai.api.TrainStats train_stats = 8;
   */
  trainStats?: TrainStats;

  /**
   * When training of this version was completed.
   *
   * @generated from field: google.protobuf.Timestamp completed_at = 10;
   */
  completedAt?: Timestamp;

  /**
   * Description about this version
   *
   * @generated from field: string description = 11;
   */
  description = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 12;
   */
  visibility?: Visibility;

  /**
   * The app the model version belongs to.
   *
   * @generated from field: string app_id = 13;
   */
  appId = "";

  /**
   * The user the model version belongs to.
   *
   * @generated from field: string user_id = 14;
   */
  userId = "";

  /**
   * When this model version was last modified
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 15;
   */
  modifiedAt?: Timestamp;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 16;
   */
  metadata?: Struct;

  /**
   * @generated from field: string license = 17;
   */
  license = "";

  /**
   * Dataset version used to create this model version.
   *
   * @generated from field: clarifai.api.DatasetVersion dataset_version = 18;
   */
  datasetVersion?: DatasetVersion;

  constructor(data?: PartialMessage<ModelVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "status", kind: "message", T: Status },
    { no: 4, name: "active_concept_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "metrics", kind: "message", T: EvalMetrics },
    { no: 6, name: "total_input_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "pretrained_model_config", kind: "message", T: PretrainedModelConfig },
    { no: 8, name: "train_stats", kind: "message", T: TrainStats },
    { no: 10, name: "completed_at", kind: "message", T: Timestamp },
    { no: 11, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "visibility", kind: "message", T: Visibility },
    { no: 13, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "modified_at", kind: "message", T: Timestamp },
    { no: 16, name: "metadata", kind: "message", T: Struct },
    { no: 17, name: "license", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "dataset_version", kind: "message", T: DatasetVersion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelVersion {
    return new ModelVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelVersion {
    return new ModelVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelVersion {
    return new ModelVersion().fromJsonString(jsonString, options);
  }

  static equals(a: ModelVersion | PlainMessage<ModelVersion> | undefined, b: ModelVersion | PlainMessage<ModelVersion> | undefined): boolean {
    return proto3.util.equals(ModelVersion, a, b);
  }
}

/**
 * PretrainedModelConfig
 *
 * @generated from message clarifai.api.PretrainedModelConfig
 */
export class PretrainedModelConfig extends Message<PretrainedModelConfig> {
  /**
   * This is the internal id of the pretrained model.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Map from the api.Data field names to the Triton config.pbtxt input.
   *
   * @generated from field: google.protobuf.Struct input_fields_map = 3;
   */
  inputFieldsMap?: Struct;

  /**
   * Map from the api.Data field names to the Triton config.pbtxt output.
   *
   * @generated from field: google.protobuf.Struct output_fields_map = 4;
   */
  outputFieldsMap?: Struct;

  /**
   * Url to a zipped up model in triton format with the following files and folders at the root:
   *  config.pbtxt
   *  version 1 folder that contains model files (onnx graph, torch script, python BE model, and etc.)
   *
   * @generated from field: string model_zip_url = 6;
   */
  modelZipUrl = "";

  /**
   * Whether to overwrite the model for the existing internal id
   *
   * @generated from field: bool overwrite = 7;
   */
  overwrite = false;

  constructor(data?: PartialMessage<PretrainedModelConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PretrainedModelConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "input_fields_map", kind: "message", T: Struct },
    { no: 4, name: "output_fields_map", kind: "message", T: Struct },
    { no: 6, name: "model_zip_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "overwrite", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PretrainedModelConfig {
    return new PretrainedModelConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PretrainedModelConfig {
    return new PretrainedModelConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PretrainedModelConfig {
    return new PretrainedModelConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PretrainedModelConfig | PlainMessage<PretrainedModelConfig> | undefined, b: PretrainedModelConfig | PlainMessage<PretrainedModelConfig> | undefined): boolean {
    return proto3.util.equals(PretrainedModelConfig, a, b);
  }
}

/**
 * TrainStats
 *
 * @generated from message clarifai.api.TrainStats
 */
export class TrainStats extends Message<TrainStats> {
  /**
   * @generated from field: repeated clarifai.api.LossCurveEntry loss_curve = 1;
   */
  lossCurve: LossCurveEntry[] = [];

  constructor(data?: PartialMessage<TrainStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TrainStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "loss_curve", kind: "message", T: LossCurveEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrainStats {
    return new TrainStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrainStats {
    return new TrainStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrainStats {
    return new TrainStats().fromJsonString(jsonString, options);
  }

  static equals(a: TrainStats | PlainMessage<TrainStats> | undefined, b: TrainStats | PlainMessage<TrainStats> | undefined): boolean {
    return proto3.util.equals(TrainStats, a, b);
  }
}

/**
 * LossCurveEntry
 *
 * @generated from message clarifai.api.LossCurveEntry
 */
export class LossCurveEntry extends Message<LossCurveEntry> {
  /**
   * current epoch
   *
   * @generated from field: uint32 epoch = 1;
   */
  epoch = 0;

  /**
   * current global step
   *
   * @generated from field: uint32 global_step = 2;
   */
  globalStep = 0;

  /**
   * current cost
   * FIXME(rigel): this should be loss instead of cost.
   *
   * @generated from field: float cost = 3;
   */
  cost = 0;

  constructor(data?: PartialMessage<LossCurveEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LossCurveEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "global_step", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "cost", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LossCurveEntry {
    return new LossCurveEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LossCurveEntry {
    return new LossCurveEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LossCurveEntry {
    return new LossCurveEntry().fromJsonString(jsonString, options);
  }

  static equals(a: LossCurveEntry | PlainMessage<LossCurveEntry> | undefined, b: LossCurveEntry | PlainMessage<LossCurveEntry> | undefined): boolean {
    return proto3.util.equals(LossCurveEntry, a, b);
  }
}

/**
 * LabelCount
 *
 * @generated from message clarifai.api.LabelCount
 */
export class LabelCount extends Message<LabelCount> {
  /**
   * FIXME: should move to Concept object and return the whole thing (including name and id)
   * otherwise if two concepts have same name then you won't tell them apart in confusion matrix.
   *
   * @generated from field: string concept_name = 1;
   */
  conceptName = "";

  /**
   * @generated from field: uint32 count = 2;
   */
  count = 0;

  constructor(data?: PartialMessage<LabelCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LabelCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concept_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelCount {
    return new LabelCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelCount {
    return new LabelCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelCount {
    return new LabelCount().fromJsonString(jsonString, options);
  }

  static equals(a: LabelCount | PlainMessage<LabelCount> | undefined, b: LabelCount | PlainMessage<LabelCount> | undefined): boolean {
    return proto3.util.equals(LabelCount, a, b);
  }
}

/**
 * LabelDistribution
 *
 * @generated from message clarifai.api.LabelDistribution
 */
export class LabelDistribution extends Message<LabelDistribution> {
  /**
   * @generated from field: repeated clarifai.api.LabelCount positive_label_counts = 1;
   */
  positiveLabelCounts: LabelCount[] = [];

  constructor(data?: PartialMessage<LabelDistribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LabelDistribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positive_label_counts", kind: "message", T: LabelCount, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelDistribution {
    return new LabelDistribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelDistribution {
    return new LabelDistribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelDistribution {
    return new LabelDistribution().fromJsonString(jsonString, options);
  }

  static equals(a: LabelDistribution | PlainMessage<LabelDistribution> | undefined, b: LabelDistribution | PlainMessage<LabelDistribution> | undefined): boolean {
    return proto3.util.equals(LabelDistribution, a, b);
  }
}

/**
 * NOTE: this is inefficient, should just have the order of the rows/cols
 *
 * @generated from message clarifai.api.CooccurrenceMatrixEntry
 */
export class CooccurrenceMatrixEntry extends Message<CooccurrenceMatrixEntry> {
  /**
   * concept_id for the row
   *
   * @generated from field: string row = 1;
   */
  row = "";

  /**
   * concept_id for the col
   *
   * @generated from field: string col = 2;
   */
  col = "";

  /**
   * @generated from field: uint32 count = 3;
   */
  count = 0;

  constructor(data?: PartialMessage<CooccurrenceMatrixEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.CooccurrenceMatrixEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "col", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CooccurrenceMatrixEntry {
    return new CooccurrenceMatrixEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CooccurrenceMatrixEntry {
    return new CooccurrenceMatrixEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CooccurrenceMatrixEntry {
    return new CooccurrenceMatrixEntry().fromJsonString(jsonString, options);
  }

  static equals(a: CooccurrenceMatrixEntry | PlainMessage<CooccurrenceMatrixEntry> | undefined, b: CooccurrenceMatrixEntry | PlainMessage<CooccurrenceMatrixEntry> | undefined): boolean {
    return proto3.util.equals(CooccurrenceMatrixEntry, a, b);
  }
}

/**
 * CooccurrenceMatrix
 *
 * @generated from message clarifai.api.CooccurrenceMatrix
 */
export class CooccurrenceMatrix extends Message<CooccurrenceMatrix> {
  /**
   * @generated from field: repeated clarifai.api.CooccurrenceMatrixEntry matrix = 1;
   */
  matrix: CooccurrenceMatrixEntry[] = [];

  /**
   * These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
   *
   * @generated from field: repeated string concept_ids = 2;
   */
  conceptIds: string[] = [];

  constructor(data?: PartialMessage<CooccurrenceMatrix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.CooccurrenceMatrix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "matrix", kind: "message", T: CooccurrenceMatrixEntry, repeated: true },
    { no: 2, name: "concept_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CooccurrenceMatrix {
    return new CooccurrenceMatrix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CooccurrenceMatrix {
    return new CooccurrenceMatrix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CooccurrenceMatrix {
    return new CooccurrenceMatrix().fromJsonString(jsonString, options);
  }

  static equals(a: CooccurrenceMatrix | PlainMessage<CooccurrenceMatrix> | undefined, b: CooccurrenceMatrix | PlainMessage<CooccurrenceMatrix> | undefined): boolean {
    return proto3.util.equals(CooccurrenceMatrix, a, b);
  }
}

/**
 * ConfusionMatrixEntry
 *
 * @generated from message clarifai.api.ConfusionMatrixEntry
 */
export class ConfusionMatrixEntry extends Message<ConfusionMatrixEntry> {
  /**
   * @generated from field: string predicted = 1;
   */
  predicted = "";

  /**
   * @generated from field: string actual = 2;
   */
  actual = "";

  /**
   * @generated from field: float value = 4;
   */
  value = 0;

  constructor(data?: PartialMessage<ConfusionMatrixEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConfusionMatrixEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicted", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "actual", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfusionMatrixEntry {
    return new ConfusionMatrixEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfusionMatrixEntry {
    return new ConfusionMatrixEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfusionMatrixEntry {
    return new ConfusionMatrixEntry().fromJsonString(jsonString, options);
  }

  static equals(a: ConfusionMatrixEntry | PlainMessage<ConfusionMatrixEntry> | undefined, b: ConfusionMatrixEntry | PlainMessage<ConfusionMatrixEntry> | undefined): boolean {
    return proto3.util.equals(ConfusionMatrixEntry, a, b);
  }
}

/**
 * ConfusionMatrix
 *
 * @generated from message clarifai.api.ConfusionMatrix
 */
export class ConfusionMatrix extends Message<ConfusionMatrix> {
  /**
   * @generated from field: repeated clarifai.api.ConfusionMatrixEntry matrix = 1;
   */
  matrix: ConfusionMatrixEntry[] = [];

  /**
   * These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
   *
   * @generated from field: repeated string concept_ids = 2;
   */
  conceptIds: string[] = [];

  constructor(data?: PartialMessage<ConfusionMatrix>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ConfusionMatrix";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "matrix", kind: "message", T: ConfusionMatrixEntry, repeated: true },
    { no: 2, name: "concept_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfusionMatrix {
    return new ConfusionMatrix().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfusionMatrix {
    return new ConfusionMatrix().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfusionMatrix {
    return new ConfusionMatrix().fromJsonString(jsonString, options);
  }

  static equals(a: ConfusionMatrix | PlainMessage<ConfusionMatrix> | undefined, b: ConfusionMatrix | PlainMessage<ConfusionMatrix> | undefined): boolean {
    return proto3.util.equals(ConfusionMatrix, a, b);
  }
}

/**
 * ROC
 *
 * @generated from message clarifai.api.ROC
 */
export class ROC extends Message<ROC> {
  /**
   * @generated from field: repeated float fpr = 1;
   */
  fpr: number[] = [];

  /**
   * @generated from field: repeated float tpr = 2;
   */
  tpr: number[] = [];

  /**
   * @generated from field: repeated float thresholds = 3;
   */
  thresholds: number[] = [];

  /**
   * @generated from field: repeated float fpr_per_image = 4;
   */
  fprPerImage: number[] = [];

  /**
   * @generated from field: repeated float fpr_per_object = 5;
   */
  fprPerObject: number[] = [];

  constructor(data?: PartialMessage<ROC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ROC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fpr", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "tpr", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 3, name: "thresholds", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 4, name: "fpr_per_image", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 5, name: "fpr_per_object", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ROC {
    return new ROC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ROC {
    return new ROC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ROC {
    return new ROC().fromJsonString(jsonString, options);
  }

  static equals(a: ROC | PlainMessage<ROC> | undefined, b: ROC | PlainMessage<ROC> | undefined): boolean {
    return proto3.util.equals(ROC, a, b);
  }
}

/**
 * PrecisionRecallCurve
 *
 * @generated from message clarifai.api.PrecisionRecallCurve
 */
export class PrecisionRecallCurve extends Message<PrecisionRecallCurve> {
  /**
   * @generated from field: repeated float recall = 1;
   */
  recall: number[] = [];

  /**
   * @generated from field: repeated float precision = 2;
   */
  precision: number[] = [];

  /**
   * @generated from field: repeated float thresholds = 3;
   */
  thresholds: number[] = [];

  constructor(data?: PartialMessage<PrecisionRecallCurve>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PrecisionRecallCurve";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recall", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 2, name: "precision", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 3, name: "thresholds", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecisionRecallCurve {
    return new PrecisionRecallCurve().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecisionRecallCurve {
    return new PrecisionRecallCurve().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecisionRecallCurve {
    return new PrecisionRecallCurve().fromJsonString(jsonString, options);
  }

  static equals(a: PrecisionRecallCurve | PlainMessage<PrecisionRecallCurve> | undefined, b: PrecisionRecallCurve | PlainMessage<PrecisionRecallCurve> | undefined): boolean {
    return proto3.util.equals(PrecisionRecallCurve, a, b);
  }
}

/**
 * BinaryMetrics
 *
 * @generated from message clarifai.api.BinaryMetrics
 */
export class BinaryMetrics extends Message<BinaryMetrics> {
  /**
   * @generated from field: uint32 num_pos = 1;
   */
  numPos = 0;

  /**
   * @generated from field: uint32 num_neg = 2;
   */
  numNeg = 0;

  /**
   * @generated from field: uint32 num_tot = 3;
   */
  numTot = 0;

  /**
   * @generated from field: float roc_auc = 4;
   */
  rocAuc = 0;

  /**
   * @generated from field: float f1 = 5;
   */
  f1 = 0;

  /**
   * @generated from field: clarifai.api.Concept concept = 6;
   */
  concept?: Concept;

  /**
   * @generated from field: clarifai.api.ROC roc_curve = 7;
   */
  rocCurve?: ROC;

  /**
   * @generated from field: clarifai.api.PrecisionRecallCurve precision_recall_curve = 8;
   */
  precisionRecallCurve?: PrecisionRecallCurve;

  /**
   * @generated from field: float avg_precision = 9;
   */
  avgPrecision = 0;

  /**
   * @generated from field: string area_name = 10;
   */
  areaName = "";

  /**
   * @generated from field: double area_min = 11;
   */
  areaMin = 0;

  /**
   * @generated from field: double area_max = 12;
   */
  areaMax = 0;

  /**
   * @generated from field: float iou = 13;
   */
  iou = 0;

  constructor(data?: PartialMessage<BinaryMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.BinaryMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_pos", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "num_neg", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "num_tot", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "roc_auc", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "f1", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "concept", kind: "message", T: Concept },
    { no: 7, name: "roc_curve", kind: "message", T: ROC },
    { no: 8, name: "precision_recall_curve", kind: "message", T: PrecisionRecallCurve },
    { no: 9, name: "avg_precision", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 10, name: "area_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "area_min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "area_max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "iou", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryMetrics {
    return new BinaryMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryMetrics {
    return new BinaryMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryMetrics {
    return new BinaryMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryMetrics | PlainMessage<BinaryMetrics> | undefined, b: BinaryMetrics | PlainMessage<BinaryMetrics> | undefined): boolean {
    return proto3.util.equals(BinaryMetrics, a, b);
  }
}

/**
 * TrackerMetrics
 *
 * @generated from message clarifai.api.TrackerMetrics
 */
export class TrackerMetrics extends Message<TrackerMetrics> {
  /**
   * Multiple object tracking accuracy
   *
   * @generated from field: float mot_mota = 1;
   */
  motMota = 0;

  /**
   * Number of switches between tracks
   *
   * @generated from field: int32 mot_num_switches = 2;
   */
  motNumSwitches = 0;

  /**
   * MORSE fragmentation rate (a.k.a unique switch rate, only calculated in public sector)
   *
   * @generated from field: float morse_frag = 3;
   */
  morseFrag = 0;

  /**
   * Average precision calculated from all processed frames
   *
   * @generated from field: float avg_precision = 4;
   */
  avgPrecision = 0;

  /**
   * The concept that we are evaluating the tracker
   *
   * @generated from field: string aiid = 5;
   */
  aiid = "";

  /**
   * Same as morse_frag but calculated using MOT mapping/metrics
   *
   * @generated from field: float unique_switch_rate = 6;
   */
  uniqueSwitchRate = 0;

  constructor(data?: PartialMessage<TrackerMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TrackerMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mot_mota", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "mot_num_switches", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "morse_frag", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "avg_precision", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "aiid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "unique_switch_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrackerMetrics {
    return new TrackerMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrackerMetrics {
    return new TrackerMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrackerMetrics {
    return new TrackerMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: TrackerMetrics | PlainMessage<TrackerMetrics> | undefined, b: TrackerMetrics | PlainMessage<TrackerMetrics> | undefined): boolean {
    return proto3.util.equals(TrackerMetrics, a, b);
  }
}

/**
 * EvalTestSetEntry
 *
 * @generated from message clarifai.api.EvalTestSetEntry
 */
export class EvalTestSetEntry extends Message<EvalTestSetEntry> {
  /**
   * Input CFID
   *
   * @generated from field: string id = 1 [deprecated = true];
   * @deprecated
   */
  id = "";

  /**
   * @generated from field: string url = 2 [deprecated = true];
   * @deprecated
   */
  url = "";

  /**
   * the input information
   *
   * @generated from field: clarifai.api.Input input = 6;
   */
  input?: Input;

  /**
   * @generated from field: repeated clarifai.api.Concept predicted_concepts = 3;
   */
  predictedConcepts: Concept[] = [];

  /**
   * All the ground truth concepts will be show on the top level
   *
   * @generated from field: repeated clarifai.api.Concept ground_truth_concepts = 4;
   */
  groundTruthConcepts: Concept[] = [];

  /**
   * Only region-based/frame-based app contains this annotation
   * Each annotation only contains one region
   * And the concepts is in ground_truth_concepts instead of this annotation
   *
   * @generated from field: clarifai.api.Annotation annotation = 5;
   */
  annotation?: Annotation;

  constructor(data?: PartialMessage<EvalTestSetEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EvalTestSetEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "input", kind: "message", T: Input },
    { no: 3, name: "predicted_concepts", kind: "message", T: Concept, repeated: true },
    { no: 4, name: "ground_truth_concepts", kind: "message", T: Concept, repeated: true },
    { no: 5, name: "annotation", kind: "message", T: Annotation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvalTestSetEntry {
    return new EvalTestSetEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvalTestSetEntry {
    return new EvalTestSetEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvalTestSetEntry {
    return new EvalTestSetEntry().fromJsonString(jsonString, options);
  }

  static equals(a: EvalTestSetEntry | PlainMessage<EvalTestSetEntry> | undefined, b: EvalTestSetEntry | PlainMessage<EvalTestSetEntry> | undefined): boolean {
    return proto3.util.equals(EvalTestSetEntry, a, b);
  }
}

/**
 * LOPQEvalResult
 *
 * @generated from message clarifai.api.LOPQEvalResult
 */
export class LOPQEvalResult extends Message<LOPQEvalResult> {
  /**
   * Rank k for which all metrics are reported.
   *
   * @generated from field: int32 k = 1;
   */
  k = 0;

  /**
   * Recall @ k assuming the brute force search is the ground truth.
   *
   * @generated from field: float recall_vs_brute_force = 2;
   */
  recallVsBruteForce = 0;

  /**
   * Kendall's tau correlation @ k assuming the brute force search is the ground truth.
   *
   * @generated from field: float kendall_tau_vs_brute_force = 3;
   */
  kendallTauVsBruteForce = 0;

  /**
   * The percentage of the most frequent code in the indexed part of evaluation data.
   *
   * @generated from field: float most_frequent_code_percent = 4;
   */
  mostFrequentCodePercent = 0;

  /**
   * Normalized Discounted Cumulative Gain (NDCG) @ k with a ground truth inferred from annotations
   * and/or prediction for this evaluation LOPQ model.
   * NDCG uses individual relevance scores of each returned image to evaluate the usefulness, or
   * gain, of a document based on its position in the result list. The premise of DCG is that
   * highly relevant documents appearing lower in a search result list should be penalized as the
   * graded relevance value is reduced logarithmically proportional to the position of the result.
   * See: https://en.wikipedia.org/wiki/Information_retrieval#Discounted_cumulative_gain
   * 
   * To compute the relevance score between two images we consider two cases:
   * 1) Only one label for each image
   * An image is relevant to an image query iff they are labeled the same (score 1), and
   * not relevant otherwise (score 0)
   * 2) Multiple labels for each image
   * Here an image relevancy with respect to a single image query is measured by f-beta score
   * assuming the query image list of labels as ground truth and comparing them with that of
   * the search result. These labels can come from image annotations or if substitute_annotation_misses
   * is set, predictions of base classifier where any prediction with prob < prob_threshold are
   * discarded. To quantify the relevancy score of a single search result we opt to compute precision
   * and recall @ k for simplicity, and combine them with f-beta score to obtain a single number.
   *
   * @generated from field: float lopq_ndcg = 5;
   */
  lopqNdcg = 0;

  /**
   * Brute force NDCG which gives a baseline to compare to and is a measure of how good
   * the embeddings are.
   *
   * @generated from field: float brute_force_ndcg = 6;
   */
  bruteForceNdcg = 0;

  constructor(data?: PartialMessage<LOPQEvalResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LOPQEvalResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "k", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "recall_vs_brute_force", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "kendall_tau_vs_brute_force", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "most_frequent_code_percent", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "lopq_ndcg", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "brute_force_ndcg", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LOPQEvalResult {
    return new LOPQEvalResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LOPQEvalResult {
    return new LOPQEvalResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LOPQEvalResult {
    return new LOPQEvalResult().fromJsonString(jsonString, options);
  }

  static equals(a: LOPQEvalResult | PlainMessage<LOPQEvalResult> | undefined, b: LOPQEvalResult | PlainMessage<LOPQEvalResult> | undefined): boolean {
    return proto3.util.equals(LOPQEvalResult, a, b);
  }
}

/**
 * MetricsSummary
 *
 * @generated from message clarifai.api.MetricsSummary
 */
export class MetricsSummary extends Message<MetricsSummary> {
  /**
   * @generated from field: float top1_accuracy = 1 [deprecated = true];
   * @deprecated
   */
  top1Accuracy = 0;

  /**
   * @generated from field: float top5_accuracy = 2 [deprecated = true];
   * @deprecated
   */
  top5Accuracy = 0;

  /**
   * @generated from field: float macro_avg_roc_auc = 3;
   */
  macroAvgRocAuc = 0;

  /**
   * @generated from field: float macro_std_roc_auc = 4;
   */
  macroStdRocAuc = 0;

  /**
   * @generated from field: float macro_avg_f1_score = 5;
   */
  macroAvgF1Score = 0;

  /**
   * @generated from field: float macro_std_f1_score = 6;
   */
  macroStdF1Score = 0;

  /**
   * @generated from field: float macro_avg_precision = 7;
   */
  macroAvgPrecision = 0;

  /**
   * @generated from field: float macro_avg_recall = 8;
   */
  macroAvgRecall = 0;

  /**
   * @generated from field: float mean_avg_precision_iou_50 = 10;
   */
  meanAvgPrecisionIou50 = 0;

  /**
   * @generated from field: float mean_avg_precision_iou_range = 11;
   */
  meanAvgPrecisionIouRange = 0;

  /**
   * @generated from field: repeated clarifai.api.LOPQEvalResult lopq_metrics = 9;
   */
  lopqMetrics: LOPQEvalResult[] = [];

  constructor(data?: PartialMessage<MetricsSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.MetricsSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top1_accuracy", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "top5_accuracy", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "macro_avg_roc_auc", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "macro_std_roc_auc", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "macro_avg_f1_score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "macro_std_f1_score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 7, name: "macro_avg_precision", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "macro_avg_recall", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 10, name: "mean_avg_precision_iou_50", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 11, name: "mean_avg_precision_iou_range", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 9, name: "lopq_metrics", kind: "message", T: LOPQEvalResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsSummary {
    return new MetricsSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsSummary {
    return new MetricsSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsSummary {
    return new MetricsSummary().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsSummary | PlainMessage<MetricsSummary> | undefined, b: MetricsSummary | PlainMessage<MetricsSummary> | undefined): boolean {
    return proto3.util.equals(MetricsSummary, a, b);
  }
}

/**
 * EvalMetrics
 *
 * @generated from message clarifai.api.EvalMetrics
 */
export class EvalMetrics extends Message<EvalMetrics> {
  /**
   * @generated from field: clarifai.api.status.Status status = 1;
   */
  status?: Status;

  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * @generated from field: clarifai.api.MetricsSummary summary = 2;
   */
  summary?: MetricsSummary;

  /**
   * @generated from field: clarifai.api.ConfusionMatrix confusion_matrix = 3;
   */
  confusionMatrix?: ConfusionMatrix;

  /**
   * @generated from field: clarifai.api.CooccurrenceMatrix cooccurrence_matrix = 4;
   */
  cooccurrenceMatrix?: CooccurrenceMatrix;

  /**
   * @generated from field: clarifai.api.LabelDistribution label_counts = 5;
   */
  labelCounts?: LabelDistribution;

  /**
   * @generated from field: repeated clarifai.api.BinaryMetrics binary_metrics = 6;
   */
  binaryMetrics: BinaryMetrics[] = [];

  /**
   * @generated from field: repeated clarifai.api.EvalTestSetEntry test_set = 7;
   */
  testSet: EvalTestSetEntry[] = [];

  /**
   * @generated from field: repeated clarifai.api.BinaryMetrics metrics_by_area = 8;
   */
  metricsByArea: BinaryMetrics[] = [];

  /**
   * @generated from field: repeated clarifai.api.BinaryMetrics metrics_by_class = 9;
   */
  metricsByClass: BinaryMetrics[] = [];

  /**
   * @generated from field: repeated clarifai.api.TrackerMetrics tracker_metrics = 11;
   */
  trackerMetrics: TrackerMetrics[] = [];

  /**
   * @generated from field: clarifai.api.EvalInfo eval_info = 12;
   */
  evalInfo?: EvalInfo;

  constructor(data?: PartialMessage<EvalMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EvalMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: Status },
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "summary", kind: "message", T: MetricsSummary },
    { no: 3, name: "confusion_matrix", kind: "message", T: ConfusionMatrix },
    { no: 4, name: "cooccurrence_matrix", kind: "message", T: CooccurrenceMatrix },
    { no: 5, name: "label_counts", kind: "message", T: LabelDistribution },
    { no: 6, name: "binary_metrics", kind: "message", T: BinaryMetrics, repeated: true },
    { no: 7, name: "test_set", kind: "message", T: EvalTestSetEntry, repeated: true },
    { no: 8, name: "metrics_by_area", kind: "message", T: BinaryMetrics, repeated: true },
    { no: 9, name: "metrics_by_class", kind: "message", T: BinaryMetrics, repeated: true },
    { no: 11, name: "tracker_metrics", kind: "message", T: TrackerMetrics, repeated: true },
    { no: 12, name: "eval_info", kind: "message", T: EvalInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvalMetrics {
    return new EvalMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvalMetrics {
    return new EvalMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvalMetrics {
    return new EvalMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: EvalMetrics | PlainMessage<EvalMetrics> | undefined, b: EvalMetrics | PlainMessage<EvalMetrics> | undefined): boolean {
    return proto3.util.equals(EvalMetrics, a, b);
  }
}

/**
 * FieldsValue
 *
 * @generated from message clarifai.api.FieldsValue
 */
export class FieldsValue extends Message<FieldsValue> {
  /**
   * @generated from field: bool confusion_matrix = 1;
   */
  confusionMatrix = false;

  /**
   * @generated from field: bool cooccurrence_matrix = 2;
   */
  cooccurrenceMatrix = false;

  /**
   * @generated from field: bool label_counts = 3;
   */
  labelCounts = false;

  /**
   * @generated from field: bool binary_metrics = 4;
   */
  binaryMetrics = false;

  /**
   * @generated from field: bool test_set = 5;
   */
  testSet = false;

  /**
   * @generated from field: bool metrics_by_area = 6;
   */
  metricsByArea = false;

  /**
   * @generated from field: bool metrics_by_class = 7;
   */
  metricsByClass = false;

  constructor(data?: PartialMessage<FieldsValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.FieldsValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confusion_matrix", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "cooccurrence_matrix", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "label_counts", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "binary_metrics", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "test_set", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "metrics_by_area", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "metrics_by_class", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldsValue {
    return new FieldsValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldsValue {
    return new FieldsValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldsValue {
    return new FieldsValue().fromJsonString(jsonString, options);
  }

  static equals(a: FieldsValue | PlainMessage<FieldsValue> | undefined, b: FieldsValue | PlainMessage<FieldsValue> | undefined): boolean {
    return proto3.util.equals(FieldsValue, a, b);
  }
}

/**
 * Output
 *
 * @generated from message clarifai.api.Output
 */
export class Output extends Message<Output> {
  /**
   * One of these outputs per Input
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: clarifai.api.status.Status status = 2;
   */
  status?: Status;

  /**
   * When the object was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * The model that created this Output.
   *
   * @generated from field: clarifai.api.Model model = 4;
   */
  model?: Model;

  /**
   * The input that was passed to the model to create this Output. For example if we have an image
   * model then it will take as input here an Input object with Image filled in.
   *
   * @generated from field: clarifai.api.Input input = 5;
   */
  input?: Input;

  /**
   * The output data for this Output. For example if we have a concept model then the predicted
   * concepts will appear here.
   *
   * @generated from field: clarifai.api.Data data = 6;
   */
  data?: Data;

  constructor(data?: PartialMessage<Output>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Output";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "message", T: Status },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "model", kind: "message", T: Model },
    { no: 5, name: "input", kind: "message", T: Input },
    { no: 6, name: "data", kind: "message", T: Data },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Output {
    return new Output().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJsonString(jsonString, options);
  }

  static equals(a: Output | PlainMessage<Output> | undefined, b: Output | PlainMessage<Output> | undefined): boolean {
    return proto3.util.equals(Output, a, b);
  }
}

/**
 * ScopeDeps
 *
 * @generated from message clarifai.api.ScopeDeps
 */
export class ScopeDeps extends Message<ScopeDeps> {
  /**
   * The scope
   *
   * @generated from field: string scope = 1;
   */
  scope = "";

  /**
   * Other scopes that are required.
   *
   * @generated from field: repeated string depending_scopes = 2;
   */
  dependingScopes: string[] = [];

  constructor(data?: PartialMessage<ScopeDeps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ScopeDeps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "depending_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopeDeps {
    return new ScopeDeps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopeDeps {
    return new ScopeDeps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopeDeps {
    return new ScopeDeps().fromJsonString(jsonString, options);
  }

  static equals(a: ScopeDeps | PlainMessage<ScopeDeps> | undefined, b: ScopeDeps | PlainMessage<ScopeDeps> | undefined): boolean {
    return proto3.util.equals(ScopeDeps, a, b);
  }
}

/**
 * EndpointDeps
 *
 * @generated from message clarifai.api.EndpointDeps
 */
export class EndpointDeps extends Message<EndpointDeps> {
  /**
   * The fully qualified endpoint to
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint = "";

  /**
   * Other scopes that are required.
   *
   * @generated from field: repeated string depending_scopes = 2;
   */
  dependingScopes: string[] = [];

  constructor(data?: PartialMessage<EndpointDeps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EndpointDeps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "depending_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndpointDeps {
    return new EndpointDeps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndpointDeps {
    return new EndpointDeps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndpointDeps {
    return new EndpointDeps().fromJsonString(jsonString, options);
  }

  static equals(a: EndpointDeps | PlainMessage<EndpointDeps> | undefined, b: EndpointDeps | PlainMessage<EndpointDeps> | undefined): boolean {
    return proto3.util.equals(EndpointDeps, a, b);
  }
}

/**
 * Hit
 *
 * @generated from message clarifai.api.Hit
 */
export class Hit extends Message<Hit> {
  /**
   * This is the score for the ranked Hit results of the search query. This score is a number
   * between 0.0 and 1.0 as it represents a confidence in the search Hit. For example, if you search
   * for "car" and get a close matching Hit, the score should be close to 1.0. If you get a score
   * of close to 0.0 that means it's very disimilar to your query, in this case NOT a "car". There
   * is a special intermediate score of 0.5 that means that the Hit is not really correlated with
   * your search query (ie. not similar or dissimlar to the query) which is a common occurrence
   * when using negate queries.
   * Note: some queries that are just filtering down your app of inputs may just return a score of
   * 1.0 for all Hits.
   *
   * @generated from field: float score = 1;
   */
  score = 0;

  /**
   * This is the matched input returned from the search query. This will contain information about
   * the Input such as the url, created_at time and trusted annotation information (for backwards
   * compatibility with apps that existed before Annotations were introduced.
   *
   * @generated from field: clarifai.api.Input input = 2;
   */
  input?: Input;

  /**
   * We also provide back the specific matched annotation for the above input. We do this in order
   * to support more complex Annotation queries in the And message below. For example if we match
   * the search results to a region in your input, or a frame in a video input, this annotation
   * field will be that matched annotation info and the input will be the image/video that the user
   * originally added which contains those regions / frames.
   *
   * @generated from field: clarifai.api.Annotation annotation = 3;
   */
  annotation?: Annotation;

  /**
   * The customer-facing id of the user who owns the app the asset came from.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * The cfid of the app the asset came from.
   *
   * @generated from field: string app_id = 5;
   */
  appId = "";

  constructor(data?: PartialMessage<Hit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Hit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "input", kind: "message", T: Input },
    { no: 3, name: "annotation", kind: "message", T: Annotation },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hit {
    return new Hit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hit {
    return new Hit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hit {
    return new Hit().fromJsonString(jsonString, options);
  }

  static equals(a: Hit | PlainMessage<Hit> | undefined, b: Hit | PlainMessage<Hit> | undefined): boolean {
    return proto3.util.equals(Hit, a, b);
  }
}

/**
 * This is the common building block of a query which is a sequence of And messages ANDed together.
 * Note that some fields are used too RANK results (affect the scores) and some are used to FILTER
 * results (unordered subset of your app's contents). In general, FILTER operations are more
 * efficient queries at scale and when combined with RANK operations can speed up search performance
 * as you effectively operate on a smaller sub-set of your entire app.
 *
 * @generated from message clarifai.api.And
 */
export class And extends Message<And> {
  /**
   * FILTER by input.data... information.
   * This can include human provided concepts, geo location info, metadata, etc.
   * This is effectively searching over only the trusted annotation attached to an input in your
   * app. To search by more specific annotation fields use the Annotation object here.
   *
   * @generated from field: clarifai.api.Input input = 1;
   */
  input?: Input;

  /**
   * RANK based predicted outputs from models such as custom trained models, pre-trained models,
   * etc. This is also where you enter the image url for a visual search because what we're asking
   * the system to do is find output embedding most visually similar to the provided input (that
   * input being in And.output.input.data.image.url for example). This will return the Hits
   * sorted by visual similarity (1.0 being very similar or exact match and 0.0 being very
   * dissimlar). For a search by Output concept, this means we're asking the system to rank
   * the Hits by confidence of our model's predicted Outputs. So for example if the model
   * predicts an image is 0.95 likely there is a "dog" present, that should related directly
   * to the score returned if you search for Output concept "dog" in your query. This provides
   * a natural ranking to search results based on confidence of predictions from the models and
   * is used when ANDing multiple of these types of RANK by Output queries together as well.
   *
   * @generated from field: clarifai.api.Output output = 2;
   */
  output?: Output;

  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
   *
   * @generated from field: bool negate = 3;
   */
  negate = false;

  /**
   * FILTER by annotation information. This is more flexible than just filtering by
   * Input information because in the general case each input can have several annotations.
   * Some example use cases for filtering by annotations:
   * 1) find all the inputs annotated "dog" by worker_id = "XYZ"
   * 2) find all the annotations associated with embed_model_version_id = "123"
   * 3) find all the annotations that are trusted, etc.
   * 
   * Since all the annotations under the hood are joined to the embedding model's annotation
   * using worker_id's of other models like cluster models or concept models should be
   * combinable with queries like visual search (a query with Output filled in).
   *
   * @generated from field: clarifai.api.Annotation annotation = 4;
   */
  annotation?: Annotation;

  constructor(data?: PartialMessage<And>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.And";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "input", kind: "message", T: Input },
    { no: 2, name: "output", kind: "message", T: Output },
    { no: 3, name: "negate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "annotation", kind: "message", T: Annotation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): And {
    return new And().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): And {
    return new And().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): And {
    return new And().fromJsonString(jsonString, options);
  }

  static equals(a: And | PlainMessage<And> | undefined, b: And | PlainMessage<And> | undefined): boolean {
    return proto3.util.equals(And, a, b);
  }
}

/**
 * AttributeMixIn
 *
 * @generated from message clarifai.api.AttributeMixIn
 */
export class AttributeMixIn extends Message<AttributeMixIn> {
  /**
   * Custom model name to be used in predictor calls
   *
   * @generated from field: string version_id = 1;
   */
  versionId = "";

  /**
   * Coefficient used to weight this term in distance calculations
   *
   * @generated from field: float mix_in_coefficient = 2;
   */
  mixInCoefficient = 0;

  /**
   * @generated from field: clarifai.api.Concept concept_override = 3;
   */
  conceptOverride?: Concept;

  constructor(data?: PartialMessage<AttributeMixIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AttributeMixIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mix_in_coefficient", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "concept_override", kind: "message", T: Concept },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttributeMixIn {
    return new AttributeMixIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttributeMixIn {
    return new AttributeMixIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttributeMixIn {
    return new AttributeMixIn().fromJsonString(jsonString, options);
  }

  static equals(a: AttributeMixIn | PlainMessage<AttributeMixIn> | undefined, b: AttributeMixIn | PlainMessage<AttributeMixIn> | undefined): boolean {
    return proto3.util.equals(AttributeMixIn, a, b);
  }
}

/**
 * AttributeQuery
 *
 * @generated from message clarifai.api.AttributeQuery
 */
export class AttributeQuery extends Message<AttributeQuery> {
  /**
   * Input containing the id/image/url to use as a visual search query
   *
   * @generated from field: clarifai.api.Input input = 1;
   */
  input?: Input;

  /**
   * @generated from field: repeated clarifai.api.AttributeMixIn attribute_mix_in = 2;
   */
  attributeMixIn: AttributeMixIn[] = [];

  constructor(data?: PartialMessage<AttributeQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AttributeQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "input", kind: "message", T: Input },
    { no: 2, name: "attribute_mix_in", kind: "message", T: AttributeMixIn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttributeQuery {
    return new AttributeQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttributeQuery {
    return new AttributeQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttributeQuery {
    return new AttributeQuery().fromJsonString(jsonString, options);
  }

  static equals(a: AttributeQuery | PlainMessage<AttributeQuery> | undefined, b: AttributeQuery | PlainMessage<AttributeQuery> | undefined): boolean {
    return proto3.util.equals(AttributeQuery, a, b);
  }
}

/**
 * This is the search query used in /searches, model training requests, bulk data exports, etc.
 *
 * @generated from message clarifai.api.Query
 */
export class Query extends Message<Query> {
  /**
   * The query syntax is simply a list of And operatiosn that will be ANDed together to fetch
   * results which are returned to the user as Hit messages.
   *
   * @generated from field: repeated clarifai.api.And ands = 1;
   */
  ands: And[] = [];

  /**
   * This allows the query to override any default language the app was setup in when doing Concept
   * based searches. This currently only affects public Models Output searches when those public
   * Models have translations for their Concepts.
   *
   * @generated from field: string language = 2;
   */
  language = "";

  /**
   * filters in this query
   * e.q. only fetch annotations that have certain metadata
   *
   * @generated from field: repeated clarifai.api.Filter filters = 3;
   */
  filters: Filter[] = [];

  /**
   * rankings in this query
   * e.g. visual search by a url
   *
   * @generated from field: repeated clarifai.api.Rank ranks = 4;
   */
  ranks: Rank[] = [];

  constructor(data?: PartialMessage<Query>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Query";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ands", kind: "message", T: And, repeated: true },
    { no: 2, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 4, name: "ranks", kind: "message", T: Rank, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query {
    return new Query().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query {
    return new Query().fromJsonString(jsonString, options);
  }

  static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean {
    return proto3.util.equals(Query, a, b);
  }
}

/**
 * This is the new Search object used in saved searches.
 *
 * @generated from message clarifai.api.Search
 */
export class Search extends Message<Search> {
  /**
   * Search query.
   *
   * @generated from field: clarifai.api.Query query = 1;
   */
  query?: Query;

  /**
   * Customer facing, external ID for search to be saved. Provided by the user, e.g. "saved-search-1.
   * It is unique per application.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * Application that owns this saved search.
   *
   * @generated from field: string application_id = 3;
   */
  applicationId = "";

  /**
   * Human readable display name of the saved search.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * "As of" timestamp, indicating a time in the past as of which we want to
   * retrieve the annotations satisfying the query.
   *
   * @generated from field: google.protobuf.Timestamp as_of = 5;
   */
  asOf?: Timestamp;

  /**
   * Git hash of the code that ran the filter.
   *
   * @generated from field: string git_hash = 6;
   */
  gitHash = "";

  /**
   * When the saved search was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * When the saved search was updated.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 8;
   */
  modifiedAt?: Timestamp;

  /**
   * The search algorithm to be used.
   * Options are are 'nearest_neighbor', 'brute_force', and 'avg_concept_brute_force'
   * The last two perform a brute force search visual search instead of a more scalable distributed
   * nearest neighbor search and should be used by advanced users only.
   * If not specified we default to nearest neighbor
   *
   * @generated from field: string algorithm = 9;
   */
  algorithm = "";

  /**
   * If true, save this search, and exit without executing the search.
   * If false execute the query
   *
   * @generated from field: bool save = 10;
   */
  save = false;

  /**
   * Minimum value of confidence threshold score in result.
   * Defaults to 0.0 which means we won't do any thresholding as all probabilities will
   * likely be > 0.0.
   *
   * @generated from field: float min_value = 11;
   */
  minValue = 0;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 12;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<Search>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Search";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "message", T: Query },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "application_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "as_of", kind: "message", T: Timestamp },
    { no: 6, name: "git_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "modified_at", kind: "message", T: Timestamp },
    { no: 9, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "save", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "min_value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 12, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search {
    return new Search().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search {
    return new Search().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search {
    return new Search().fromJsonString(jsonString, options);
  }

  static equals(a: Search | PlainMessage<Search> | undefined, b: Search | PlainMessage<Search> | undefined): boolean {
    return proto3.util.equals(Search, a, b);
  }
}

/**
 * Filter
 *
 * @generated from message clarifai.api.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
   *
   * @generated from field: bool negate = 3;
   */
  negate = false;

  /**
   * FILTER by annotation information.
   *
   * @generated from field: clarifai.api.Annotation annotation = 4;
   */
  annotation?: Annotation;

  /**
   * FILTER by input information.
   * For example you can filter inputs by status,
   *
   * @generated from field: clarifai.api.Input input = 5;
   */
  input?: Input;

  /**
   * Filter by annotation last updated time range.
   *
   * @generated from field: clarifai.api.TimeRange last_updated_time_range = 6;
   */
  lastUpdatedTimeRange?: TimeRange;

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "negate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "annotation", kind: "message", T: Annotation },
    { no: 5, name: "input", kind: "message", T: Input },
    { no: 6, name: "last_updated_time_range", kind: "message", T: TimeRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * TimeRange
 *
 * @generated from message clarifai.api.TimeRange
 */
export class TimeRange extends Message<TimeRange> {
  /**
   * Begin of the time range, optional, inclusive.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * End of the time range, optional, inclusive.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  constructor(data?: PartialMessage<TimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRange {
    return new TimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: TimeRange | PlainMessage<TimeRange> | undefined, b: TimeRange | PlainMessage<TimeRange> | undefined): boolean {
    return proto3.util.equals(TimeRange, a, b);
  }
}

/**
 * Rank
 *
 * @generated from message clarifai.api.Rank
 */
export class Rank extends Message<Rank> {
  /**
   * If True then this will flip the meaning of this part of the
   * query. This allow for queries such as !dog
   *
   * @generated from field: bool negate = 3;
   */
  negate = false;

  /**
   * RANK by annotation information.
   *
   * @generated from field: clarifai.api.Annotation annotation = 4;
   */
  annotation?: Annotation;

  constructor(data?: PartialMessage<Rank>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Rank";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "negate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "annotation", kind: "message", T: Annotation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rank {
    return new Rank().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rank {
    return new Rank().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rank {
    return new Rank().fromJsonString(jsonString, options);
  }

  static equals(a: Rank | PlainMessage<Rank> | undefined, b: Rank | PlainMessage<Rank> | undefined): boolean {
    return proto3.util.equals(Rank, a, b);
  }
}

/**
 * AnnotationSearchMetrics
 *
 * @generated from message clarifai.api.AnnotationSearchMetrics
 */
export class AnnotationSearchMetrics extends Message<AnnotationSearchMetrics> {
  /**
   * The ground truth we are evaluating against
   *
   * @generated from field: clarifai.api.Search ground_truth = 1;
   */
  groundTruth?: Search;

  /**
   * The set we are evaluating
   *
   * @generated from field: clarifai.api.Search search_to_eval = 2;
   */
  searchToEval?: Search;

  /**
   * The metric result
   *
   * @generated from field: clarifai.api.EvalMetrics metrics = 3;
   */
  metrics?: EvalMetrics;

  /**
   * data is filled out with the concepts used for this evaluation
   *
   * @generated from field: clarifai.api.Data data = 4;
   */
  data?: Data;

  /**
   * active_concept_count is the number of concepts for this evaluation
   *
   * @generated from field: uint32 active_concept_count = 5;
   */
  activeConceptCount = 0;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 6;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<AnnotationSearchMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AnnotationSearchMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ground_truth", kind: "message", T: Search },
    { no: 2, name: "search_to_eval", kind: "message", T: Search },
    { no: 3, name: "metrics", kind: "message", T: EvalMetrics },
    { no: 4, name: "data", kind: "message", T: Data },
    { no: 5, name: "active_concept_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotationSearchMetrics {
    return new AnnotationSearchMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotationSearchMetrics {
    return new AnnotationSearchMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotationSearchMetrics {
    return new AnnotationSearchMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotationSearchMetrics | PlainMessage<AnnotationSearchMetrics> | undefined, b: AnnotationSearchMetrics | PlainMessage<AnnotationSearchMetrics> | undefined): boolean {
    return proto3.util.equals(AnnotationSearchMetrics, a, b);
  }
}

/**
 * Plan
 *
 * @generated from message clarifai.api.Plan
 */
export class Plan extends Message<Plan> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<Plan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Plan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plan {
    return new Plan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plan {
    return new Plan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plan {
    return new Plan().fromJsonString(jsonString, options);
  }

  static equals(a: Plan | PlainMessage<Plan> | undefined, b: Plan | PlainMessage<Plan> | undefined): boolean {
    return proto3.util.equals(Plan, a, b);
  }
}

/**
 * CreditCard
 *
 * @generated from message clarifai.api.CreditCard
 */
export class CreditCard extends Message<CreditCard> {
  /**
   * @generated from field: string number = 1;
   */
  number = "";

  /**
   * @generated from field: string four_digits = 2;
   */
  fourDigits = "";

  /**
   * @generated from field: string exp_month = 3;
   */
  expMonth = "";

  /**
   * @generated from field: string exp_year = 4;
   */
  expYear = "";

  /**
   * @generated from field: string cvc = 5;
   */
  cvc = "";

  /**
   * @generated from field: string name = 6;
   */
  name = "";

  /**
   * @generated from field: string address_line_1 = 7;
   */
  addressLine1 = "";

  /**
   * @generated from field: string address_line_2 = 8;
   */
  addressLine2 = "";

  /**
   * @generated from field: string address_zip = 9;
   */
  addressZip = "";

  /**
   * @generated from field: string address_country = 10;
   */
  addressCountry = "";

  /**
   * @generated from field: string address_city = 11;
   */
  addressCity = "";

  /**
   * @generated from field: string address_state = 12;
   */
  addressState = "";

  /**
   * @generated from field: string id = 13;
   */
  id = "";

  /**
   * @generated from field: string brand = 14;
   */
  brand = "";

  /**
   * @generated from field: string funding = 15;
   */
  funding = "";

  /**
   * @generated from field: bool default = 16;
   */
  default = false;

  /**
   * @generated from field: string cvc_check = 17;
   */
  cvcCheck = "";

  constructor(data?: PartialMessage<CreditCard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.CreditCard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "four_digits", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "exp_month", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "exp_year", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cvc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "address_line_1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "address_line_2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "address_zip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "address_country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "address_city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "address_state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "brand", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "default", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "cvc_check", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreditCard {
    return new CreditCard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreditCard {
    return new CreditCard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreditCard {
    return new CreditCard().fromJsonString(jsonString, options);
  }

  static equals(a: CreditCard | PlainMessage<CreditCard> | undefined, b: CreditCard | PlainMessage<CreditCard> | undefined): boolean {
    return proto3.util.equals(CreditCard, a, b);
  }
}

/**
 * ShippingAddress
 *
 * @generated from message clarifai.api.ShippingAddress
 */
export class ShippingAddress extends Message<ShippingAddress> {
  /**
   * @generated from field: string shipping_address_line_1 = 1;
   */
  shippingAddressLine1 = "";

  /**
   * @generated from field: string shipping_address_line_2 = 2;
   */
  shippingAddressLine2 = "";

  /**
   * @generated from field: string shipping_address_zip = 3;
   */
  shippingAddressZip = "";

  /**
   * @generated from field: string shipping_address_country = 4;
   */
  shippingAddressCountry = "";

  /**
   * @generated from field: string shipping_address_city = 5;
   */
  shippingAddressCity = "";

  /**
   * @generated from field: string shipping_address_state = 6;
   */
  shippingAddressState = "";

  /**
   * @generated from field: string shipping_name = 7;
   */
  shippingName = "";

  constructor(data?: PartialMessage<ShippingAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ShippingAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "shipping_address_line_1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shipping_address_line_2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "shipping_address_zip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "shipping_address_country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "shipping_address_city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "shipping_address_state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "shipping_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShippingAddress {
    return new ShippingAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShippingAddress {
    return new ShippingAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShippingAddress {
    return new ShippingAddress().fromJsonString(jsonString, options);
  }

  static equals(a: ShippingAddress | PlainMessage<ShippingAddress> | undefined, b: ShippingAddress | PlainMessage<ShippingAddress> | undefined): boolean {
    return proto3.util.equals(ShippingAddress, a, b);
  }
}

/**
 * Text
 *
 * @generated from message clarifai.api.Text
 */
export class Text extends Message<Text> {
  /**
   * This is a raw text string.
   *
   * @generated from field: string raw = 1;
   */
  raw = "";

  /**
   * Url to a text file
   *
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: bool allow_duplicate_url = 3;
   */
  allowDuplicateUrl = false;

  /**
   * The hosted field lists original text hosted in Clarifai storage. This field is currently used
   * only in response.
   *
   * @generated from field: clarifai.api.HostedURL hosted = 4;
   */
  hosted?: HostedURL;

  /**
   * text info
   *
   * @generated from field: clarifai.api.TextInfo text_info = 5;
   */
  textInfo?: TextInfo;

  constructor(data?: PartialMessage<Text>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Text";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "raw", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "allow_duplicate_url", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "hosted", kind: "message", T: HostedURL },
    { no: 5, name: "text_info", kind: "message", T: TextInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Text {
    return new Text().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Text {
    return new Text().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Text {
    return new Text().fromJsonString(jsonString, options);
  }

  static equals(a: Text | PlainMessage<Text> | undefined, b: Text | PlainMessage<Text> | undefined): boolean {
    return proto3.util.equals(Text, a, b);
  }
}

/**
 * @generated from message clarifai.api.TextInfo
 */
export class TextInfo extends Message<TextInfo> {
  /**
   * count of characters in text
   *
   * @generated from field: int32 char_count = 1;
   */
  charCount = 0;

  /**
   * text encoding
   *
   * @generated from field: string encoding = 2;
   */
  encoding = "";

  constructor(data?: PartialMessage<TextInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TextInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "char_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "encoding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextInfo {
    return new TextInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextInfo {
    return new TextInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextInfo {
    return new TextInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TextInfo | PlainMessage<TextInfo> | undefined, b: TextInfo | PlainMessage<TextInfo> | undefined): boolean {
    return proto3.util.equals(TextInfo, a, b);
  }
}

/**
 * Op count broken down by date, used for the Billing 2 Historical Usage Endpoint
 *
 * @generated from message clarifai.api.OpCountByDate
 */
export class OpCountByDate extends Message<OpCountByDate> {
  /**
   * date of the usage
   *
   * @generated from field: google.protobuf.Timestamp date = 1;
   */
  date?: Timestamp;

  /**
   * section name of the usage dashboard, including ops-count, training-hours, stored-inputs, data-labeling, model-usage
   *
   * @generated from field: string section = 2;
   */
  section = "";

  /**
   * the operation caller's user-unique-id/primary-email
   *
   * @generated from field: string caller_user_id = 3;
   */
  callerUserId = "";

  /**
   * populated with the application-internal-id when GetHistoricalUsageRequest's broken_down_per_app field is set to true
   * when broken_down_per_app is set to false, this field will be empty
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * @generated from field: string model_id = 5;
   */
  modelId = "";

  /**
   * the id of usage_categories. Each operation is matched with the filter-expressions to usage_categories.
   *
   * @generated from field: string category_id = 6;
   */
  categoryId = "";

  /**
   * operation count, or runtime in seconds if the category is training
   *
   * @generated from field: int32 value = 7;
   */
  value = 0;

  constructor(data?: PartialMessage<OpCountByDate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OpCountByDate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "date", kind: "message", T: Timestamp },
    { no: 2, name: "section", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "caller_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "category_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpCountByDate {
    return new OpCountByDate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpCountByDate {
    return new OpCountByDate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpCountByDate {
    return new OpCountByDate().fromJsonString(jsonString, options);
  }

  static equals(a: OpCountByDate | PlainMessage<OpCountByDate> | undefined, b: OpCountByDate | PlainMessage<OpCountByDate> | undefined): boolean {
    return proto3.util.equals(OpCountByDate, a, b);
  }
}

/**
 * DimensionList
 *
 * @generated from message clarifai.api.DimensionList
 */
export class DimensionList extends Message<DimensionList> {
  /**
   * @generated from field: map<string, string> dimension = 1;
   */
  dimension: { [key: string]: string } = {};

  /**
   * @generated from field: repeated int64 int_value_list = 2;
   */
  intValueList: bigint[] = [];

  /**
   * @generated from field: google.protobuf.Timestamp start_date = 3;
   */
  startDate?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_date = 4;
   */
  endDate?: Timestamp;

  constructor(data?: PartialMessage<DimensionList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DimensionList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dimension", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "int_value_list", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 3, name: "start_date", kind: "message", T: Timestamp },
    { no: 4, name: "end_date", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DimensionList {
    return new DimensionList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DimensionList {
    return new DimensionList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DimensionList {
    return new DimensionList().fromJsonString(jsonString, options);
  }

  static equals(a: DimensionList | PlainMessage<DimensionList> | undefined, b: DimensionList | PlainMessage<DimensionList> | undefined): boolean {
    return proto3.util.equals(DimensionList, a, b);
  }
}

/**
 * UsageInterval
 *
 * @generated from message clarifai.api.UsageInterval
 */
export class UsageInterval extends Message<UsageInterval> {
  /**
   * @generated from field: string interval = 1;
   */
  interval = "";

  /**
   * @generated from field: int32 range = 2;
   */
  range = 0;

  constructor(data?: PartialMessage<UsageInterval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UsageInterval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageInterval {
    return new UsageInterval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageInterval {
    return new UsageInterval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageInterval {
    return new UsageInterval().fromJsonString(jsonString, options);
  }

  static equals(a: UsageInterval | PlainMessage<UsageInterval> | undefined, b: UsageInterval | PlainMessage<UsageInterval> | undefined): boolean {
    return proto3.util.equals(UsageInterval, a, b);
  }
}

/**
 * RealtimeCount
 *
 * @generated from message clarifai.api.RealtimeCount
 */
export class RealtimeCount extends Message<RealtimeCount> {
  /**
   * @generated from field: string op_type = 1;
   */
  opType = "";

  /**
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<RealtimeCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.RealtimeCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RealtimeCount {
    return new RealtimeCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RealtimeCount {
    return new RealtimeCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RealtimeCount {
    return new RealtimeCount().fromJsonString(jsonString, options);
  }

  static equals(a: RealtimeCount | PlainMessage<RealtimeCount> | undefined, b: RealtimeCount | PlainMessage<RealtimeCount> | undefined): boolean {
    return proto3.util.equals(RealtimeCount, a, b);
  }
}

/**
 * EventSummary
 *
 * @generated from message clarifai.api.EventSummary
 */
export class EventSummary extends Message<EventSummary> {
  /**
   * the type of event
   *
   * @generated from field: clarifai.api.APIEventType event_type = 1;
   */
  eventType = APIEventType.API_EVENT_TYPE_NOT_SET;

  /**
   * the model on which the event happens, can be empty
   *
   * @generated from field: clarifai.api.Model model = 2;
   */
  model?: Model;

  /**
   * the number of event
   *
   * @generated from field: uint64 count = 3;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<EventSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EventSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(APIEventType) },
    { no: 2, name: "model", kind: "message", T: Model },
    { no: 3, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSummary {
    return new EventSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSummary {
    return new EventSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSummary {
    return new EventSummary().fromJsonString(jsonString, options);
  }

  static equals(a: EventSummary | PlainMessage<EventSummary> | undefined, b: EventSummary | PlainMessage<EventSummary> | undefined): boolean {
    return proto3.util.equals(EventSummary, a, b);
  }
}

/**
 * EventsCollection
 *
 * @generated from message clarifai.api.EventsCollection
 */
export class EventsCollection extends Message<EventsCollection> {
  /**
   * Begin of the events summary time range
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * End of the events summary time range
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * @generated from field: repeated clarifai.api.EventSummary event_summaries = 3;
   */
  eventSummaries: EventSummary[] = [];

  constructor(data?: PartialMessage<EventsCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EventsCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
    { no: 3, name: "event_summaries", kind: "message", T: EventSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventsCollection {
    return new EventsCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventsCollection {
    return new EventsCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventsCollection {
    return new EventsCollection().fromJsonString(jsonString, options);
  }

  static equals(a: EventsCollection | PlainMessage<EventsCollection> | undefined, b: EventsCollection | PlainMessage<EventsCollection> | undefined): boolean {
    return proto3.util.equals(EventsCollection, a, b);
  }
}

/**
 * User
 *
 * @generated from message clarifai.api.User
 */
export class User extends Message<User> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string primary_email = 2 [deprecated = true];
   * @deprecated
   */
  primaryEmail = "";

  /**
   * @generated from field: string first_name = 3;
   */
  firstName = "";

  /**
   * @generated from field: string last_name = 4;
   */
  lastName = "";

  /**
   * @generated from field: string company_name = 5;
   */
  companyName = "";

  /**
   * @generated from field: string job_title = 19;
   */
  jobTitle = "";

  /**
   * @generated from field: string job_role = 20;
   */
  jobRole = "";

  /**
   * @generated from field: string bill_type = 7 [deprecated = true];
   * @deprecated
   */
  billType = "";

  /**
   * When the user was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_gdpr_consent = 8 [deprecated = true];
   * @deprecated
   */
  dateGdprConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_tos_consent = 9 [deprecated = true];
   * @deprecated
   */
  dateTosConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_marketing_consent = 10 [deprecated = true];
   * @deprecated
   */
  dateMarketingConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_pii_consent = 23 [deprecated = true];
   * @deprecated
   */
  datePiiConsent?: Timestamp;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 11 [deprecated = true];
   * @deprecated
   */
  metadata?: Struct;

  /**
   * @generated from field: repeated clarifai.api.EmailAddress email_addresses = 12 [deprecated = true];
   * @deprecated
   */
  emailAddresses: EmailAddress[] = [];

  /**
   * @generated from field: bool is_org_admin = 14 [deprecated = true];
   * @deprecated
   */
  isOrgAdmin = false;

  /**
   * @generated from field: bool two_factor_auth_enabled = 15 [deprecated = true];
   * @deprecated
   */
  twoFactorAuthEnabled = false;

  /**
   * @generated from field: uint32 teams_count = 16 [deprecated = true];
   * @deprecated
   */
  teamsCount = 0;

  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostUserStars/DeleteUserStars endpoints to star/unstar an user
   *
   * @generated from field: bool is_starred = 21;
   */
  isStarred = false;

  /**
   * How many users have starred the user (only showed on get/list requests)
   * Computed value, not editable
   *
   * @generated from field: int32 star_count = 22;
   */
  starCount = 0;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 17;
   */
  visibility?: Visibility;

  /**
   * This is all the personal information of a user. GetUser/ListUsers will not return this
   * information unless the caller has the UserAccounts_Get scope on their key or is the user
   * themselves.
   *
   * @generated from field: clarifai.api.UserDetail user_detail = 18;
   */
  userDetail?: UserDetail;

  constructor(data?: PartialMessage<User>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.User";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "primary_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "first_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "company_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "job_title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "job_role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "bill_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "date_gdpr_consent", kind: "message", T: Timestamp },
    { no: 9, name: "date_tos_consent", kind: "message", T: Timestamp },
    { no: 10, name: "date_marketing_consent", kind: "message", T: Timestamp },
    { no: 23, name: "date_pii_consent", kind: "message", T: Timestamp },
    { no: 11, name: "metadata", kind: "message", T: Struct },
    { no: 12, name: "email_addresses", kind: "message", T: EmailAddress, repeated: true },
    { no: 14, name: "is_org_admin", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "two_factor_auth_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "teams_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "is_starred", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "star_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 17, name: "visibility", kind: "message", T: Visibility },
    { no: 18, name: "user_detail", kind: "message", T: UserDetail },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
    return new User().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
    return new User().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
    return new User().fromJsonString(jsonString, options);
  }

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
    return proto3.util.equals(User, a, b);
  }
}

/**
 * This message holds the confidential information from the User object that we don't want to expose
 * to other users. It will be accessible only from /users/{user_id}/account and with the User scopes.
 *
 * @generated from message clarifai.api.UserDetail
 */
export class UserDetail extends Message<UserDetail> {
  /**
   * @generated from field: string primary_email = 1;
   */
  primaryEmail = "";

  /**
   * @generated from field: string bill_type = 2;
   */
  billType = "";

  /**
   * @generated from field: google.protobuf.Timestamp date_gdpr_consent = 3;
   */
  dateGdprConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_tos_consent = 4;
   */
  dateTosConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_marketing_consent = 5;
   */
  dateMarketingConsent?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp date_pii_consent = 13;
   */
  datePiiConsent?: Timestamp;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: Struct;

  /**
   * @generated from field: repeated clarifai.api.EmailAddress email_addresses = 7;
   */
  emailAddresses: EmailAddress[] = [];

  /**
   * @generated from field: bool is_org_admin = 8;
   */
  isOrgAdmin = false;

  /**
   * @generated from field: bool two_factor_auth_enabled = 9;
   */
  twoFactorAuthEnabled = false;

  /**
   * @generated from field: uint32 teams_count = 10;
   */
  teamsCount = 0;

  /**
   * @generated from field: string country = 11;
   */
  country = "";

  /**
   * @generated from field: string state = 12;
   */
  state = "";

  constructor(data?: PartialMessage<UserDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bill_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "date_gdpr_consent", kind: "message", T: Timestamp },
    { no: 4, name: "date_tos_consent", kind: "message", T: Timestamp },
    { no: 5, name: "date_marketing_consent", kind: "message", T: Timestamp },
    { no: 13, name: "date_pii_consent", kind: "message", T: Timestamp },
    { no: 6, name: "metadata", kind: "message", T: Struct },
    { no: 7, name: "email_addresses", kind: "message", T: EmailAddress, repeated: true },
    { no: 8, name: "is_org_admin", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "two_factor_auth_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "teams_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDetail {
    return new UserDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDetail {
    return new UserDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDetail {
    return new UserDetail().fromJsonString(jsonString, options);
  }

  static equals(a: UserDetail | PlainMessage<UserDetail> | undefined, b: UserDetail | PlainMessage<UserDetail> | undefined): boolean {
    return proto3.util.equals(UserDetail, a, b);
  }
}

/**
 * EmailAddress
 *
 * @generated from message clarifai.api.EmailAddress
 */
export class EmailAddress extends Message<EmailAddress> {
  /**
   * @generated from field: string email = 1;
   */
  email = "";

  /**
   * @generated from field: bool primary = 2;
   */
  primary = false;

  /**
   * @generated from field: bool verified = 3;
   */
  verified = false;

  constructor(data?: PartialMessage<EmailAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.EmailAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "primary", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmailAddress {
    return new EmailAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmailAddress {
    return new EmailAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmailAddress {
    return new EmailAddress().fromJsonString(jsonString, options);
  }

  static equals(a: EmailAddress | PlainMessage<EmailAddress> | undefined, b: EmailAddress | PlainMessage<EmailAddress> | undefined): boolean {
    return proto3.util.equals(EmailAddress, a, b);
  }
}

/**
 * UserPassword
 *
 * @generated from message clarifai.api.UserPassword
 */
export class UserPassword extends Message<UserPassword> {
  /**
   * Old password to change
   *
   * @generated from field: string old_password = 1;
   */
  oldPassword = "";

  /**
   * New password to update to
   *
   * @generated from field: string password = 2;
   */
  password = "";

  constructor(data?: PartialMessage<UserPassword>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserPassword";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "old_password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPassword {
    return new UserPassword().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPassword {
    return new UserPassword().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPassword {
    return new UserPassword().fromJsonString(jsonString, options);
  }

  static equals(a: UserPassword | PlainMessage<UserPassword> | undefined, b: UserPassword | PlainMessage<UserPassword> | undefined): boolean {
    return proto3.util.equals(UserPassword, a, b);
  }
}

/**
 * UserInfo
 *
 * @generated from message clarifai.api.UserInfo
 */
export class UserInfo extends Message<UserInfo> {
  /**
   * Company name to change to.
   *
   * @generated from field: string company_name = 1;
   */
  companyName = "";

  /**
   * First name to change to.
   *
   * @generated from field: string first_name = 2;
   */
  firstName = "";

  /**
   * Last name to change to.
   *
   * @generated from field: string last_name = 3;
   */
  lastName = "";

  /**
   * User id to change to. If this is set in a PATCH call, no other fields here can be set.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * Organisation admin flag.
   *
   * @generated from oneof clarifai.api.UserInfo.nullable_is_org_admin
   */
  nullableIsOrgAdmin: {
    /**
     * @generated from field: bool is_org_admin = 5;
     */
    value: boolean;
    case: "isOrgAdmin";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 6;
   */
  visibility?: Visibility;

  /**
   * Job title to change to
   *
   * @generated from field: string job_title = 7;
   */
  jobTitle = "";

  /**
   * Job role to change to
   *
   * @generated from field: string job_role = 8;
   */
  jobRole = "";

  /**
   * Country to change to
   *
   * @generated from field: string country = 9;
   */
  country = "";

  /**
   * State to change to
   *
   * @generated from field: string state = 10;
   */
  state = "";

  constructor(data?: PartialMessage<UserInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "company_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "first_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "is_org_admin", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "nullable_is_org_admin" },
    { no: 6, name: "visibility", kind: "message", T: Visibility },
    { no: 7, name: "job_title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "job_role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInfo {
    return new UserInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInfo {
    return new UserInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInfo {
    return new UserInfo().fromJsonString(jsonString, options);
  }

  static equals(a: UserInfo | PlainMessage<UserInfo> | undefined, b: UserInfo | PlainMessage<UserInfo> | undefined): boolean {
    return proto3.util.equals(UserInfo, a, b);
  }
}

/**
 * Password
 *
 * @generated from message clarifai.api.Password
 */
export class Password extends Message<Password> {
  /**
   * unencrypted password string
   *
   * @generated from field: string plaintext = 1;
   */
  plaintext = "";

  constructor(data?: PartialMessage<Password>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Password";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plaintext", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Password {
    return new Password().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Password {
    return new Password().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Password {
    return new Password().fromJsonString(jsonString, options);
  }

  static equals(a: Password | PlainMessage<Password> | undefined, b: Password | PlainMessage<Password> | undefined): boolean {
    return proto3.util.equals(Password, a, b);
  }
}

/**
 * @generated from message clarifai.api.UserAccess
 */
export class UserAccess extends Message<UserAccess> {
  /**
   * @generated from field: string user_id = 1;
   */
  userId = "";

  /**
   * @generated from field: bool v2_portal_requested = 2;
   */
  v2PortalRequested = false;

  /**
   * @generated from field: bool v2_portal_granted = 3;
   */
  v2PortalGranted = false;

  /**
   * @generated from field: string id = 4;
   */
  id = "";

  constructor(data?: PartialMessage<UserAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "v2_portal_requested", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "v2_portal_granted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserAccess {
    return new UserAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserAccess {
    return new UserAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserAccess {
    return new UserAccess().fromJsonString(jsonString, options);
  }

  static equals(a: UserAccess | PlainMessage<UserAccess> | undefined, b: UserAccess | PlainMessage<UserAccess> | undefined): boolean {
    return proto3.util.equals(UserAccess, a, b);
  }
}

/**
 * PasswordPolicy
 *
 * @generated from message clarifai.api.PasswordPolicy
 */
export class PasswordPolicy extends Message<PasswordPolicy> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * either of the two below needs to be filled in
   *
   * @generated from field: string user_id = 2;
   */
  userId = "";

  /**
   * @generated from field: string organization_id = 3;
   */
  organizationId = "";

  /**
   * @generated from field: uint32 minimum_length = 4;
   */
  minimumLength = 0;

  /**
   * @generated from field: uint32 maximum_length = 5;
   */
  maximumLength = 0;

  /**
   * if at least one upper-case character should appear in the password
   *
   * @generated from field: bool upper_case_needed = 6;
   */
  upperCaseNeeded = false;

  /**
   * if at least one lower-case character should appear in the password
   *
   * @generated from field: bool lower_case_needed = 7;
   */
  lowerCaseNeeded = false;

  /**
   * if at least a number should appear in the password
   *
   * @generated from field: bool numeric_needed = 8;
   */
  numericNeeded = false;

  /**
   * if at least a special character should appear in the password
   *
   * @generated from field: bool non_alphanumeric_needed = 9;
   */
  nonAlphanumericNeeded = false;

  /**
   * the duration for which the password will last before it needs to be reset with a new one
   * We use 'day' as the unit of time here
   *
   * @generated from field: uint32 password_life_span_days = 10;
   */
  passwordLifeSpanDays = 0;

  /**
   * when resetting a passwod, we check if the new password has been used before.
   * this epoch is the number of generations of latest password we cannot use again.
   *
   * @generated from field: uint32 password_reuse_epoch = 11;
   */
  passwordReuseEpoch = 0;

  /**
   * if the password should not contain user's first or last names
   *
   * @generated from field: bool exclude_names = 12;
   */
  excludeNames = false;

  /**
   * if the password should not contain the first part of the user's primary email
   *
   * @generated from field: bool exclude_email = 13;
   */
  excludeEmail = false;

  /**
   * if the password should not contain confusing letters such as 0(numeric zero) and o(first character of omega)
   *
   * @generated from field: bool no_confusing_letters = 14;
   */
  noConfusingLetters = false;

  /**
   * if the password should not be as simple as series of numbers (123456...) or same characters (aaaaaa or 222222 etc)
   *
   * @generated from field: bool no_simple_passwords = 15;
   */
  noSimplePasswords = false;

  /**
   * if the password should not contain simple vocabularies like password
   *
   * @generated from field: bool no_common_vocabs = 16;
   */
  noCommonVocabs = false;

  /**
   * if either the old password should not contain the new password or the new password should not contain the old password
   *
   * @generated from field: bool no_overlap_with_old = 17;
   */
  noOverlapWithOld = false;

  constructor(data?: PartialMessage<PasswordPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PasswordPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "organization_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "minimum_length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "maximum_length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "upper_case_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "lower_case_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "numeric_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "non_alphanumeric_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "password_life_span_days", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "password_reuse_epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "exclude_names", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "exclude_email", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "no_confusing_letters", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "no_simple_passwords", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "no_common_vocabs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "no_overlap_with_old", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PasswordPolicy {
    return new PasswordPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PasswordPolicy {
    return new PasswordPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PasswordPolicy {
    return new PasswordPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: PasswordPolicy | PlainMessage<PasswordPolicy> | undefined, b: PasswordPolicy | PlainMessage<PasswordPolicy> | undefined): boolean {
    return proto3.util.equals(PasswordPolicy, a, b);
  }
}

/**
 * PasswordViolations
 *
 * @generated from message clarifai.api.PasswordViolations
 */
export class PasswordViolations extends Message<PasswordViolations> {
  /**
   * when new password length is shorter than minimum length set
   *
   * @generated from field: bool minimum_length = 1;
   */
  minimumLength = false;

  /**
   * when new password length is longer than maximum length set
   *
   * @generated from field: bool maximum_length = 2;
   */
  maximumLength = false;

  /**
   * there is no upper case letter in the new password when there should be at least one
   *
   * @generated from field: bool upper_case_needed = 3;
   */
  upperCaseNeeded = false;

  /**
   * there is no lower case letter in the new password when there should be at least one
   *
   * @generated from field: bool lower_case_needed = 4;
   */
  lowerCaseNeeded = false;

  /**
   * there is no numerics in the new password when there should be at least one
   *
   * @generated from field: bool numeric_needed = 5;
   */
  numericNeeded = false;

  /**
   * there is no special character in the new password when there should be at least one
   *
   * @generated from field: bool non_alphanumeric_needed = 6;
   */
  nonAlphanumericNeeded = false;

  /**
   * when one of the N most recent old password is reused, N is specified by password_reuse_epoch in db.password_policies
   *
   * @generated from field: bool password_reuse = 7;
   */
  passwordReuse = false;

  /**
   * when either user's first, middle or last name is used in the new password
   *
   * @generated from field: bool exclude_names = 8;
   */
  excludeNames = false;

  /**
   * when first part of user's email (exact string or after removing special characters) is used in the new password
   *
   * @generated from field: bool exclude_email = 9;
   */
  excludeEmail = false;

  /**
   * when there are confusing letters in the new password, such as o (first character of 'omega') vs 0 (zero)
   *
   * @generated from field: bool no_confusing_letters = 10;
   */
  noConfusingLetters = false;

  /**
   * when there are simple password patterns used, such as 12345678 or aaaaaaa1
   *
   * @generated from field: bool no_simple_passwords = 11;
   */
  noSimplePasswords = false;

  /**
   * when there are common vocabs from the common vocab list used
   *
   * @generated from field: bool no_common_vocabs = 12;
   */
  noCommonVocabs = false;

  /**
   * when the current password is contained in the new password or vice versa
   *
   * @generated from field: bool no_overlap_with_old = 13;
   */
  noOverlapWithOld = false;

  /**
   * when password has to be changed becauase it's too old
   *
   * @generated from field: bool password_lifespan = 14;
   */
  passwordLifespan = false;

  constructor(data?: PartialMessage<PasswordViolations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PasswordViolations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "minimum_length", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "maximum_length", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "upper_case_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "lower_case_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "numeric_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "non_alphanumeric_needed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "password_reuse", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "exclude_names", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "exclude_email", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "no_confusing_letters", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "no_simple_passwords", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "no_common_vocabs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "no_overlap_with_old", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "password_lifespan", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PasswordViolations {
    return new PasswordViolations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PasswordViolations {
    return new PasswordViolations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PasswordViolations {
    return new PasswordViolations().fromJsonString(jsonString, options);
  }

  static equals(a: PasswordViolations | PlainMessage<PasswordViolations> | undefined, b: PasswordViolations | PlainMessage<PasswordViolations> | undefined): boolean {
    return proto3.util.equals(PasswordViolations, a, b);
  }
}

/**
 * Video
 *
 * @generated from message clarifai.api.Video
 */
export class Video extends Message<Video> {
  /**
   * This is a URL to a publicly accessible video file. The platform will download this file server
   * side and then process.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * The base64 field is using video file bytes directly in the request.
   * NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
   * the name here).
   * When using our grpc clients, you DO NOT need to base64 encode
   * it yourself since the clients know how to do this for you automatically and will avoid the
   * base64 encoding if they send a binary request.
   *
   * @generated from field: bytes base64 = 2;
   */
  base64 = new Uint8Array(0);

  /**
   * @generated from field: bool allow_duplicate_url = 4;
   */
  allowDuplicateUrl = false;

  /**
   * URL of thumbnail image, which is currently frame at position of 1s. This field is currently
   * used only in response.
   *
   * @generated from field: string thumbnail_url = 5;
   */
  thumbnailUrl = "";

  /**
   * The hosted field lists original video hosted in Clarifai storage. This field is currently used
   * only in response.
   *
   * @generated from field: clarifai.api.HostedURL hosted = 6;
   */
  hosted?: HostedURL;

  /**
   * video info
   *
   * @generated from field: clarifai.api.VideoInfo video_info = 7;
   */
  videoInfo?: VideoInfo;

  constructor(data?: PartialMessage<Video>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Video";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base64", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "allow_duplicate_url", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "thumbnail_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "hosted", kind: "message", T: HostedURL },
    { no: 7, name: "video_info", kind: "message", T: VideoInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Video {
    return new Video().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Video {
    return new Video().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Video {
    return new Video().fromJsonString(jsonString, options);
  }

  static equals(a: Video | PlainMessage<Video> | undefined, b: Video | PlainMessage<Video> | undefined): boolean {
    return proto3.util.equals(Video, a, b);
  }
}

/**
 * @generated from message clarifai.api.VideoInfo
 */
export class VideoInfo extends Message<VideoInfo> {
  /**
   * width
   *
   * @generated from field: int32 width = 1;
   */
  width = 0;

  /**
   * height
   *
   * @generated from field: int32 height = 2;
   */
  height = 0;

  /**
   * Frames per second of the video.
   *
   * @generated from field: float fps = 3;
   */
  fps = 0;

  /**
   * video format
   *
   * @generated from field: string video_format = 4;
   */
  videoFormat = "";

  /**
   * video track bit rate
   *
   * @generated from field: int32 bit_rate = 5;
   */
  bitRate = 0;

  /**
   * video frame count
   *
   * @generated from field: int32 frame_count = 6;
   */
  frameCount = 0;

  /**
   * video duration in seconds
   *
   * @generated from field: float duration_seconds = 7;
   */
  durationSeconds = 0;

  constructor(data?: PartialMessage<VideoInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.VideoInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "width", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "fps", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "video_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "bit_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "frame_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "duration_seconds", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VideoInfo {
    return new VideoInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VideoInfo {
    return new VideoInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VideoInfo {
    return new VideoInfo().fromJsonString(jsonString, options);
  }

  static equals(a: VideoInfo | PlainMessage<VideoInfo> | undefined, b: VideoInfo | PlainMessage<VideoInfo> | undefined): boolean {
    return proto3.util.equals(VideoInfo, a, b);
  }
}

/**
 * This represents a vocabulary which is an ordered list of concepts
 *
 * @generated from message clarifai.api.Vocab
 */
export class Vocab extends Message<Vocab> {
  /**
   * This is user unique id for the vocabulary.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * A nice display name for the vocabulary.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * A description of what this vocab is for.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The application id that this vocab belongs to.
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * When the object was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 6;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<Vocab>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Vocab";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vocab {
    return new Vocab().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vocab {
    return new Vocab().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vocab {
    return new Vocab().fromJsonString(jsonString, options);
  }

  static equals(a: Vocab | PlainMessage<Vocab> | undefined, b: Vocab | PlainMessage<Vocab> | undefined): boolean {
    return proto3.util.equals(Vocab, a, b);
  }
}

/**
 * Workflow
 *
 * @generated from message clarifai.api.Workflow
 */
export class Workflow extends Message<Workflow> {
  /**
   * The workflows's unique id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The app the workflow belongs to
   *
   * @generated from field: string app_id = 2;
   */
  appId = "";

  /**
   * When the workflow was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * The list of nodes retrieved from latest workflow version.
   * Each node can specify an input node that it connects to in order to define the graph.
   *
   * @generated from field: repeated clarifai.api.WorkflowNode nodes = 4;
   */
  nodes: WorkflowNode[] = [];

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: Struct;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 6;
   */
  visibility?: Visibility;

  /**
   * The user the workflow belongs to
   *
   * @generated from field: string user_id = 7;
   */
  userId = "";

  /**
   * When the workflow was last modified
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 8;
   */
  modifiedAt?: Timestamp;

  /**
   * Info about the workflow version
   *
   * @generated from field: clarifai.api.WorkflowVersion version = 9;
   */
  version?: WorkflowVersion;

  /**
   * Is starred by the requesting user (only showed on get/list requests)
   * Please use PostWorkflowStars/DeleteWorkflowStars endpoints to star/unstar a workflow
   *
   * @generated from field: bool is_starred = 10;
   */
  isStarred = false;

  /**
   * How many users have starred the workflow (only showed on get/list requests)
   * Computed value, not editable
   *
   * @generated from field: int32 star_count = 11;
   */
  starCount = 0;

  /**
   * Short description about this workflow
   *
   * @generated from field: string description = 12;
   */
  description = "";

  /**
   * Notes for the workflow
   * This field should be used for in-depth notes and supports up to 64Kbs.
   *
   * @generated from field: string notes = 13;
   */
  notes = "";

  /**
   * Tags from use_cases category
   *
   * @generated from field: repeated string use_cases = 14;
   */
  useCases: string[] = [];

  /**
   * Tags for check consents
   *
   * @generated from field: repeated string check_consents = 15;
   */
  checkConsents: string[] = [];

  constructor(data?: PartialMessage<Workflow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Workflow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "nodes", kind: "message", T: WorkflowNode, repeated: true },
    { no: 5, name: "metadata", kind: "message", T: Struct },
    { no: 6, name: "visibility", kind: "message", T: Visibility },
    { no: 7, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "modified_at", kind: "message", T: Timestamp },
    { no: 9, name: "version", kind: "message", T: WorkflowVersion },
    { no: 10, name: "is_starred", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "star_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 12, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "use_cases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "check_consents", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Workflow {
    return new Workflow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Workflow {
    return new Workflow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Workflow {
    return new Workflow().fromJsonString(jsonString, options);
  }

  static equals(a: Workflow | PlainMessage<Workflow> | undefined, b: Workflow | PlainMessage<Workflow> | undefined): boolean {
    return proto3.util.equals(Workflow, a, b);
  }
}

/**
 * WorkflowVersion
 *
 * @generated from message clarifai.api.WorkflowVersion
 */
export class WorkflowVersion extends Message<WorkflowVersion> {
  /**
   * Id of this version.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Workflow id for this version.
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * When the version was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the version was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 4;
   */
  modifiedAt?: Timestamp;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 5;
   */
  visibility?: Visibility;

  /**
   * The list of nodes that make up the workflow version. Each node can specify an input node
   * that it connects to in order to define the graph.
   *
   * @generated from field: repeated clarifai.api.WorkflowNode nodes = 6;
   */
  nodes: WorkflowNode[] = [];

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 7;
   */
  metadata?: Struct;

  /**
   * The app the workflow version belongs to.
   *
   * @generated from field: string app_id = 8;
   */
  appId = "";

  /**
   * The user the workflow version belongs to.
   *
   * @generated from field: string user_id = 9;
   */
  userId = "";

  /**
   * Short description about this workflow version
   *
   * @generated from field: string description = 10;
   */
  description = "";

  /**
   * License associated to this workflow version
   *
   * @generated from field: string license = 11;
   */
  license = "";

  constructor(data?: PartialMessage<WorkflowVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "modified_at", kind: "message", T: Timestamp },
    { no: 5, name: "visibility", kind: "message", T: Visibility },
    { no: 6, name: "nodes", kind: "message", T: WorkflowNode, repeated: true },
    { no: 7, name: "metadata", kind: "message", T: Struct },
    { no: 8, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "license", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowVersion {
    return new WorkflowVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowVersion {
    return new WorkflowVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowVersion {
    return new WorkflowVersion().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowVersion | PlainMessage<WorkflowVersion> | undefined, b: WorkflowVersion | PlainMessage<WorkflowVersion> | undefined): boolean {
    return proto3.util.equals(WorkflowVersion, a, b);
  }
}

/**
 * WorkflowNode
 *
 * @generated from message clarifai.api.WorkflowNode
 */
export class WorkflowNode extends Message<WorkflowNode> {
  /**
   * An identifier for this node in the graph. This is used when connecting NodeInputs
   * together.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The model that will do the processing at this node. We only vlidate the model.id and
   * model.model_version.id fields.
   *
   * @generated from field: clarifai.api.Model model = 2;
   */
  model?: Model;

  /**
   * Each WorkflowNode can connect to multiple input nodes so that we can handle multi-model data
   * and more complex workflow operations.
   *
   * @generated from field: repeated clarifai.api.NodeInput node_inputs = 3;
   */
  nodeInputs: NodeInput[] = [];

  /**
   * suppress the output for workflow prediction
   *
   * @generated from field: bool suppress_output = 4;
   */
  suppressOutput = false;

  constructor(data?: PartialMessage<WorkflowNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model", kind: "message", T: Model },
    { no: 3, name: "node_inputs", kind: "message", T: NodeInput, repeated: true },
    { no: 4, name: "suppress_output", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowNode {
    return new WorkflowNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowNode {
    return new WorkflowNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowNode {
    return new WorkflowNode().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowNode | PlainMessage<WorkflowNode> | undefined, b: WorkflowNode | PlainMessage<WorkflowNode> | undefined): boolean {
    return proto3.util.equals(WorkflowNode, a, b);
  }
}

/**
 * NodeInput represents inputs to a node of the graph.
 *
 * @generated from message clarifai.api.NodeInput
 */
export class NodeInput extends Message<NodeInput> {
  /**
   * The id to a connected WorkflowNode which will be used as an input for current WorkflowNode.
   *
   * @generated from field: string node_id = 1;
   */
  nodeId = "";

  constructor(data?: PartialMessage<NodeInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.NodeInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeInput {
    return new NodeInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeInput {
    return new NodeInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeInput {
    return new NodeInput().fromJsonString(jsonString, options);
  }

  static equals(a: NodeInput | PlainMessage<NodeInput> | undefined, b: NodeInput | PlainMessage<NodeInput> | undefined): boolean {
    return proto3.util.equals(NodeInput, a, b);
  }
}

/**
 * WorkflowResult
 *
 * @generated from message clarifai.api.WorkflowResult
 */
export class WorkflowResult extends Message<WorkflowResult> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: clarifai.api.status.Status status = 2;
   */
  status?: Status;

  /**
   * When the object was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: clarifai.api.Model model = 4;
   */
  model?: Model;

  /**
   * @generated from field: clarifai.api.Input input = 5;
   */
  input?: Input;

  /**
   * @generated from field: repeated clarifai.api.Output outputs = 6;
   */
  outputs: Output[] = [];

  /**
   * Indicate if the output of this model is suppressed.
   *
   * @generated from field: bool suppress_output = 7;
   */
  suppressOutput = false;

  constructor(data?: PartialMessage<WorkflowResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "message", T: Status },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "model", kind: "message", T: Model },
    { no: 5, name: "input", kind: "message", T: Input },
    { no: 6, name: "outputs", kind: "message", T: Output, repeated: true },
    { no: 7, name: "suppress_output", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowResult {
    return new WorkflowResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowResult {
    return new WorkflowResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowResult {
    return new WorkflowResult().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowResult | PlainMessage<WorkflowResult> | undefined, b: WorkflowResult | PlainMessage<WorkflowResult> | undefined): boolean {
    return proto3.util.equals(WorkflowResult, a, b);
  }
}

/**
 * WorkflowMetrics
 *
 * @generated from message clarifai.api.WorkflowMetrics
 */
export class WorkflowMetrics extends Message<WorkflowMetrics> {
  /**
   * Id of this evaluation.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Workflow id for this evaluation.
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * When the metric was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the metric was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 4;
   */
  modifiedAt?: Timestamp;

  /**
   * Workflow evaluation status.
   *
   * @generated from field: clarifai.api.status.Status status = 5;
   */
  status?: Status;

  /**
   * data is filled out with the concepts used for this evaluation
   *
   * @generated from field: clarifai.api.Data data = 6;
   */
  data?: Data;

  /**
   * Node metrics for this evaluation.
   * Key: node id
   * Value: metrics for node evaluation
   *
   * @generated from field: map<string, clarifai.api.EvalMetrics> node_metrics = 7;
   */
  nodeMetrics: { [key: string]: EvalMetrics } = {};

  /**
   * The ground truth we are evaluating against
   *
   * @generated from field: clarifai.api.Search ground_truth = 8;
   */
  groundTruth?: Search;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 9;
   */
  visibility?: Visibility;

  constructor(data?: PartialMessage<WorkflowMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "modified_at", kind: "message", T: Timestamp },
    { no: 5, name: "status", kind: "message", T: Status },
    { no: 6, name: "data", kind: "message", T: Data },
    { no: 7, name: "node_metrics", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: EvalMetrics} },
    { no: 8, name: "ground_truth", kind: "message", T: Search },
    { no: 9, name: "visibility", kind: "message", T: Visibility },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowMetrics {
    return new WorkflowMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowMetrics {
    return new WorkflowMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowMetrics {
    return new WorkflowMetrics().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowMetrics | PlainMessage<WorkflowMetrics> | undefined, b: WorkflowMetrics | PlainMessage<WorkflowMetrics> | undefined): boolean {
    return proto3.util.equals(WorkflowMetrics, a, b);
  }
}

/**
 * WorkflowState
 *
 * @generated from message clarifai.api.WorkflowState
 */
export class WorkflowState extends Message<WorkflowState> {
  /**
   * A unique ID for the workflow state.
   * To start saving a state in a PostWorkflowResults request set this ID to "init"
   * and it will return a newly generated unique state id that you can then pass in subsequent
   * PostWorkflowResults calls. These state expire after 5 minutes between calls.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<WorkflowState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowState {
    return new WorkflowState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowState {
    return new WorkflowState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowState {
    return new WorkflowState().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowState | PlainMessage<WorkflowState> | undefined, b: WorkflowState | PlainMessage<WorkflowState> | undefined): boolean {
    return proto3.util.equals(WorkflowState, a, b);
  }
}

/**
 * AppDuplication
 *
 * @generated from message clarifai.api.AppDuplication
 */
export class AppDuplication extends Message<AppDuplication> {
  /**
   * the id of app duplication
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * the id of new app. If provided, we will create a new application with this id. If the app id exists, we will return err.
   * if new_app_name is empty, the name will be the same as this id.
   * You can not set this if existing_app_id is set.
   *
   * @generated from field: string new_app_id = 2;
   */
  newAppId = "";

  /**
   * the name of new app. If provided, we will create a new application with this name.
   * You can not set this if existing_app_id is set.
   *
   * @generated from field: string new_app_name = 3;
   */
  newAppName = "";

  /**
   * the status of app duplication
   *
   * @generated from field: clarifai.api.status.Status status = 4;
   */
  status?: Status;

  /**
   * when is the app duplication triggered
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * The last time when is the status got updated
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 6;
   */
  lastModifiedAt?: Timestamp;

  /**
   * Only copy resources depending on the filters
   *
   * @generated from field: clarifai.api.AppDuplicationFilters filter = 7;
   */
  filter?: AppDuplicationFilters;

  /**
   * the id of existing app you want to copy data into.
   * you can not set this if either new_app_id or new_app_name is set.
   * if new_app_id, new_app_name and existing_app_id are all empty, we will create a new app with random app id/name
   *
   * @generated from field: string existing_app_id = 8;
   */
  existingAppId = "";

  /**
   * contains progress for each requested filter
   *
   * @generated from field: repeated clarifai.api.AppCopyProgress progress = 9;
   */
  progress: AppCopyProgress[] = [];

  constructor(data?: PartialMessage<AppDuplication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AppDuplication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "new_app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "new_app_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "message", T: Status },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "last_modified_at", kind: "message", T: Timestamp },
    { no: 7, name: "filter", kind: "message", T: AppDuplicationFilters },
    { no: 8, name: "existing_app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "progress", kind: "message", T: AppCopyProgress, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDuplication {
    return new AppDuplication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDuplication {
    return new AppDuplication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDuplication {
    return new AppDuplication().fromJsonString(jsonString, options);
  }

  static equals(a: AppDuplication | PlainMessage<AppDuplication> | undefined, b: AppDuplication | PlainMessage<AppDuplication> | undefined): boolean {
    return proto3.util.equals(AppDuplication, a, b);
  }
}

/**
 * @generated from message clarifai.api.AppCopyProgress
 */
export class AppCopyProgress extends Message<AppCopyProgress> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: int32 value = 2;
   */
  value = 0;

  constructor(data?: PartialMessage<AppCopyProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AppCopyProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppCopyProgress {
    return new AppCopyProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppCopyProgress {
    return new AppCopyProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppCopyProgress {
    return new AppCopyProgress().fromJsonString(jsonString, options);
  }

  static equals(a: AppCopyProgress | PlainMessage<AppCopyProgress> | undefined, b: AppCopyProgress | PlainMessage<AppCopyProgress> | undefined): boolean {
    return proto3.util.equals(AppCopyProgress, a, b);
  }
}

/**
 * AppDuplicationFilters
 *
 * @generated from message clarifai.api.AppDuplicationFilters
 */
export class AppDuplicationFilters extends Message<AppDuplicationFilters> {
  /**
   * Copy inputs what what it depends on: input level annotation and concepts
   *
   * @generated from field: bool copy_inputs = 1;
   */
  copyInputs = false;

  /**
   * Copy only concepts
   *
   * @generated from field: bool copy_concepts = 2;
   */
  copyConcepts = false;

  /**
   * Copy annotations and what it depends on: inputs and concepts
   *
   * @generated from field: bool copy_annotations = 3;
   */
  copyAnnotations = false;

  /**
   * Copy models and what it depends on: concepts
   *
   * @generated from field: bool copy_models = 4;
   */
  copyModels = false;

  /**
   * Copy workflows and what it depends on: models and concepts
   *
   * @generated from field: bool copy_workflows = 5;
   */
  copyWorkflows = false;

  constructor(data?: PartialMessage<AppDuplicationFilters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AppDuplicationFilters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "copy_inputs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "copy_concepts", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "copy_annotations", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "copy_models", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "copy_workflows", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDuplicationFilters {
    return new AppDuplicationFilters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDuplicationFilters {
    return new AppDuplicationFilters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDuplicationFilters {
    return new AppDuplicationFilters().fromJsonString(jsonString, options);
  }

  static equals(a: AppDuplicationFilters | PlainMessage<AppDuplicationFilters> | undefined, b: AppDuplicationFilters | PlainMessage<AppDuplicationFilters> | undefined): boolean {
    return proto3.util.equals(AppDuplicationFilters, a, b);
  }
}

/**
 * LabelOrder
 *
 * @generated from message clarifai.api.LabelOrder
 */
export class LabelOrder extends Message<LabelOrder> {
  /**
   * id of the order
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * name of the order
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * status of the order.
   * pending (QA lead review the order),
   * in progress (labeling in progress),
   * ready for release (passed clarifai QA and client can review)
   * success (released)
   *
   * @generated from field: clarifai.api.status.Status status = 3;
   */
  status?: Status;

  /**
   * if set to true, automatically release the labels once passed clarifai review.
   *
   * @generated from field: bool auto_release = 4;
   */
  autoRelease = false;

  /**
   * allow input without any tag.
   *
   * @generated from field: bool allow_empty_tag = 5;
   */
  allowEmptyTag = false;

  /**
   * User desired estimation when the task should be done
   *
   * @generated from field: google.protobuf.Timestamp desired_fulfill_time = 6;
   */
  desiredFulfillTime?: Timestamp;

  /**
   * Clarifai estimation when the task should be done .
   *
   * @generated from field: google.protobuf.Timestamp estimate_fulfill_time = 7;
   */
  estimateFulfillTime?: Timestamp;

  /**
   * task for this label order
   *
   * @generated from field: clarifai.api.Task task = 8;
   */
  task?: Task;

  /**
   * When the label order was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 9;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the label order was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 10;
   */
  modifiedAt?: Timestamp;

  constructor(data?: PartialMessage<LabelOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.LabelOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "status", kind: "message", T: Status },
    { no: 4, name: "auto_release", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "allow_empty_tag", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "desired_fulfill_time", kind: "message", T: Timestamp },
    { no: 7, name: "estimate_fulfill_time", kind: "message", T: Timestamp },
    { no: 8, name: "task", kind: "message", T: Task },
    { no: 9, name: "created_at", kind: "message", T: Timestamp },
    { no: 10, name: "modified_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelOrder {
    return new LabelOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelOrder {
    return new LabelOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelOrder {
    return new LabelOrder().fromJsonString(jsonString, options);
  }

  static equals(a: LabelOrder | PlainMessage<LabelOrder> | undefined, b: LabelOrder | PlainMessage<LabelOrder> | undefined): boolean {
    return proto3.util.equals(LabelOrder, a, b);
  }
}

/**
 * Task is the work that needs to be done for labeling the inputs in an app.
 *
 * @generated from message clarifai.api.Task
 */
export class Task extends Message<Task> {
  /**
   * Unique ID for the task.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the task was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the task was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * Task type.
   *
   * @generated from field: clarifai.api.Task.TaskType type = 4;
   */
  type = Task_TaskType.TYPE_NOT_SET;

  /**
   * Description of the task.
   *
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * Worker details.
   *
   * @generated from field: clarifai.api.TaskWorker worker = 6;
   */
  worker?: TaskWorker;

  /**
   * List of concept ids used in the work of this task if label type is classification.
   *
   * @generated from field: repeated string concept_ids = 7;
   */
  conceptIds: string[] = [];

  /**
   * List of inputs used in this task will be taken from this source.
   *
   * @generated from field: clarifai.api.TaskInputSource input_source = 8;
   */
  inputSource?: TaskInputSource;

  /**
   * For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
   *
   * @generated from field: uint32 sample_ms = 9;
   */
  sampleMs = 0;

  /**
   * AI assistant details.
   *
   * @generated from field: clarifai.api.TaskAIAssistant ai_assistant = 10;
   */
  aiAssistant?: TaskAIAssistant;

  /**
   * Review details.
   *
   * @generated from field: clarifai.api.TaskReview review = 11;
   */
  review?: TaskReview;

  /**
   * Status of this task.
   *
   * @generated from field: clarifai.api.status.Status status = 12;
   */
  status?: Status;

  /**
   * Add a title for this task to quickly recognise it in a list of tasks.
   *
   * @generated from field: string name = 13;
   */
  name = "";

  /**
   * @generated from field: clarifai.api.AiAssistParameters ai_assist_params = 14;
   */
  aiAssistParams?: AiAssistParameters;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   *
   * @generated from field: clarifai.api.Visibility visibility = 15;
   */
  visibility?: Visibility;

  /**
   * The app the task belongs to.
   *
   * @generated from field: string app_id = 16;
   */
  appId = "";

  /**
   * The user the task belongs to.
   *
   * @generated from field: string user_id = 17;
   */
  userId = "";

  /**
   * The label order the task belongs to.
   *
   * @generated from field: string label_order_id = 18;
   */
  labelOrderId = "";

  constructor(data?: PartialMessage<Task>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Task";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(Task_TaskType) },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "worker", kind: "message", T: TaskWorker },
    { no: 7, name: "concept_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "input_source", kind: "message", T: TaskInputSource },
    { no: 9, name: "sample_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "ai_assistant", kind: "message", T: TaskAIAssistant },
    { no: 11, name: "review", kind: "message", T: TaskReview },
    { no: 12, name: "status", kind: "message", T: Status },
    { no: 13, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "ai_assist_params", kind: "message", T: AiAssistParameters },
    { no: 15, name: "visibility", kind: "message", T: Visibility },
    { no: 16, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "label_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Task {
    return new Task().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJsonString(jsonString, options);
  }

  static equals(a: Task | PlainMessage<Task> | undefined, b: Task | PlainMessage<Task> | undefined): boolean {
    return proto3.util.equals(Task, a, b);
  }
}

/**
 * @generated from enum clarifai.api.Task.TaskType
 */
export enum Task_TaskType {
  /**
   * @generated from enum value: TYPE_NOT_SET = 0;
   */
  TYPE_NOT_SET = 0,

  /**
   * Concepts classification tasks annotate concepts for the overall image, frame of video or section of text.
   *
   * @generated from enum value: CONCEPTS_CLASSIFICATION = 1;
   */
  CONCEPTS_CLASSIFICATION = 1,

  /**
   * Bounding box detection tasks annotate rectangular bounding box regions around each concept in an image, frame of video or section of text.
   *
   * @generated from enum value: BOUNDING_BOX_DETECTION = 2;
   */
  BOUNDING_BOX_DETECTION = 2,

  /**
   * Polygon detection tasks annotate free-form regions around concepts in an image, frame of video or section of text.
   *
   * @generated from enum value: POLYGON_DETECTION = 3;
   */
  POLYGON_DETECTION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Task_TaskType)
proto3.util.setEnumType(Task_TaskType, "clarifai.api.Task.TaskType", [
  { no: 0, name: "TYPE_NOT_SET" },
  { no: 1, name: "CONCEPTS_CLASSIFICATION" },
  { no: 2, name: "BOUNDING_BOX_DETECTION" },
  { no: 3, name: "POLYGON_DETECTION" },
]);

/**
 * AiAssistParameters
 *
 * @generated from message clarifai.api.AiAssistParameters
 */
export class AiAssistParameters extends Message<AiAssistParameters> {
  /**
   * Min and max threshold values for approving annotations by default based on prediction score
   *
   * @generated from field: float min_threshold = 1;
   */
  minThreshold = 0;

  /**
   * @generated from field: float max_threshold = 2;
   */
  maxThreshold = 0;

  /**
   * ids of concept relations. Used in AI assist workflow
   *
   * @generated from field: repeated string concept_relation_ids = 3;
   */
  conceptRelationIds: string[] = [];

  constructor(data?: PartialMessage<AiAssistParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AiAssistParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "concept_relation_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiAssistParameters {
    return new AiAssistParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiAssistParameters {
    return new AiAssistParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiAssistParameters {
    return new AiAssistParameters().fromJsonString(jsonString, options);
  }

  static equals(a: AiAssistParameters | PlainMessage<AiAssistParameters> | undefined, b: AiAssistParameters | PlainMessage<AiAssistParameters> | undefined): boolean {
    return proto3.util.equals(AiAssistParameters, a, b);
  }
}

/**
 * TaskWorker
 *
 * @generated from message clarifai.api.TaskWorker
 */
export class TaskWorker extends Message<TaskWorker> {
  /**
   * Worker strategy.
   *
   * @generated from field: clarifai.api.TaskWorker.TaskWorkerStrategy strategy = 1;
   */
  strategy = TaskWorker_TaskWorkerStrategy.WORKER_STRATEGY_NOT_SET;

  /**
   * Who will work on this task.
   * DEPRECATED: Use users.id instead.
   *
   * @generated from field: repeated string user_ids = 2 [deprecated = true];
   * @deprecated
   */
  userIds: string[] = [];

  /**
   * Users who will work on this task.
   * When the 'worker.users' field is additionally requested, then all user
   * info is filled for the workers. Otherwise, only the user 'id' is filled.
   *
   * @generated from field: repeated clarifai.api.User users = 4;
   */
  users: User[] = [];

  /**
   * Info based on the worker strategy,
   *
   * @generated from oneof clarifai.api.TaskWorker.strategy_info
   */
  strategyInfo: {
    /**
     * @generated from field: clarifai.api.TaskWorkerPartitionedStrategyInfo partitioned_strategy_info = 3;
     */
    value: TaskWorkerPartitionedStrategyInfo;
    case: "partitionedStrategyInfo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TaskWorker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskWorker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "strategy", kind: "enum", T: proto3.getEnumType(TaskWorker_TaskWorkerStrategy) },
    { no: 2, name: "user_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "users", kind: "message", T: User, repeated: true },
    { no: 3, name: "partitioned_strategy_info", kind: "message", T: TaskWorkerPartitionedStrategyInfo, oneof: "strategy_info" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskWorker {
    return new TaskWorker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskWorker {
    return new TaskWorker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskWorker {
    return new TaskWorker().fromJsonString(jsonString, options);
  }

  static equals(a: TaskWorker | PlainMessage<TaskWorker> | undefined, b: TaskWorker | PlainMessage<TaskWorker> | undefined): boolean {
    return proto3.util.equals(TaskWorker, a, b);
  }
}

/**
 * @generated from enum clarifai.api.TaskWorker.TaskWorkerStrategy
 */
export enum TaskWorker_TaskWorkerStrategy {
  /**
   * @generated from enum value: WORKER_STRATEGY_NOT_SET = 0;
   */
  WORKER_STRATEGY_NOT_SET = 0,

  /**
   * The inputs will be partitioned in several partitions.
   * Each worker will label one or more input partitions.
   *
   * @generated from enum value: PARTITIONED = 2;
   */
  PARTITIONED = 2,

  /**
   * Each worker will label all inputs from input source.
   *
   * @generated from enum value: FULL = 3;
   */
  FULL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskWorker_TaskWorkerStrategy)
proto3.util.setEnumType(TaskWorker_TaskWorkerStrategy, "clarifai.api.TaskWorker.TaskWorkerStrategy", [
  { no: 0, name: "WORKER_STRATEGY_NOT_SET" },
  { no: 2, name: "PARTITIONED" },
  { no: 3, name: "FULL" },
]);

/**
 * TaskWorkerPartitionedStrategyInfo
 *
 * @generated from message clarifai.api.TaskWorkerPartitionedStrategyInfo
 */
export class TaskWorkerPartitionedStrategyInfo extends Message<TaskWorkerPartitionedStrategyInfo> {
  /**
   * Define how the partitioning should work.
   *
   * @generated from field: clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;
   */
  type = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy.PARTITIONED_WORKER_STRATEGY_NOT_SET;

  /**
   * How many workers will label each input.
   *
   * @generated from field: int32 workers_per_input = 2;
   */
  workersPerInput = 0;

  /**
   * In case of weighted partitioning, map user ids to weights.
   * Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
   * 
   * EXAMPLE:
   * If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
   * then first worker will have assigned 30% of the work,
   * second worker will have assigned 30% of the work,
   * and third worker will have assigned 40% of the work.
   * You may use weights which add up to 100, but it's not necessary.
   * For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
   * because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
   * 
   * NOTE:
   * Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
   * It is mathematically impossible to partition the work in such a case.
   * Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
   * Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
   * Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
   * If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
   * Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
   * No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
   * This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
   *
   * @generated from field: google.protobuf.Struct weights = 3;
   */
  weights?: Struct;

  constructor(data?: PartialMessage<TaskWorkerPartitionedStrategyInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskWorkerPartitionedStrategyInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy) },
    { no: 2, name: "workers_per_input", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "weights", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskWorkerPartitionedStrategyInfo {
    return new TaskWorkerPartitionedStrategyInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskWorkerPartitionedStrategyInfo {
    return new TaskWorkerPartitionedStrategyInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskWorkerPartitionedStrategyInfo {
    return new TaskWorkerPartitionedStrategyInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskWorkerPartitionedStrategyInfo | PlainMessage<TaskWorkerPartitionedStrategyInfo> | undefined, b: TaskWorkerPartitionedStrategyInfo | PlainMessage<TaskWorkerPartitionedStrategyInfo> | undefined): boolean {
    return proto3.util.equals(TaskWorkerPartitionedStrategyInfo, a, b);
  }
}

/**
 * @generated from enum clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy
 */
export enum TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
  /**
   * @generated from enum value: PARTITIONED_WORKER_STRATEGY_NOT_SET = 0;
   */
  PARTITIONED_WORKER_STRATEGY_NOT_SET = 0,

  /**
   * Each worker will label (approximately) the same number of inputs.
   *
   * @generated from enum value: EVENLY = 1;
   */
  EVENLY = 1,

  /**
   * Each worker will have an assigned weight.
   * See weights field for more details.
   *
   * @generated from enum value: WEIGHTED = 2;
   */
  WEIGHTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy)
proto3.util.setEnumType(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy, "clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy", [
  { no: 0, name: "PARTITIONED_WORKER_STRATEGY_NOT_SET" },
  { no: 1, name: "EVENLY" },
  { no: 2, name: "WEIGHTED" },
]);

/**
 * TaskInputSource
 *
 * @generated from message clarifai.api.TaskInputSource
 */
export class TaskInputSource extends Message<TaskInputSource> {
  /**
   * Type of input source.
   *
   * @generated from field: clarifai.api.TaskInputSource.TaskInputSourceType type = 1;
   */
  type = TaskInputSource_TaskInputSourceType.INPUT_SOURCE_TYPE_NOT_SET;

  /**
   * If type is SAVED_SEARCH, then this is the saved search id.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<TaskInputSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskInputSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(TaskInputSource_TaskInputSourceType) },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskInputSource {
    return new TaskInputSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskInputSource {
    return new TaskInputSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskInputSource {
    return new TaskInputSource().fromJsonString(jsonString, options);
  }

  static equals(a: TaskInputSource | PlainMessage<TaskInputSource> | undefined, b: TaskInputSource | PlainMessage<TaskInputSource> | undefined): boolean {
    return proto3.util.equals(TaskInputSource, a, b);
  }
}

/**
 * @generated from enum clarifai.api.TaskInputSource.TaskInputSourceType
 */
export enum TaskInputSource_TaskInputSourceType {
  /**
   * @generated from enum value: INPUT_SOURCE_TYPE_NOT_SET = 0;
   */
  INPUT_SOURCE_TYPE_NOT_SET = 0,

  /**
   * Use all inputs in the app.
   *
   * @generated from enum value: ALL_INPUTS = 1;
   */
  ALL_INPUTS = 1,

  /**
   * Use the inputs from a saved search.
   *
   * @generated from enum value: SAVED_SEARCH = 2;
   */
  SAVED_SEARCH = 2,

  /**
   * Inputs from a dataset.
   *
   * @generated from enum value: DATASET = 3;
   */
  DATASET = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskInputSource_TaskInputSourceType)
proto3.util.setEnumType(TaskInputSource_TaskInputSourceType, "clarifai.api.TaskInputSource.TaskInputSourceType", [
  { no: 0, name: "INPUT_SOURCE_TYPE_NOT_SET" },
  { no: 1, name: "ALL_INPUTS" },
  { no: 2, name: "SAVED_SEARCH" },
  { no: 3, name: "DATASET" },
]);

/**
 * TaskReview
 *
 * @generated from message clarifai.api.TaskReview
 */
export class TaskReview extends Message<TaskReview> {
  /**
   * Task review strategy.
   *
   * @generated from field: clarifai.api.TaskReview.TaskReviewStrategy strategy = 1;
   */
  strategy = TaskReview_TaskReviewStrategy.TASK_REVIEW_STRATEGY_NOT_SET;

  /**
   * Who will review this task.
   * DEPRECATED: Use users.id instead.
   *
   * @generated from field: repeated string user_ids = 2 [deprecated = true];
   * @deprecated
   */
  userIds: string[] = [];

  /**
   * Users who will review this task.
   * When the 'review.users' field is additionally requested, then all user
   * info is filled for the reviewers. Otherwise, only the user 'id' is filled.
   *
   * @generated from field: repeated clarifai.api.User users = 5;
   */
  users: User[] = [];

  /**
   * Info based on the review strategy,
   *
   * @generated from oneof clarifai.api.TaskReview.strategy_info
   */
  strategyInfo: {
    /**
     * @generated from field: clarifai.api.TaskReviewManualStrategyInfo manual_strategy_info = 3;
     */
    value: TaskReviewManualStrategyInfo;
    case: "manualStrategyInfo";
  } | {
    /**
     * @generated from field: clarifai.api.TaskReviewConsensusStrategyInfo consensus_strategy_info = 4;
     */
    value: TaskReviewConsensusStrategyInfo;
    case: "consensusStrategyInfo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TaskReview>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskReview";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "strategy", kind: "enum", T: proto3.getEnumType(TaskReview_TaskReviewStrategy) },
    { no: 2, name: "user_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "users", kind: "message", T: User, repeated: true },
    { no: 3, name: "manual_strategy_info", kind: "message", T: TaskReviewManualStrategyInfo, oneof: "strategy_info" },
    { no: 4, name: "consensus_strategy_info", kind: "message", T: TaskReviewConsensusStrategyInfo, oneof: "strategy_info" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskReview {
    return new TaskReview().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskReview {
    return new TaskReview().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskReview {
    return new TaskReview().fromJsonString(jsonString, options);
  }

  static equals(a: TaskReview | PlainMessage<TaskReview> | undefined, b: TaskReview | PlainMessage<TaskReview> | undefined): boolean {
    return proto3.util.equals(TaskReview, a, b);
  }
}

/**
 * @generated from enum clarifai.api.TaskReview.TaskReviewStrategy
 */
export enum TaskReview_TaskReviewStrategy {
  /**
   * @generated from enum value: TASK_REVIEW_STRATEGY_NOT_SET = 0;
   */
  TASK_REVIEW_STRATEGY_NOT_SET = 0,

  /**
   * No review is needed.
   *
   * @generated from enum value: NONE = 1;
   */
  NONE = 1,

  /**
   * Manual review strategy.
   *
   * @generated from enum value: MANUAL = 2;
   */
  MANUAL = 2,

  /**
   * Consensus review strategy.
   *
   * @generated from enum value: CONSENSUS = 3;
   */
  CONSENSUS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskReview_TaskReviewStrategy)
proto3.util.setEnumType(TaskReview_TaskReviewStrategy, "clarifai.api.TaskReview.TaskReviewStrategy", [
  { no: 0, name: "TASK_REVIEW_STRATEGY_NOT_SET" },
  { no: 1, name: "NONE" },
  { no: 2, name: "MANUAL" },
  { no: 3, name: "CONSENSUS" },
]);

/**
 * TaskReviewManualStrategyInfo
 *
 * @generated from message clarifai.api.TaskReviewManualStrategyInfo
 */
export class TaskReviewManualStrategyInfo extends Message<TaskReviewManualStrategyInfo> {
  /**
   * This field represents the percentage of inputs that will be reviewed by reviewers. It is a value between 0 and 1.
   *
   * @generated from field: float sample_percentage = 1;
   */
  samplePercentage = 0;

  constructor(data?: PartialMessage<TaskReviewManualStrategyInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskReviewManualStrategyInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sample_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskReviewManualStrategyInfo {
    return new TaskReviewManualStrategyInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskReviewManualStrategyInfo {
    return new TaskReviewManualStrategyInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskReviewManualStrategyInfo {
    return new TaskReviewManualStrategyInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskReviewManualStrategyInfo | PlainMessage<TaskReviewManualStrategyInfo> | undefined, b: TaskReviewManualStrategyInfo | PlainMessage<TaskReviewManualStrategyInfo> | undefined): boolean {
    return proto3.util.equals(TaskReviewManualStrategyInfo, a, b);
  }
}

/**
 * TaskReviewConsensusStrategyInfo
 *
 * @generated from message clarifai.api.TaskReviewConsensusStrategyInfo
 */
export class TaskReviewConsensusStrategyInfo extends Message<TaskReviewConsensusStrategyInfo> {
  /**
   * The number of labelers that need to agree in order to automatically approve an annotation.
   *
   * @generated from field: uint32 approval_threshold = 2;
   */
  approvalThreshold = 0;

  constructor(data?: PartialMessage<TaskReviewConsensusStrategyInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskReviewConsensusStrategyInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "approval_threshold", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskReviewConsensusStrategyInfo {
    return new TaskReviewConsensusStrategyInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskReviewConsensusStrategyInfo {
    return new TaskReviewConsensusStrategyInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskReviewConsensusStrategyInfo {
    return new TaskReviewConsensusStrategyInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskReviewConsensusStrategyInfo | PlainMessage<TaskReviewConsensusStrategyInfo> | undefined, b: TaskReviewConsensusStrategyInfo | PlainMessage<TaskReviewConsensusStrategyInfo> | undefined): boolean {
    return proto3.util.equals(TaskReviewConsensusStrategyInfo, a, b);
  }
}

/**
 * TaskAIAssistant
 *
 * @generated from message clarifai.api.TaskAIAssistant
 */
export class TaskAIAssistant extends Message<TaskAIAssistant> {
  /**
   * The worker is helped by an AI assistant.
   * This field is the workflow id which is used to assist the worker with predictions.
   * If empty, then AI assistant is disabled.
   *
   * @generated from field: string workflow_id = 1;
   */
  workflowId = "";

  constructor(data?: PartialMessage<TaskAIAssistant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskAIAssistant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskAIAssistant {
    return new TaskAIAssistant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskAIAssistant {
    return new TaskAIAssistant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskAIAssistant {
    return new TaskAIAssistant().fromJsonString(jsonString, options);
  }

  static equals(a: TaskAIAssistant | PlainMessage<TaskAIAssistant> | undefined, b: TaskAIAssistant | PlainMessage<TaskAIAssistant> | undefined): boolean {
    return proto3.util.equals(TaskAIAssistant, a, b);
  }
}

/**
 * TaskStatusCountPerUser can represents count of human created annotations for a user for each valid status,
 * count of inputs (anchor annotation) for a user for each valid status
 *
 * @generated from message clarifai.api.TaskStatusCountPerUser
 */
export class TaskStatusCountPerUser extends Message<TaskStatusCountPerUser> {
  /**
   * @generated from field: string user_id = 1;
   */
  userId = "";

  /**
   * @generated from field: uint32 pending = 2;
   */
  pending = 0;

  /**
   * @generated from field: uint32 awaiting_review = 3;
   */
  awaitingReview = 0;

  /**
   * @generated from field: uint32 success = 4;
   */
  success = 0;

  /**
   * @generated from field: uint32 review_denied = 5;
   */
  reviewDenied = 0;

  /**
   * @generated from field: uint32 awaiting_consensus_review = 6;
   */
  awaitingConsensusReview = 0;

  constructor(data?: PartialMessage<TaskStatusCountPerUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TaskStatusCountPerUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pending", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "awaiting_review", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "success", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "review_denied", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "awaiting_consensus_review", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskStatusCountPerUser {
    return new TaskStatusCountPerUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskStatusCountPerUser {
    return new TaskStatusCountPerUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskStatusCountPerUser {
    return new TaskStatusCountPerUser().fromJsonString(jsonString, options);
  }

  static equals(a: TaskStatusCountPerUser | PlainMessage<TaskStatusCountPerUser> | undefined, b: TaskStatusCountPerUser | PlainMessage<TaskStatusCountPerUser> | undefined): boolean {
    return proto3.util.equals(TaskStatusCountPerUser, a, b);
  }
}

/**
 * Role represents a list of permissions
 *
 * @generated from message clarifai.api.Role
 */
export class Role extends Message<Role> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the role was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the role was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * The low-level scopes this role has
   *
   * @generated from field: repeated string scopes = 6;
   */
  scopes: string[] = [];

  /**
   * The endpoint-level scopes this role has
   *
   * @generated from field: repeated string endpoints = 7;
   */
  endpoints: string[] = [];

  /**
   * Type of the role 'team' or 'org'
   *
   * @generated from field: clarifai.api.RoleType type = 8;
   */
  type = RoleType.TEAM;

  constructor(data?: PartialMessage<Role>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Role";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "type", kind: "enum", T: proto3.getEnumType(RoleType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Role {
    return new Role().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJsonString(jsonString, options);
  }

  static equals(a: Role | PlainMessage<Role> | undefined, b: Role | PlainMessage<Role> | undefined): boolean {
    return proto3.util.equals(Role, a, b);
  }
}

/**
 * Represents an organization
 *
 * @generated from message clarifai.api.Organization
 */
export class Organization extends Message<Organization> {
  /**
   * Identify the organization (unique).
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the organization was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the team was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * Name of the organization.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * Email for billing of the organization.
   *
   * @generated from field: string billing_email = 5;
   */
  billingEmail = "";

  constructor(data?: PartialMessage<Organization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Organization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "billing_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Organization {
    return new Organization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Organization {
    return new Organization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Organization {
    return new Organization().fromJsonString(jsonString, options);
  }

  static equals(a: Organization | PlainMessage<Organization> | undefined, b: Organization | PlainMessage<Organization> | undefined): boolean {
    return proto3.util.equals(Organization, a, b);
  }
}

/**
 * OrganizationMember
 *
 * @generated from message clarifai.api.OrganizationMember
 */
export class OrganizationMember extends Message<OrganizationMember> {
  /**
   * @generated from field: clarifai.api.User user = 1;
   */
  user?: User;

  /**
   * @generated from field: clarifai.api.Role role = 2;
   */
  role?: Role;

  /**
   * From when the role is active for member
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp not_before = 3;
   */
  notBefore?: Timestamp;

  constructor(data?: PartialMessage<OrganizationMember>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OrganizationMember";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "message", T: User },
    { no: 2, name: "role", kind: "message", T: Role },
    { no: 3, name: "not_before", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrganizationMember {
    return new OrganizationMember().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrganizationMember {
    return new OrganizationMember().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrganizationMember {
    return new OrganizationMember().fromJsonString(jsonString, options);
  }

  static equals(a: OrganizationMember | PlainMessage<OrganizationMember> | undefined, b: OrganizationMember | PlainMessage<OrganizationMember> | undefined): boolean {
    return proto3.util.equals(OrganizationMember, a, b);
  }
}

/**
 * Represents an IdentityProvider
 *
 * @generated from message clarifai.api.IdentityProvider
 */
export class IdentityProvider extends Message<IdentityProvider> {
  /**
   * Identify the IdentityProvider (unique).
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Name of the IdentityProvider.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: bool enabled = 3;
   */
  enabled = false;

  /**
   * SAML metadata url
   *
   * @generated from field: string saml_metadata_url = 4;
   */
  samlMetadataUrl = "";

  /**
   * Background color of the sign-in button
   *
   * @generated from field: string background_color = 5;
   */
  backgroundColor = "";

  /**
   * Icon in the sign-in button
   *
   * @generated from field: string icon = 6;
   */
  icon = "";

  /**
   * Text color of the sign-in button
   *
   * @generated from field: string text_color = 7;
   */
  textColor = "";

  /**
   * Identity provider type, currently supported types are saml and oauth
   *
   * @generated from field: string type = 8;
   */
  type = "";

  /**
   * Name of the oauth provider, currently supported are google and github
   *
   * @generated from field: string oauth_provider = 9;
   */
  oauthProvider = "";

  /**
   * oAuth client id
   *
   * @generated from field: string oauth_client_id = 10;
   */
  oauthClientId = "";

  /**
   * oAuth client secret
   *
   * @generated from field: string oauth_client_secret = 11;
   */
  oauthClientSecret = "";

  /**
   * When the identity_provider was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 12;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the identity_provider was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 13;
   */
  modifiedAt?: Timestamp;

  constructor(data?: PartialMessage<IdentityProvider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.IdentityProvider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "saml_metadata_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "background_color", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "icon", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "text_color", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "oauth_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "oauth_client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "oauth_client_secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "created_at", kind: "message", T: Timestamp },
    { no: 13, name: "modified_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentityProvider {
    return new IdentityProvider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentityProvider {
    return new IdentityProvider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentityProvider {
    return new IdentityProvider().fromJsonString(jsonString, options);
  }

  static equals(a: IdentityProvider | PlainMessage<IdentityProvider> | undefined, b: IdentityProvider | PlainMessage<IdentityProvider> | undefined): boolean {
    return proto3.util.equals(IdentityProvider, a, b);
  }
}

/**
 * Represents a group of users.
 *
 * @generated from message clarifai.api.Team
 */
export class Team extends Message<Team> {
  /**
   * Identify the team (unique).
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the team was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the team was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * Name the team.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<Team>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Team";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Team {
    return new Team().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Team {
    return new Team().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Team {
    return new Team().fromJsonString(jsonString, options);
  }

  static equals(a: Team | PlainMessage<Team> | undefined, b: Team | PlainMessage<Team> | undefined): boolean {
    return proto3.util.equals(Team, a, b);
  }
}

/**
 * Represent a user associated to a team.
 *
 * @generated from message clarifai.api.TeamUser
 */
export class TeamUser extends Message<TeamUser> {
  /**
   * @generated from field: string team_id = 1;
   */
  teamId = "";

  /**
   * @generated from field: string user_id = 2;
   */
  userId = "";

  /**
   * When the team user was created.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string first_name = 4;
   */
  firstName = "";

  /**
   * @generated from field: string last_name = 5;
   */
  lastName = "";

  constructor(data?: PartialMessage<TeamUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TeamUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "team_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "first_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TeamUser {
    return new TeamUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TeamUser {
    return new TeamUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TeamUser {
    return new TeamUser().fromJsonString(jsonString, options);
  }

  static equals(a: TeamUser | PlainMessage<TeamUser> | undefined, b: TeamUser | PlainMessage<TeamUser> | undefined): boolean {
    return proto3.util.equals(TeamUser, a, b);
  }
}

/**
 * OrganizationInvitation
 *
 * @generated from message clarifai.api.OrganizationInvitation
 */
export class OrganizationInvitation extends Message<OrganizationInvitation> {
  /**
   * id of the invitation
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * email of the invitee
   *
   * @generated from field: string invitee_email = 2;
   */
  inviteeEmail = "";

  /**
   * the role which the invitee will be assigned to in the org
   *
   * @generated from field: clarifai.api.Role role = 3;
   */
  role?: Role;

  /**
   * the organization the invitee will be assigned into
   *
   * @generated from field: clarifai.api.Organization organization = 4;
   */
  organization?: Organization;

  /**
   * when the invite was created
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * when the invite was cancelled by the inviter
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp cancelled_at = 6;
   */
  cancelledAt?: Timestamp;

  /**
   * when the invite was declined by the invitee
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp declined_at = 7;
   */
  declinedAt?: Timestamp;

  /**
   * when the invite was accepted by the invitee
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp accepted_at = 8;
   */
  acceptedAt?: Timestamp;

  /**
   * true if a primary email matching 'invitee_email' exists, currently only for GET endpoints, always false for List
   *
   * @generated from field: bool primary_email_exists = 9;
   */
  primaryEmailExists = false;

  constructor(data?: PartialMessage<OrganizationInvitation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OrganizationInvitation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "invitee_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "role", kind: "message", T: Role },
    { no: 4, name: "organization", kind: "message", T: Organization },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "cancelled_at", kind: "message", T: Timestamp },
    { no: 7, name: "declined_at", kind: "message", T: Timestamp },
    { no: 8, name: "accepted_at", kind: "message", T: Timestamp },
    { no: 9, name: "primary_email_exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrganizationInvitation {
    return new OrganizationInvitation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrganizationInvitation {
    return new OrganizationInvitation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrganizationInvitation {
    return new OrganizationInvitation().fromJsonString(jsonString, options);
  }

  static equals(a: OrganizationInvitation | PlainMessage<OrganizationInvitation> | undefined, b: OrganizationInvitation | PlainMessage<OrganizationInvitation> | undefined): boolean {
    return proto3.util.equals(OrganizationInvitation, a, b);
  }
}

/**
 * Collector is a data pathway from a CollectorSource to an app to collect data automatically.
 * For example, a CollectorSource
 *
 * @generated from message clarifai.api.Collector
 */
export class Collector extends Message<Collector> {
  /**
   * Unique ID for the collector.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Human readable description for the collector.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * When the collector is created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * This is a workflow to run inline in model predict calls. It should ONLY have very fast and
   * light-weight models in it as it will effect the speed of the predictions being made.
   * This workflow's purpose is to filter down the inputs to queue for the collector to process.
   * The input to this workflow is going to be the OUTPUT of the model, not the input to the model
   * since we want to encourage having fast workflows that can also take advantage of the model
   * outputs to make deciions (for example: thresholding based on concepts). If the workflow
   * output has any field that is non-empty then the input will be queued for the collector
   * to process with the post_queue_workflow_id.
   *
   * @generated from field: string pre_queue_workflow_id = 4;
   */
  preQueueWorkflowId = "";

  /**
   * A workflow to run to after the collector is processing the queued input. This workflow
   * uses the original input to the model as input to the workflow so that you can run additional
   * models as well on that input to decide whether to queue the model or not. If the workflow
   * output has any field that is non-empty then it will be passed on to POST /inputs to
   * the destination app.
   *
   * @generated from field: string post_queue_workflow_id = 5;
   */
  postQueueWorkflowId = "";

  /**
   * The source of the collector to feed data into this app.
   * Note(zeiler): if we wanted more than one source per collector we could make this it's own
   * object and introduce /collectors/{collector_id}/sources
   * We will keep it simple for now and have just one source per collector since a user can make
   * more than one collector in the same app anyways.
   *
   * @generated from field: clarifai.api.CollectorSource collector_source = 6;
   */
  collectorSource?: CollectorSource;

  /**
   * Status for the collector. This allows you to pause a collector without having to delete it as
   * an example.
   *
   * @generated from field: clarifai.api.status.Status status = 7;
   */
  status?: Status;

  constructor(data?: PartialMessage<Collector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Collector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "pre_queue_workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "post_queue_workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "collector_source", kind: "message", T: CollectorSource },
    { no: 7, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collector {
    return new Collector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collector {
    return new Collector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collector {
    return new Collector().fromJsonString(jsonString, options);
  }

  static equals(a: Collector | PlainMessage<Collector> | undefined, b: Collector | PlainMessage<Collector> | undefined): boolean {
    return proto3.util.equals(Collector, a, b);
  }
}

/**
 * Configuration for the source to collect data from.
 * Only one of the fields can be present at a time.
 *
 * The ID of the source in case we want to implment /collectors/{collector_id}/sources
 * string id = 1;
 *
 * @generated from message clarifai.api.CollectorSource
 */
export class CollectorSource extends Message<CollectorSource> {
  /**
   * Collect from the inputs passed in for PostModelOutputs predictions of a specific model.
   * This does not apply to models used within workflows, only PostModelOutputs calls.
   *
   * @generated from field: clarifai.api.APIPostModelOutputsCollectorSource api_post_model_outputs_collector_source = 2;
   */
  apiPostModelOutputsCollectorSource?: APIPostModelOutputsCollectorSource;

  constructor(data?: PartialMessage<CollectorSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.CollectorSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "api_post_model_outputs_collector_source", kind: "message", T: APIPostModelOutputsCollectorSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectorSource {
    return new CollectorSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectorSource {
    return new CollectorSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectorSource {
    return new CollectorSource().fromJsonString(jsonString, options);
  }

  static equals(a: CollectorSource | PlainMessage<CollectorSource> | undefined, b: CollectorSource | PlainMessage<CollectorSource> | undefined): boolean {
    return proto3.util.equals(CollectorSource, a, b);
  }
}

/**
 * This is configuration for using the inputs send for model prediction in our API as
 * as the source for data.
 *
 * @generated from message clarifai.api.APIPostModelOutputsCollectorSource
 */
export class APIPostModelOutputsCollectorSource extends Message<APIPostModelOutputsCollectorSource> {
  /**
   * To define the model that we should collect from we need to specify the following 4 IDs:
   * The User ID of the model we want to collect from.
   * This is User B in the example.
   *
   * @generated from field: string model_user_id = 1;
   */
  modelUserId = "";

  /**
   * The App ID of the model we want to collect from.
   *
   * @generated from field: string model_app_id = 2;
   */
  modelAppId = "";

  /**
   * The Model ID of the model we want to collect from.
   *
   * @generated from field: string model_id = 3;
   */
  modelId = "";

  /**
   * The Version ID of the model we want to collect from.
   *
   * @generated from field: string model_version_id = 4;
   */
  modelVersionId = "";

  /**
   * This key is used to POST /inputs into your app by the collector. It can be an API key or a
   * PAT. This needs the permissions that are needed for POST /inputs for the app_id this
   * Collector is defined in.
   *
   * @generated from field: string post_inputs_key_id = 5;
   */
  postInputsKeyId = "";

  /**
   * This is a private field that defaults to the app owner for public users.
   * If this is left blank then this collector will collect from ALL users calling the given model.
   *
   * @generated from field: string caller_user_id = 6;
   */
  callerUserId = "";

  constructor(data?: PartialMessage<APIPostModelOutputsCollectorSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.APIPostModelOutputsCollectorSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model_app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "post_inputs_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "caller_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): APIPostModelOutputsCollectorSource {
    return new APIPostModelOutputsCollectorSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): APIPostModelOutputsCollectorSource {
    return new APIPostModelOutputsCollectorSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): APIPostModelOutputsCollectorSource {
    return new APIPostModelOutputsCollectorSource().fromJsonString(jsonString, options);
  }

  static equals(a: APIPostModelOutputsCollectorSource | PlainMessage<APIPostModelOutputsCollectorSource> | undefined, b: APIPostModelOutputsCollectorSource | PlainMessage<APIPostModelOutputsCollectorSource> | undefined): boolean {
    return proto3.util.equals(APIPostModelOutputsCollectorSource, a, b);
  }
}

/**
 * StatValue
 *
 * @generated from message clarifai.api.StatValue
 */
export class StatValue extends Message<StatValue> {
  /**
   * The time of the event. Defaults to now().
   *
   * @generated from field: google.protobuf.Timestamp time = 1;
   */
  time?: Timestamp;

  /**
   * A value for the metric you're recording.
   *
   * @generated from field: float value = 2;
   */
  value = 0;

  /**
   * List of tags to attach to this stat. Each should contain one colon so that the first part will
   * be used as a tag group while the second being the tag itself. For example: ["task_id:a",
   * "worker_id:1"]. These tag groups like "task_id" or "worker_id" are important for aggregating
   * values in the StatValueAggregateQuery.
   *
   * @generated from field: repeated string tags = 3;
   */
  tags: string[] = [];

  constructor(data?: PartialMessage<StatValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.StatValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time", kind: "message", T: Timestamp },
    { no: 2, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatValue {
    return new StatValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatValue {
    return new StatValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatValue {
    return new StatValue().fromJsonString(jsonString, options);
  }

  static equals(a: StatValue | PlainMessage<StatValue> | undefined, b: StatValue | PlainMessage<StatValue> | undefined): boolean {
    return proto3.util.equals(StatValue, a, b);
  }
}

/**
 * StatValueAggregateResult
 *
 * @generated from message clarifai.api.StatValueAggregateResult
 */
export class StatValueAggregateResult extends Message<StatValueAggregateResult> {
  /**
   * The list of repeated aggregate values and their counts.
   *
   * @generated from field: repeated clarifai.api.StatValueAggregate stat_value_aggregates = 1;
   */
  statValueAggregates: StatValueAggregate[] = [];

  /**
   * The query that created these results.
   *
   * @generated from field: clarifai.api.StatValueAggregateQuery stat_value_aggregate_query = 2;
   */
  statValueAggregateQuery?: StatValueAggregateQuery;

  constructor(data?: PartialMessage<StatValueAggregateResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.StatValueAggregateResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stat_value_aggregates", kind: "message", T: StatValueAggregate, repeated: true },
    { no: 2, name: "stat_value_aggregate_query", kind: "message", T: StatValueAggregateQuery },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatValueAggregateResult {
    return new StatValueAggregateResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatValueAggregateResult {
    return new StatValueAggregateResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatValueAggregateResult {
    return new StatValueAggregateResult().fromJsonString(jsonString, options);
  }

  static equals(a: StatValueAggregateResult | PlainMessage<StatValueAggregateResult> | undefined, b: StatValueAggregateResult | PlainMessage<StatValueAggregateResult> | undefined): boolean {
    return proto3.util.equals(StatValueAggregateResult, a, b);
  }
}

/**
 * StatValueAggregate
 *
 * @generated from message clarifai.api.StatValueAggregate
 */
export class StatValueAggregate extends Message<StatValueAggregate> {
  /**
   * The time of the aggregation. For example, if you aggregate over "HOUR" buckets then you can
   * expect each hour that has atleast one value (matching the rest of your query fields) will have
   * a StatValueAggregate with the time filled into that hour.
   *
   * @generated from field: google.protobuf.Timestamp time = 1;
   */
  time?: Timestamp;

  /**
   * The value aggregated according to the stat_value_agg_type
   *
   * @generated from field: float aggregate_value = 2;
   */
  aggregateValue = 0;

  /**
   * The count of the stat values that were used in this aggregation.
   *
   * @generated from field: uint64 count = 3;
   */
  count = protoInt64.zero;

  /**
   * The tags for this aggregated_value and count. This will be filled in if tag groups were used in
   * the query to group aggregations.
   *
   * @generated from field: repeated string tags = 4;
   */
  tags: string[] = [];

  constructor(data?: PartialMessage<StatValueAggregate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.StatValueAggregate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time", kind: "message", T: Timestamp },
    { no: 2, name: "aggregate_value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatValueAggregate {
    return new StatValueAggregate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatValueAggregate {
    return new StatValueAggregate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatValueAggregate {
    return new StatValueAggregate().fromJsonString(jsonString, options);
  }

  static equals(a: StatValueAggregate | PlainMessage<StatValueAggregate> | undefined, b: StatValueAggregate | PlainMessage<StatValueAggregate> | undefined): boolean {
    return proto3.util.equals(StatValueAggregate, a, b);
  }
}

/**
 * StatValueAggregateQuery
 *
 * @generated from message clarifai.api.StatValueAggregateQuery
 */
export class StatValueAggregateQuery extends Message<StatValueAggregateQuery> {
  /**
   * These tags are used to filter down the values before they are aggregated. For example,
   * if you want to aggregate values for "task_id:a" you could specify that as a tag here.
   *
   * @generated from field: repeated string tags = 1;
   */
  tags: string[] = [];

  /**
   * These are tag groups to aggregate over. So for example if you added stat values with tags
   * "task_id:a" and others with "task_id:b", then added ["task_id"] to the task group, it the
   * aggregation would return StatValueAggregate values for each task_id. If you provide more than
   * one tag_group the response will return all rolled up combinations of them. For example
   * ["task_id", "something"] where "something:1" and "something:2" were used as tags for some
   * values then you'd get StatValueAggregate values back for:
   * task_id | something
   * a       | 1
   * a       | 2
   * b       | 1
   * b       | 1
   *
   * @generated from field: repeated string tag_groups = 2;
   */
  tagGroups: string[] = [];

  /**
   * Aggregation function to use over the values. Count(value) is also always returns.
   * Defaults to 'sum' if not provided.
   *
   * @generated from field: clarifai.api.StatValueAggType stat_value_agg_type = 3;
   */
  statValueAggType = StatValueAggType.SUM;

  /**
   * Aggregation bins for time where the values will be aggregated at this bin granualarity.
   * And the "time" field will be returned in StatValueAggregate object.
   * If not provided then bins are not used, and all time is aggregated over.
   *
   * @generated from field: clarifai.api.StatTimeAggType stat_time_agg_type = 4;
   */
  statTimeAggType = StatTimeAggType.NO_TIME_AGG;

  /**
   * If provided the time range over which values will be >= this time. If not provided then
   * all values will be used back to start of time.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 5;
   */
  startTime?: Timestamp;

  /**
   * If provided the time range over which values will be <= this time. If not provided then all
   * values will be used up until now().
   *
   * @generated from field: google.protobuf.Timestamp end_time = 6;
   */
  endTime?: Timestamp;

  constructor(data?: PartialMessage<StatValueAggregateQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.StatValueAggregateQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "tag_groups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "stat_value_agg_type", kind: "enum", T: proto3.getEnumType(StatValueAggType) },
    { no: 4, name: "stat_time_agg_type", kind: "enum", T: proto3.getEnumType(StatTimeAggType) },
    { no: 5, name: "start_time", kind: "message", T: Timestamp },
    { no: 6, name: "end_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatValueAggregateQuery {
    return new StatValueAggregateQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatValueAggregateQuery {
    return new StatValueAggregateQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatValueAggregateQuery {
    return new StatValueAggregateQuery().fromJsonString(jsonString, options);
  }

  static equals(a: StatValueAggregateQuery | PlainMessage<StatValueAggregateQuery> | undefined, b: StatValueAggregateQuery | PlainMessage<StatValueAggregateQuery> | undefined): boolean {
    return proto3.util.equals(StatValueAggregateQuery, a, b);
  }
}

/**
 * Authentication method available in the portal
 *
 * @generated from message clarifai.api.AuthMethod
 */
export class AuthMethod extends Message<AuthMethod> {
  /**
   * Id of authentication method
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Type of authentication method. See AuthMethodType.
   *
   * @generated from field: clarifai.api.AuthMethod.AuthMethodType type = 2;
   */
  type = AuthMethod_AuthMethodType.AUTH_METHOD_TYPE_NOT_SET;

  /**
   * Name of authentication method.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * Flag to show if authentication method is enabled or disabled.
   *
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  /**
   * Link for initiating the auth flow for Identity Provider
   * This is required when type = SAML or OAUTH.
   *
   * @generated from field: string auth_link = 5;
   */
  authLink = "";

  /**
   * @generated from field: string background_color = 6;
   */
  backgroundColor = "";

  /**
   * @generated from field: string icon = 7;
   */
  icon = "";

  /**
   * @generated from field: string text_color = 8;
   */
  textColor = "";

  constructor(data?: PartialMessage<AuthMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AuthMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(AuthMethod_AuthMethodType) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "auth_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "background_color", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "icon", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "text_color", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthMethod {
    return new AuthMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthMethod {
    return new AuthMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthMethod {
    return new AuthMethod().fromJsonString(jsonString, options);
  }

  static equals(a: AuthMethod | PlainMessage<AuthMethod> | undefined, b: AuthMethod | PlainMessage<AuthMethod> | undefined): boolean {
    return proto3.util.equals(AuthMethod, a, b);
  }
}

/**
 * @generated from enum clarifai.api.AuthMethod.AuthMethodType
 */
export enum AuthMethod_AuthMethodType {
  /**
   * @generated from enum value: AUTH_METHOD_TYPE_NOT_SET = 0;
   */
  AUTH_METHOD_TYPE_NOT_SET = 0,

  /**
   * This is used for standard authentication method: user & password.
   *
   * @generated from enum value: PASSWORD = 1;
   */
  PASSWORD = 1,

  /**
   * This is used for Single Sign On authentication method using a SAML Identity Provider.
   *
   * @generated from enum value: SAML = 2;
   */
  SAML = 2,

  /**
   * This is used for Single Sign On authentication method using a OAuth Identity Provider.
   *
   * @generated from enum value: OAUTH = 3;
   */
  OAUTH = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthMethod_AuthMethodType)
proto3.util.setEnumType(AuthMethod_AuthMethodType, "clarifai.api.AuthMethod.AuthMethodType", [
  { no: 0, name: "AUTH_METHOD_TYPE_NOT_SET" },
  { no: 1, name: "PASSWORD" },
  { no: 2, name: "SAML" },
  { no: 3, name: "OAUTH" },
]);

/**
 * 2FA method available in the portal
 *
 * @generated from message clarifai.api.TwoFactorAuthMethod
 */
export class TwoFactorAuthMethod extends Message<TwoFactorAuthMethod> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Type of 2FA method. See AuthMethodType.
   *
   * @generated from field: clarifai.api.TwoFactorAuthMethod.AuthMethodType type = 2;
   */
  type = TwoFactorAuthMethod_AuthMethodType.AUTH_METHOD_TYPE_NOT_SET;

  /**
   * Name of 2FA method.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * Flag to show if 2FA method is enabled or disabled.
   *
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  constructor(data?: PartialMessage<TwoFactorAuthMethod>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TwoFactorAuthMethod";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TwoFactorAuthMethod_AuthMethodType) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TwoFactorAuthMethod {
    return new TwoFactorAuthMethod().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TwoFactorAuthMethod {
    return new TwoFactorAuthMethod().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TwoFactorAuthMethod {
    return new TwoFactorAuthMethod().fromJsonString(jsonString, options);
  }

  static equals(a: TwoFactorAuthMethod | PlainMessage<TwoFactorAuthMethod> | undefined, b: TwoFactorAuthMethod | PlainMessage<TwoFactorAuthMethod> | undefined): boolean {
    return proto3.util.equals(TwoFactorAuthMethod, a, b);
  }
}

/**
 * @generated from enum clarifai.api.TwoFactorAuthMethod.AuthMethodType
 */
export enum TwoFactorAuthMethod_AuthMethodType {
  /**
   * @generated from enum value: AUTH_METHOD_TYPE_NOT_SET = 0;
   */
  AUTH_METHOD_TYPE_NOT_SET = 0,

  /**
   * TOTP - Time base one time password.
   *
   * @generated from enum value: TOTP = 1;
   */
  TOTP = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(TwoFactorAuthMethod_AuthMethodType)
proto3.util.setEnumType(TwoFactorAuthMethod_AuthMethodType, "clarifai.api.TwoFactorAuthMethod.AuthMethodType", [
  { no: 0, name: "AUTH_METHOD_TYPE_NOT_SET" },
  { no: 1, name: "TOTP" },
]);

/**
 * SDK Billing Cycle defines which year and month is associated with the billing data
 *
 * @generated from message clarifai.api.SDKBillingCycle
 */
export class SDKBillingCycle extends Message<SDKBillingCycle> {
  /**
   * Year of the billing
   *
   * @generated from field: uint32 year = 1;
   */
  year = 0;

  /**
   * Month of the billing
   *
   * @generated from field: uint32 month = 2;
   */
  month = 0;

  constructor(data?: PartialMessage<SDKBillingCycle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.SDKBillingCycle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "year", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "month", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SDKBillingCycle {
    return new SDKBillingCycle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SDKBillingCycle {
    return new SDKBillingCycle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SDKBillingCycle {
    return new SDKBillingCycle().fromJsonString(jsonString, options);
  }

  static equals(a: SDKBillingCycle | PlainMessage<SDKBillingCycle> | undefined, b: SDKBillingCycle | PlainMessage<SDKBillingCycle> | undefined): boolean {
    return proto3.util.equals(SDKBillingCycle, a, b);
  }
}

/**
 * DeviceInfo
 *
 * @generated from message clarifai.api.DeviceInfo
 */
export class DeviceInfo extends Message<DeviceInfo> {
  /**
   * Apple, Samsung, LG, etc
   *
   * @generated from field: string brand = 1;
   */
  brand = "";

  /**
   * iPhone10,3
   *
   * @generated from field: string model = 2;
   */
  model = "";

  constructor(data?: PartialMessage<DeviceInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DeviceInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "brand", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceInfo {
    return new DeviceInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceInfo {
    return new DeviceInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceInfo {
    return new DeviceInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceInfo | PlainMessage<DeviceInfo> | undefined, b: DeviceInfo | PlainMessage<DeviceInfo> | undefined): boolean {
    return proto3.util.equals(DeviceInfo, a, b);
  }
}

/**
 * SDKEventSummary
 *
 * @generated from message clarifai.api.SDKEventSummary
 */
export class SDKEventSummary extends Message<SDKEventSummary> {
  /**
   * Number of events logged under this grouping
   *
   * @generated from field: uint32 count = 1;
   */
  count = 0;

  /**
   * Name associated with the event type
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: clarifai.api.SDKEventSummary.AnalyticsEventType event_type = 3;
   */
  eventType = SDKEventSummary_AnalyticsEventType.UNKNOWN_EVENT_TYPE;

  /**
   * @generated from field: clarifai.api.SDKEventSummary.NetworkConnectivity network_connectivity = 4;
   */
  networkConnectivity = SDKEventSummary_NetworkConnectivity.NO_CONNECTIVITY;

  /**
   * @generated from field: clarifai.api.SDKEventSummary.RunningMode running_mode = 5;
   */
  runningMode = SDKEventSummary_RunningMode.UNKNOWN_RUNNING_MODE;

  /**
   * id of the model associated with the event
   *
   * @generated from field: string model_id = 6;
   */
  modelId = "";

  /**
   * id of the model version associated with the event
   *
   * @generated from field: string model_version_id = 7;
   */
  modelVersionId = "";

  constructor(data?: PartialMessage<SDKEventSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.SDKEventSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "event_type", kind: "enum", T: proto3.getEnumType(SDKEventSummary_AnalyticsEventType) },
    { no: 4, name: "network_connectivity", kind: "enum", T: proto3.getEnumType(SDKEventSummary_NetworkConnectivity) },
    { no: 5, name: "running_mode", kind: "enum", T: proto3.getEnumType(SDKEventSummary_RunningMode) },
    { no: 6, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SDKEventSummary {
    return new SDKEventSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SDKEventSummary {
    return new SDKEventSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SDKEventSummary {
    return new SDKEventSummary().fromJsonString(jsonString, options);
  }

  static equals(a: SDKEventSummary | PlainMessage<SDKEventSummary> | undefined, b: SDKEventSummary | PlainMessage<SDKEventSummary> | undefined): boolean {
    return proto3.util.equals(SDKEventSummary, a, b);
  }
}

/**
 * @generated from enum clarifai.api.SDKEventSummary.RunningMode
 */
export enum SDKEventSummary_RunningMode {
  /**
   * @generated from enum value: UNKNOWN_RUNNING_MODE = 0;
   */
  UNKNOWN_RUNNING_MODE = 0,

  /**
   * Instruction runs on device
   *
   * @generated from enum value: LOCAL = 1;
   */
  LOCAL = 1,

  /**
   * Instruction runs remotely, on the cloud
   *
   * @generated from enum value: REMOTE = 2;
   */
  REMOTE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SDKEventSummary_RunningMode)
proto3.util.setEnumType(SDKEventSummary_RunningMode, "clarifai.api.SDKEventSummary.RunningMode", [
  { no: 0, name: "UNKNOWN_RUNNING_MODE" },
  { no: 1, name: "LOCAL" },
  { no: 2, name: "REMOTE" },
]);

/**
 * @generated from enum clarifai.api.SDKEventSummary.NetworkConnectivity
 */
export enum SDKEventSummary_NetworkConnectivity {
  /**
   * @generated from enum value: NO_CONNECTIVITY = 0;
   */
  NO_CONNECTIVITY = 0,

  /**
   * @generated from enum value: WIFI = 1;
   */
  WIFI = 1,

  /**
   * WAN
   *
   * @generated from enum value: CELLULAR = 2;
   */
  CELLULAR = 2,

  /**
   * Ethernet, USB, etc
   *
   * @generated from enum value: WIRED = 3;
   */
  WIRED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SDKEventSummary_NetworkConnectivity)
proto3.util.setEnumType(SDKEventSummary_NetworkConnectivity, "clarifai.api.SDKEventSummary.NetworkConnectivity", [
  { no: 0, name: "NO_CONNECTIVITY" },
  { no: 1, name: "WIFI" },
  { no: 2, name: "CELLULAR" },
  { no: 3, name: "WIRED" },
]);

/**
 * @generated from enum clarifai.api.SDKEventSummary.AnalyticsEventType
 */
export enum SDKEventSummary_AnalyticsEventType {
  /**
   * @generated from enum value: UNKNOWN_EVENT_TYPE = 0;
   */
  UNKNOWN_EVENT_TYPE = 0,

  /**
   * @generated from enum value: SAVE_MODEL = 1;
   */
  SAVE_MODEL = 1,

  /**
   * @generated from enum value: TRAIN = 2;
   */
  TRAIN = 2,

  /**
   * @generated from enum value: PREDICT = 3;
   */
  PREDICT = 3,

  /**
   * @generated from enum value: SAVE_CONCEPT = 4;
   */
  SAVE_CONCEPT = 4,

  /**
   * @generated from enum value: DELETE_CONCEPT = 5;
   */
  DELETE_CONCEPT = 5,

  /**
   * @generated from enum value: SAVE_INPUT = 6;
   */
  SAVE_INPUT = 6,

  /**
   * @generated from enum value: LOAD_INPUT = 7;
   */
  LOAD_INPUT = 7,

  /**
   * @generated from enum value: VISUAL_SIMILARITY = 8;
   */
  VISUAL_SIMILARITY = 8,

  /**
   * @generated from enum value: LOAD_CONCEPT = 9;
   */
  LOAD_CONCEPT = 9,

  /**
   * @generated from enum value: DELETE_INPUT = 10;
   */
  DELETE_INPUT = 10,

  /**
   * @generated from enum value: DELETE_MODEL = 11;
   */
  DELETE_MODEL = 11,

  /**
   * @generated from enum value: LOAD_MODEL = 12;
   */
  LOAD_MODEL = 12,

  /**
   * Something didn't go according to plan (e.g. a prediction failed, empty vector parameter)
   *
   * @generated from enum value: WARNING = 13;
   */
  WARNING = 13,

  /**
   * An operation failed (e.g. failed to build a batch, model file is corrupted)
   *
   * @generated from enum value: ERROR = 14;
   */
  ERROR = 14,

  /**
   * App launch
   *
   * @generated from enum value: LAUNCH = 15;
   */
  LAUNCH = 15,

  /**
   * App is brought to the foreground
   *
   * @generated from enum value: FOREGROUND = 16;
   */
  FOREGROUND = 16,

  /**
   * App is sent to the background
   *
   * @generated from enum value: BACKGROUND = 17;
   */
  BACKGROUND = 17,

  /**
   * Force quit app
   *
   * @generated from enum value: TERMINATION = 18;
   */
  TERMINATION = 18,

  /**
   * Authentication result received: granted
   *
   * @generated from enum value: AUTHENTICATION_GRANTED = 19;
   */
  AUTHENTICATION_GRANTED = 19,

  /**
   * Authentication result received: denied
   *
   * @generated from enum value: AUTHENTICATION_DENIED = 20;
   */
  AUTHENTICATION_DENIED = 20,

  /**
   * Model has been downloaded from the cloud to an SDK (Device)
   *
   * @generated from enum value: MODEL_DOWNLOAD = 21;
   */
  MODEL_DOWNLOAD = 21,
}
// Retrieve enum metadata with: proto3.getEnumType(SDKEventSummary_AnalyticsEventType)
proto3.util.setEnumType(SDKEventSummary_AnalyticsEventType, "clarifai.api.SDKEventSummary.AnalyticsEventType", [
  { no: 0, name: "UNKNOWN_EVENT_TYPE" },
  { no: 1, name: "SAVE_MODEL" },
  { no: 2, name: "TRAIN" },
  { no: 3, name: "PREDICT" },
  { no: 4, name: "SAVE_CONCEPT" },
  { no: 5, name: "DELETE_CONCEPT" },
  { no: 6, name: "SAVE_INPUT" },
  { no: 7, name: "LOAD_INPUT" },
  { no: 8, name: "VISUAL_SIMILARITY" },
  { no: 9, name: "LOAD_CONCEPT" },
  { no: 10, name: "DELETE_INPUT" },
  { no: 11, name: "DELETE_MODEL" },
  { no: 12, name: "LOAD_MODEL" },
  { no: 13, name: "WARNING" },
  { no: 14, name: "ERROR" },
  { no: 15, name: "LAUNCH" },
  { no: 16, name: "FOREGROUND" },
  { no: 17, name: "BACKGROUND" },
  { no: 18, name: "TERMINATION" },
  { no: 19, name: "AUTHENTICATION_GRANTED" },
  { no: 20, name: "AUTHENTICATION_DENIED" },
  { no: 21, name: "MODEL_DOWNLOAD" },
]);

/**
 * SDKEventsCollection
 *
 * @generated from message clarifai.api.SDKEventsCollection
 */
export class SDKEventsCollection extends Message<SDKEventsCollection> {
  /**
   * Begin of the events summary time range
   *
   * @generated from field: google.protobuf.Timestamp time_range_begin = 1;
   */
  timeRangeBegin?: Timestamp;

  /**
   * End of the events summary time range
   *
   * @generated from field: google.protobuf.Timestamp time_range_end = 2;
   */
  timeRangeEnd?: Timestamp;

  /**
   * @generated from field: repeated clarifai.api.SDKEventSummary event_summary = 3;
   */
  eventSummary: SDKEventSummary[] = [];

  constructor(data?: PartialMessage<SDKEventsCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.SDKEventsCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time_range_begin", kind: "message", T: Timestamp },
    { no: 2, name: "time_range_end", kind: "message", T: Timestamp },
    { no: 3, name: "event_summary", kind: "message", T: SDKEventSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SDKEventsCollection {
    return new SDKEventsCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SDKEventsCollection {
    return new SDKEventsCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SDKEventsCollection {
    return new SDKEventsCollection().fromJsonString(jsonString, options);
  }

  static equals(a: SDKEventsCollection | PlainMessage<SDKEventsCollection> | undefined, b: SDKEventsCollection | PlainMessage<SDKEventsCollection> | undefined): boolean {
    return proto3.util.equals(SDKEventsCollection, a, b);
  }
}

/**
 * HostAppInfo
 *
 * @generated from message clarifai.api.HostAppInfo
 */
export class HostAppInfo extends Message<HostAppInfo> {
  /**
   * Host app build number
   *
   * @generated from field: string build_number = 1;
   */
  buildNumber = "";

  /**
   * Clarifai's API Key associated with the host app
   *
   * @generated from field: string api_key = 2;
   */
  apiKey = "";

  /**
   * Host app version
   *
   * @generated from field: string version = 3;
   */
  version = "";

  constructor(data?: PartialMessage<HostAppInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.HostAppInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostAppInfo {
    return new HostAppInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostAppInfo {
    return new HostAppInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostAppInfo {
    return new HostAppInfo().fromJsonString(jsonString, options);
  }

  static equals(a: HostAppInfo | PlainMessage<HostAppInfo> | undefined, b: HostAppInfo | PlainMessage<HostAppInfo> | undefined): boolean {
    return proto3.util.equals(HostAppInfo, a, b);
  }
}

/**
 * OperatingSystem
 *
 * @generated from message clarifai.api.OperatingSystem
 */
export class OperatingSystem extends Message<OperatingSystem> {
  /**
   * macOS, Linux, FreeBSD, etc
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Version of the OS
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<OperatingSystem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OperatingSystem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperatingSystem {
    return new OperatingSystem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperatingSystem {
    return new OperatingSystem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperatingSystem {
    return new OperatingSystem().fromJsonString(jsonString, options);
  }

  static equals(a: OperatingSystem | PlainMessage<OperatingSystem> | undefined, b: OperatingSystem | PlainMessage<OperatingSystem> | undefined): boolean {
    return proto3.util.equals(OperatingSystem, a, b);
  }
}

/**
 * SDK
 *
 * @generated from message clarifai.api.SDK
 */
export class SDK extends Message<SDK> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string build = 2;
   */
  build = "";

  constructor(data?: PartialMessage<SDK>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.SDK";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "build", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SDK {
    return new SDK().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SDK {
    return new SDK().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SDK {
    return new SDK().fromJsonString(jsonString, options);
  }

  static equals(a: SDK | PlainMessage<SDK> | undefined, b: SDK | PlainMessage<SDK> | undefined): boolean {
    return proto3.util.equals(SDK, a, b);
  }
}

/**
 * State
 *
 * @generated from message clarifai.api.State
 */
export class State extends Message<State> {
  /**
   * US, UK, SK, etc
   *
   * @generated from field: string country_code = 1;
   */
  countryCode = "";

  /**
   * Number of times (cumulative over lifetime) the SDK has been launched
   *
   * @generated from field: uint32 launch_count = 2;
   */
  launchCount = 0;

  /**
   * en, fr, cs
   *
   * @generated from field: string language_code = 3;
   */
  languageCode = "";

  /**
   * Number used tokens. Starts from 0 and counts towards a budget, until renewed by the server
   *
   * @generated from field: uint64 token_count = 4;
   */
  tokenCount = protoInt64.zero;

  /**
   * Time zone offset (number of seconds from GMT)
   *
   * @generated from field: int32 time_zone_offset = 5;
   */
  timeZoneOffset = 0;

  /**
   * Time zone abbreviation (EST, PST, GMT, etc)
   *
   * @generated from field: string time_zone_abbreviation = 6;
   */
  timeZoneAbbreviation = "";

  /**
   * @generated from field: clarifai.api.State.RunningEnvironment running_environment = 7;
   */
  runningEnvironment = State_RunningEnvironment.UNKNOWN_RUNNING_ENVIRONMENT;

  constructor(data?: PartialMessage<State>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.State";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "country_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "launch_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "time_zone_offset", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "time_zone_abbreviation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "running_environment", kind: "enum", T: proto3.getEnumType(State_RunningEnvironment) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): State {
    return new State().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): State {
    return new State().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): State {
    return new State().fromJsonString(jsonString, options);
  }

  static equals(a: State | PlainMessage<State> | undefined, b: State | PlainMessage<State> | undefined): boolean {
    return proto3.util.equals(State, a, b);
  }
}

/**
 * @generated from enum clarifai.api.State.RunningEnvironment
 */
export enum State_RunningEnvironment {
  /**
   * @generated from enum value: UNKNOWN_RUNNING_ENVIRONMENT = 0;
   */
  UNKNOWN_RUNNING_ENVIRONMENT = 0,

  /**
   * @generated from enum value: DEVELOPMENT = 1;
   */
  DEVELOPMENT = 1,

  /**
   * @generated from enum value: PRODUCTION = 2;
   */
  PRODUCTION = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(State_RunningEnvironment)
proto3.util.setEnumType(State_RunningEnvironment, "clarifai.api.State.RunningEnvironment", [
  { no: 0, name: "UNKNOWN_RUNNING_ENVIRONMENT" },
  { no: 1, name: "DEVELOPMENT" },
  { no: 2, name: "PRODUCTION" },
]);

/**
 * FindDuplicateAnnotationsJob
 *
 * @generated from message clarifai.api.FindDuplicateAnnotationsJob
 */
export class FindDuplicateAnnotationsJob extends Message<FindDuplicateAnnotationsJob> {
  /**
   * The id of this job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * What attribute will determine if a pair of annotations are duplicates
   *
   * @generated from oneof clarifai.api.FindDuplicateAnnotationsJob.comparison_attribute
   */
  comparisonAttribute: {
    /**
     * @generated from field: clarifai.api.PCAProjectionComparator pca_projection_comparator = 2;
     */
    value: PCAProjectionComparator;
    case: "pcaProjectionComparator";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * This is the result of the job. This will contain a serialized DuplicateAnnotationsResults proto.
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * Status of the job
   *
   * @generated from field: clarifai.api.status.Status status = 4;
   */
  status?: Status;

  constructor(data?: PartialMessage<FindDuplicateAnnotationsJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.FindDuplicateAnnotationsJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pca_projection_comparator", kind: "message", T: PCAProjectionComparator, oneof: "comparison_attribute" },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindDuplicateAnnotationsJob {
    return new FindDuplicateAnnotationsJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindDuplicateAnnotationsJob {
    return new FindDuplicateAnnotationsJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindDuplicateAnnotationsJob {
    return new FindDuplicateAnnotationsJob().fromJsonString(jsonString, options);
  }

  static equals(a: FindDuplicateAnnotationsJob | PlainMessage<FindDuplicateAnnotationsJob> | undefined, b: FindDuplicateAnnotationsJob | PlainMessage<FindDuplicateAnnotationsJob> | undefined): boolean {
    return proto3.util.equals(FindDuplicateAnnotationsJob, a, b);
  }
}

/**
 * @generated from message clarifai.api.DatasetInputsSearchAddJob
 */
export class DatasetInputsSearchAddJob extends Message<DatasetInputsSearchAddJob> {
  /**
   * The id of this job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the job was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * When the job was last modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * Status of the job and rough estimated progress
   *
   * @generated from field: clarifai.api.status.Status status = 4;
   */
  status?: Status;

  /**
   * Dataset which will receive inputs
   *
   * @generated from field: string dataset_id = 5;
   */
  datasetId = "";

  /**
   * The search that the job uses
   *
   * @generated from field: clarifai.api.Search search = 6;
   */
  search?: Search;

  constructor(data?: PartialMessage<DatasetInputsSearchAddJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DatasetInputsSearchAddJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "status", kind: "message", T: Status },
    { no: 5, name: "dataset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "search", kind: "message", T: Search },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatasetInputsSearchAddJob {
    return new DatasetInputsSearchAddJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatasetInputsSearchAddJob {
    return new DatasetInputsSearchAddJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatasetInputsSearchAddJob {
    return new DatasetInputsSearchAddJob().fromJsonString(jsonString, options);
  }

  static equals(a: DatasetInputsSearchAddJob | PlainMessage<DatasetInputsSearchAddJob> | undefined, b: DatasetInputsSearchAddJob | PlainMessage<DatasetInputsSearchAddJob> | undefined): boolean {
    return proto3.util.equals(DatasetInputsSearchAddJob, a, b);
  }
}

/**
 * PCAProjectionComparator
 *
 * @generated from message clarifai.api.PCAProjectionComparator
 */
export class PCAProjectionComparator extends Message<PCAProjectionComparator> {
  /**
   * Within what distance do we consider two annotations duplicates
   *
   * @generated from field: float distance_threshold = 1;
   */
  distanceThreshold = 0;

  /**
   * What cluster model version generated these
   *
   * @generated from field: string model_version_id = 2;
   */
  modelVersionId = "";

  constructor(data?: PartialMessage<PCAProjectionComparator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PCAProjectionComparator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "distance_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "model_version_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PCAProjectionComparator {
    return new PCAProjectionComparator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PCAProjectionComparator {
    return new PCAProjectionComparator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PCAProjectionComparator {
    return new PCAProjectionComparator().fromJsonString(jsonString, options);
  }

  static equals(a: PCAProjectionComparator | PlainMessage<PCAProjectionComparator> | undefined, b: PCAProjectionComparator | PlainMessage<PCAProjectionComparator> | undefined): boolean {
    return proto3.util.equals(PCAProjectionComparator, a, b);
  }
}

/**
 * DuplicateAnnotations
 *
 * @generated from message clarifai.api.DuplicateAnnotations
 */
export class DuplicateAnnotations extends Message<DuplicateAnnotations> {
  /**
   * @generated from field: clarifai.api.Annotation representative = 1;
   */
  representative?: Annotation;

  /**
   * @generated from field: repeated clarifai.api.Annotation duplicates = 2;
   */
  duplicates: Annotation[] = [];

  constructor(data?: PartialMessage<DuplicateAnnotations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DuplicateAnnotations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "representative", kind: "message", T: Annotation },
    { no: 2, name: "duplicates", kind: "message", T: Annotation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DuplicateAnnotations {
    return new DuplicateAnnotations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DuplicateAnnotations {
    return new DuplicateAnnotations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DuplicateAnnotations {
    return new DuplicateAnnotations().fromJsonString(jsonString, options);
  }

  static equals(a: DuplicateAnnotations | PlainMessage<DuplicateAnnotations> | undefined, b: DuplicateAnnotations | PlainMessage<DuplicateAnnotations> | undefined): boolean {
    return proto3.util.equals(DuplicateAnnotations, a, b);
  }
}

/**
 * DuplicateAnnotationsResults
 *
 * @generated from message clarifai.api.DuplicateAnnotationsResults
 */
export class DuplicateAnnotationsResults extends Message<DuplicateAnnotationsResults> {
  /**
   * @generated from field: repeated clarifai.api.DuplicateAnnotations results = 1;
   */
  results: DuplicateAnnotations[] = [];

  constructor(data?: PartialMessage<DuplicateAnnotationsResults>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DuplicateAnnotationsResults";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: DuplicateAnnotations, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DuplicateAnnotationsResults {
    return new DuplicateAnnotationsResults().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DuplicateAnnotationsResults {
    return new DuplicateAnnotationsResults().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DuplicateAnnotationsResults {
    return new DuplicateAnnotationsResults().fromJsonString(jsonString, options);
  }

  static equals(a: DuplicateAnnotationsResults | PlainMessage<DuplicateAnnotationsResults> | undefined, b: DuplicateAnnotationsResults | PlainMessage<DuplicateAnnotationsResults> | undefined): boolean {
    return proto3.util.equals(DuplicateAnnotationsResults, a, b);
  }
}

/**
 * Visibility represents how visible the given resource is to other users.
 * When authenticating a request we can tell if a user is a collaborator or a teammate for the
 * the app that contains the resource and set their allowed visibility. We use that to restrict
 * what they are allowed to see:
 * If AllowedVisibility is PRIVATE then we allow PRIVATE (10), ORG (30), PUBLIC (50)
 * If AllowedVisibility is ORG then we allow ORG (30), PUBLIC (50)
 * If AllowedVisibility is PUBLIC then we allow PUBLIC (50) only.
 *
 * @generated from message clarifai.api.Visibility
 */
export class Visibility extends Message<Visibility> {
  /**
   * @generated from field: clarifai.api.Visibility.Gettable gettable = 1;
   */
  gettable = Visibility_Gettable.UNKNOWN_VISIBILITY;

  constructor(data?: PartialMessage<Visibility>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Visibility";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gettable", kind: "enum", T: proto3.getEnumType(Visibility_Gettable) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Visibility {
    return new Visibility().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Visibility {
    return new Visibility().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Visibility {
    return new Visibility().fromJsonString(jsonString, options);
  }

  static equals(a: Visibility | PlainMessage<Visibility> | undefined, b: Visibility | PlainMessage<Visibility> | undefined): boolean {
    return proto3.util.equals(Visibility, a, b);
  }
}

/**
 * Gettable defined the level of access for GET operations for this resource.
 *
 * @generated from enum clarifai.api.Visibility.Gettable
 */
export enum Visibility_Gettable {
  /**
   * Default value not allowed.
   *
   * @generated from enum value: UNKNOWN_VISIBILITY = 0;
   */
  UNKNOWN_VISIBILITY = 0,

  /**
   * PRIVATE requires collaborator or team permissions in order to GET this resource.
   *
   * @generated from enum value: PRIVATE = 10;
   */
  PRIVATE = 10,

  /**
   * ORG requires you to be in the same org in order to GET this resource, but don't have to be a
   * teammate or collaborator.
   *
   * @generated from enum value: ORG = 30;
   */
  ORG = 30,

  /**
   * PUBLIC opens up GET access to the resource to any user on the platform even if they are not
   * a teammate or collaborator.
   *
   * @generated from enum value: PUBLIC = 50;
   */
  PUBLIC = 50,
}
// Retrieve enum metadata with: proto3.getEnumType(Visibility_Gettable)
proto3.util.setEnumType(Visibility_Gettable, "clarifai.api.Visibility.Gettable", [
  { no: 0, name: "UNKNOWN_VISIBILITY" },
  { no: 10, name: "PRIVATE" },
  { no: 30, name: "ORG" },
  { no: 50, name: "PUBLIC" },
]);

/**
 * TrendingMetric
 *
 * @generated from message clarifai.api.TrendingMetric
 */
export class TrendingMetric extends Message<TrendingMetric> {
  /**
   * @generated from field: string user_id = 1;
   */
  userId = "";

  /**
   * @generated from field: string app_id = 2;
   */
  appId = "";

  /**
   * @generated from field: string object_id = 3;
   */
  objectId = "";

  /**
   * @generated from field: uint64 view_count = 4;
   */
  viewCount = protoInt64.zero;

  constructor(data?: PartialMessage<TrendingMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TrendingMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "view_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrendingMetric {
    return new TrendingMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrendingMetric {
    return new TrendingMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrendingMetric {
    return new TrendingMetric().fromJsonString(jsonString, options);
  }

  static equals(a: TrendingMetric | PlainMessage<TrendingMetric> | undefined, b: TrendingMetric | PlainMessage<TrendingMetric> | undefined): boolean {
    return proto3.util.equals(TrendingMetric, a, b);
  }
}

/**
 * ValidationError
 *
 * @generated from message clarifai.api.ValidationError
 */
export class ValidationError extends Message<ValidationError> {
  /**
   * Type of validation error, one of: 'restricted', 'database' or 'format'
   *
   * @generated from field: clarifai.api.ValidationErrorType type = 1;
   */
  type = ValidationErrorType.VALIDATION_ERROR_TYPE_NOT_SET;

  /**
   * Human friendly error text
   *
   * @generated from field: string text = 2;
   */
  text = "";

  /**
   * Optional longer description of error
   *
   * @generated from field: string description = 3;
   */
  description = "";

  constructor(data?: PartialMessage<ValidationError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ValidationError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ValidationErrorType) },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationError {
    return new ValidationError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationError {
    return new ValidationError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationError {
    return new ValidationError().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationError | PlainMessage<ValidationError> | undefined, b: ValidationError | PlainMessage<ValidationError> | undefined): boolean {
    return proto3.util.equals(ValidationError, a, b);
  }
}

/**
 * Validation
 *
 * @generated from message clarifai.api.Validation
 */
export class Validation extends Message<Validation> {
  /**
   * The user_id (required for app, workflow and model id validation).
   *
   * @generated from field: string user_id = 1;
   */
  userId = "";

  /**
   * Type of object. 'app' and 'user' are supported
   *
   * @generated from field: string object_type = 2;
   */
  objectType = "";

  /**
   * Id to validate
   *
   * @generated from field: string object_id = 3;
   */
  objectId = "";

  /**
   * App id (required for workflow and model id validation).
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  constructor(data?: PartialMessage<Validation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Validation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Validation {
    return new Validation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Validation {
    return new Validation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Validation {
    return new Validation().fromJsonString(jsonString, options);
  }

  static equals(a: Validation | PlainMessage<Validation> | undefined, b: Validation | PlainMessage<Validation> | undefined): boolean {
    return proto3.util.equals(Validation, a, b);
  }
}

/**
 * ValidationResult
 *
 * @generated from message clarifai.api.ValidationResult
 */
export class ValidationResult extends Message<ValidationResult> {
  /**
   * The initial validation object that was posted
   *
   * @generated from field: clarifai.api.Validation validation = 1;
   */
  validation?: Validation;

  /**
   * List of validation errors
   *
   * @generated from field: repeated clarifai.api.ValidationError errors = 2;
   */
  errors: ValidationError[] = [];

  /**
   * List of recommended ids
   *
   * @generated from field: repeated string recommended_ids = 3;
   */
  recommendedIds: string[] = [];

  constructor(data?: PartialMessage<ValidationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ValidationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validation", kind: "message", T: Validation },
    { no: 2, name: "errors", kind: "message", T: ValidationError, repeated: true },
    { no: 3, name: "recommended_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationResult {
    return new ValidationResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationResult {
    return new ValidationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationResult {
    return new ValidationResult().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationResult | PlainMessage<ValidationResult> | undefined, b: ValidationResult | PlainMessage<ValidationResult> | undefined): boolean {
    return proto3.util.equals(ValidationResult, a, b);
  }
}

/**
 * TagCategory
 *
 * @generated from message clarifai.api.TagCategory
 */
export class TagCategory extends Message<TagCategory> {
  /**
   * Category name - use_case, license, toolkit or language
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * List of tags
   *
   * @generated from field: repeated string tags = 2;
   */
  tags: string[] = [];

  /**
   * List of full tags
   *
   * @generated from field: repeated clarifai.api.FullTag full_tags = 4;
   */
  fullTags: FullTag[] = [];

  /**
   * Does object support multiple tags of this kind
   *
   * @generated from field: bool supports_multiple = 3;
   */
  supportsMultiple = false;

  constructor(data?: PartialMessage<TagCategory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TagCategory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "full_tags", kind: "message", T: FullTag, repeated: true },
    { no: 3, name: "supports_multiple", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TagCategory {
    return new TagCategory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TagCategory {
    return new TagCategory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TagCategory {
    return new TagCategory().fromJsonString(jsonString, options);
  }

  static equals(a: TagCategory | PlainMessage<TagCategory> | undefined, b: TagCategory | PlainMessage<TagCategory> | undefined): boolean {
    return proto3.util.equals(TagCategory, a, b);
  }
}

/**
 * @generated from message clarifai.api.FullTag
 */
export class FullTag extends Message<FullTag> {
  /**
   * Display name of the tag. Ex. "English"
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Id value for referencing. Ex. "en"
   *
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<FullTag>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.FullTag";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FullTag {
    return new FullTag().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FullTag {
    return new FullTag().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FullTag {
    return new FullTag().fromJsonString(jsonString, options);
  }

  static equals(a: FullTag | PlainMessage<FullTag> | undefined, b: FullTag | PlainMessage<FullTag> | undefined): boolean {
    return proto3.util.equals(FullTag, a, b);
  }
}

/**
 * TimeSegment
 *
 * @generated from message clarifai.api.TimeSegment
 */
export class TimeSegment extends Message<TimeSegment> {
  /**
   * A unique id for the time segment.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: clarifai.api.Data data = 2;
   */
  data?: Data;

  /**
   * @generated from field: clarifai.api.TimeInfo time_info = 3;
   */
  timeInfo?: TimeInfo;

  constructor(data?: PartialMessage<TimeSegment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TimeSegment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data", kind: "message", T: Data },
    { no: 3, name: "time_info", kind: "message", T: TimeInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSegment {
    return new TimeSegment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSegment {
    return new TimeSegment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSegment {
    return new TimeSegment().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSegment | PlainMessage<TimeSegment> | undefined, b: TimeSegment | PlainMessage<TimeSegment> | undefined): boolean {
    return proto3.util.equals(TimeSegment, a, b);
  }
}

/**
 * TimeInfo
 *
 * @generated from message clarifai.api.TimeInfo
 */
export class TimeInfo extends Message<TimeInfo> {
  /**
   * Number of frames
   *
   * @generated from field: uint32 num_frames = 1;
   */
  numFrames = 0;

  /**
   * Timestamp where track begins.
   *
   * @generated from field: uint32 begin_time = 2;
   */
  beginTime = 0;

  /**
   * Timestamp where track ends.
   *
   * @generated from field: uint32 end_time = 3;
   */
  endTime = 0;

  constructor(data?: PartialMessage<TimeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.TimeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_frames", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "begin_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "end_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeInfo {
    return new TimeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeInfo {
    return new TimeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeInfo {
    return new TimeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TimeInfo | PlainMessage<TimeInfo> | undefined, b: TimeInfo | PlainMessage<TimeInfo> | undefined): boolean {
    return proto3.util.equals(TimeInfo, a, b);
  }
}

/**
 * ModelStar
 *
 * @generated from message clarifai.api.ModelStar
 */
export class ModelStar extends Message<ModelStar> {
  /**
   * Model id of the star
   *
   * @generated from field: string model_id = 1;
   */
  modelId = "";

  constructor(data?: PartialMessage<ModelStar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModelStar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelStar {
    return new ModelStar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelStar {
    return new ModelStar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelStar {
    return new ModelStar().fromJsonString(jsonString, options);
  }

  static equals(a: ModelStar | PlainMessage<ModelStar> | undefined, b: ModelStar | PlainMessage<ModelStar> | undefined): boolean {
    return proto3.util.equals(ModelStar, a, b);
  }
}

/**
 * UserStar
 *
 * @generated from message clarifai.api.UserStar
 */
export class UserStar extends Message<UserStar> {
  /**
   * User id of the star
   *
   * @generated from field: string user_id = 1;
   */
  userId = "";

  constructor(data?: PartialMessage<UserStar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UserStar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserStar {
    return new UserStar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserStar {
    return new UserStar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserStar {
    return new UserStar().fromJsonString(jsonString, options);
  }

  static equals(a: UserStar | PlainMessage<UserStar> | undefined, b: UserStar | PlainMessage<UserStar> | undefined): boolean {
    return proto3.util.equals(UserStar, a, b);
  }
}

/**
 * AppStar
 *
 * @generated from message clarifai.api.AppStar
 */
export class AppStar extends Message<AppStar> {
  /**
   * App id of the star
   *
   * @generated from field: string app_id = 1;
   */
  appId = "";

  constructor(data?: PartialMessage<AppStar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AppStar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppStar {
    return new AppStar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppStar {
    return new AppStar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppStar {
    return new AppStar().fromJsonString(jsonString, options);
  }

  static equals(a: AppStar | PlainMessage<AppStar> | undefined, b: AppStar | PlainMessage<AppStar> | undefined): boolean {
    return proto3.util.equals(AppStar, a, b);
  }
}

/**
 * WorkflowStar
 *
 * @generated from message clarifai.api.WorkflowStar
 */
export class WorkflowStar extends Message<WorkflowStar> {
  /**
   * Workflow id of the star
   *
   * @generated from field: string workflow_id = 1;
   */
  workflowId = "";

  constructor(data?: PartialMessage<WorkflowStar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WorkflowStar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowStar {
    return new WorkflowStar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowStar {
    return new WorkflowStar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowStar {
    return new WorkflowStar().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowStar | PlainMessage<WorkflowStar> | undefined, b: WorkflowStar | PlainMessage<WorkflowStar> | undefined): boolean {
    return proto3.util.equals(WorkflowStar, a, b);
  }
}

/**
 * @generated from message clarifai.api.WebNotification
 */
export class WebNotification extends Message<WebNotification> {
  /**
   * Id of notification
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The full description of notification. Will not be returned from List endpoint
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Short summary of notification. Max 100 characters
   *
   * @generated from field: string summary = 3;
   */
  summary = "";

  /**
   * Title of notification
   *
   * @generated from field: string title = 4;
   */
  title = "";

  /**
   * when was the notification created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * when was the notification read by user. Unread if not set.
   *
   * @generated from field: google.protobuf.Timestamp read_at = 6;
   */
  readAt?: Timestamp;

  constructor(data?: PartialMessage<WebNotification>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WebNotification";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "read_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebNotification {
    return new WebNotification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebNotification {
    return new WebNotification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebNotification {
    return new WebNotification().fromJsonString(jsonString, options);
  }

  static equals(a: WebNotification | PlainMessage<WebNotification> | undefined, b: WebNotification | PlainMessage<WebNotification> | undefined): boolean {
    return proto3.util.equals(WebNotification, a, b);
  }
}

/**
 * @generated from message clarifai.api.PatchWebNotification
 */
export class PatchWebNotification extends Message<PatchWebNotification> {
  /**
   * Id of notification
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Should the notification be marked as read. Marked as unread if not set or false.
   *
   * @generated from field: bool is_read = 2;
   */
  isRead = false;

  constructor(data?: PartialMessage<PatchWebNotification>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.PatchWebNotification";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_read", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PatchWebNotification {
    return new PatchWebNotification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PatchWebNotification {
    return new PatchWebNotification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PatchWebNotification {
    return new PatchWebNotification().fromJsonString(jsonString, options);
  }

  static equals(a: PatchWebNotification | PlainMessage<PatchWebNotification> | undefined, b: PatchWebNotification | PlainMessage<PatchWebNotification> | undefined): boolean {
    return proto3.util.equals(PatchWebNotification, a, b);
  }
}

/**
 * An app module that a user created in our app module marketplace.
 *
 * @generated from message clarifai.api.Module
 */
export class Module extends Message<Module> {
  /**
   * A unique ID for this app module.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * A short description for this app module to be used in grids of modules.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * When the app module was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  /**
   * When the app module was last modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 5;
   */
  modifiedAt?: Timestamp;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   * Defaults to PRIVATE if not provided.
   *
   * @generated from field: clarifai.api.Visibility visibility = 7;
   */
  visibility?: Visibility;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   * This is an optional arg.
   *
   * @generated from field: google.protobuf.Struct metadata = 8;
   */
  metadata?: Struct;

  /**
   * The creator of the app module.
   *
   * @generated from field: string user_id = 9;
   */
  userId = "";

  /**
   * The app_id this module was created in.
   *
   * @generated from field: string app_id = 10;
   */
  appId = "";

  constructor(data?: PartialMessage<Module>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Module";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "created_at", kind: "message", T: Timestamp },
    { no: 5, name: "modified_at", kind: "message", T: Timestamp },
    { no: 7, name: "visibility", kind: "message", T: Visibility },
    { no: 8, name: "metadata", kind: "message", T: Struct },
    { no: 9, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Module {
    return new Module().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJsonString(jsonString, options);
  }

  static equals(a: Module | PlainMessage<Module> | undefined, b: Module | PlainMessage<Module> | undefined): boolean {
    return proto3.util.equals(Module, a, b);
  }
}

/**
 * A specific version of an app module that is available for assigning to apps.
 *
 * @generated from message clarifai.api.ModuleVersion
 */
export class ModuleVersion extends Message<ModuleVersion> {
  /**
   * A name for this version like 1_0, 1_1_0, etc.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The module this version belongs to.
   *
   * @generated from field: string module_id = 2;
   */
  moduleId = "";

  /**
   * The app_id this module version belongs to.
   *
   * @generated from field: string app_id = 3;
   */
  appId = "";

  /**
   * The user_id this module version belongs to.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * A short description for this version.
   *
   * @generated from field: string description = 6;
   */
  description = "";

  /**
   * A markdown formatted string to detailed description of the app module.
   * This is within each version so that it can be change version to version.
   *
   * @generated from field: string notes = 7;
   */
  notes = "";

  /**
   * When the app module version was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the app module version was last modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 9;
   */
  modifiedAt?: Timestamp;

  /**
   * The code repo of the streamlit app.
   * If you are still developing your Module you should create a ModuleVersion
   * with an empty git_commit_url and then create an InstalledModuleVersion
   * with a pre-deployed deploy_url (such as localhost or streamlit cloud).
   * Once you are ready to create a production, create a new ModuleVersion with
   * the ready git url to a specific commit that you would like to be reviewed by the
   * Clarifai team for approval within our community. You cannot publish a ModuleVersion
   * is reviewed and approved. Please only provide the git_commit_url when you're
   * ready for a review. This url needs to include a specific commit, for example:
   * https://github.com/user/repo/commit/767ff9c08ba3429c8e7b8825da148555
   *
   * @generated from field: string git_commit_url = 10;
   */
  gitCommitUrl = "";

  /**
   * @generated from field: clarifai.api.ModuleVersion.ModuleNav module_nav = 11;
   */
  moduleNav?: ModuleVersion_ModuleNav;

  /**
   * A boolean to mark if Clarifai has approved this app version.
   * This cannot be set in the request to True.
   *
   * @generated from field: bool approved = 12;
   */
  approved = false;

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible.
   * Defaults to PRIVATE if not provided.
   *
   * @generated from field: clarifai.api.Visibility visibility = 13;
   */
  visibility?: Visibility;

  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   * This is an optional arg.
   *
   * @generated from field: google.protobuf.Struct metadata = 14;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<ModuleVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModuleVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "modified_at", kind: "message", T: Timestamp },
    { no: 10, name: "git_commit_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "module_nav", kind: "message", T: ModuleVersion_ModuleNav },
    { no: 12, name: "approved", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "visibility", kind: "message", T: Visibility },
    { no: 14, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleVersion {
    return new ModuleVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleVersion {
    return new ModuleVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleVersion {
    return new ModuleVersion().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleVersion | PlainMessage<ModuleVersion> | undefined, b: ModuleVersion | PlainMessage<ModuleVersion> | undefined): boolean {
    return proto3.util.equals(ModuleVersion, a, b);
  }
}

/**
 * @generated from message clarifai.api.ModuleVersion.ModuleSubNav
 */
export class ModuleVersion_ModuleSubNav extends Message<ModuleVersion_ModuleSubNav> {
  /**
   * This is the display title for a navbar element to link to a specific page.
   * The name for this subnav element to show in the sidebar.
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * The query param name
   *
   * @generated from field: string query_key = 2;
   */
  queryKey = "";

  /**
   * The query param value
   *
   * @generated from field: string query_value = 3;
   */
  queryValue = "";

  constructor(data?: PartialMessage<ModuleVersion_ModuleSubNav>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModuleVersion.ModuleSubNav";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "query_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleVersion_ModuleSubNav {
    return new ModuleVersion_ModuleSubNav().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleVersion_ModuleSubNav {
    return new ModuleVersion_ModuleSubNav().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleVersion_ModuleSubNav {
    return new ModuleVersion_ModuleSubNav().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleVersion_ModuleSubNav | PlainMessage<ModuleVersion_ModuleSubNav> | undefined, b: ModuleVersion_ModuleSubNav | PlainMessage<ModuleVersion_ModuleSubNav> | undefined): boolean {
    return proto3.util.equals(ModuleVersion_ModuleSubNav, a, b);
  }
}

/**
 * @generated from message clarifai.api.ModuleVersion.ModuleNav
 */
export class ModuleVersion_ModuleNav extends Message<ModuleVersion_ModuleNav> {
  /**
   * This is the left side title for this module and for browser tab title of the module.
   * We have this in the version so that users can change those settings
   * when releasing a new version of their module.
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * A list of subnav elements to put under the module title.
   *
   * @generated from field: repeated clarifai.api.ModuleVersion.ModuleSubNav module_sub_navs = 2;
   */
  moduleSubNavs: ModuleVersion_ModuleSubNav[] = [];

  constructor(data?: PartialMessage<ModuleVersion_ModuleNav>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.ModuleVersion.ModuleNav";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module_sub_navs", kind: "message", T: ModuleVersion_ModuleSubNav, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleVersion_ModuleNav {
    return new ModuleVersion_ModuleNav().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleVersion_ModuleNav {
    return new ModuleVersion_ModuleNav().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleVersion_ModuleNav {
    return new ModuleVersion_ModuleNav().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleVersion_ModuleNav | PlainMessage<ModuleVersion_ModuleNav> | undefined, b: ModuleVersion_ModuleNav | PlainMessage<ModuleVersion_ModuleNav> | undefined): boolean {
    return proto3.util.equals(ModuleVersion_ModuleNav, a, b);
  }
}

/**
 * @generated from message clarifai.api.InstalledModuleVersion
 */
export class InstalledModuleVersion extends Message<InstalledModuleVersion> {
  /**
   * A unique id for this install. This will be used in the browser url.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The installed module version provided here so that we users don't need to do an additional
   * fetch. When creating a new InstalledModuleVersion you should provide the:
   * module_version.user_id
   * module_version.app_id
   * module_version.module_id
   * module_version.id
   * in order to uniquely define which module version.
   *
   * @generated from field: clarifai.api.ModuleVersion module_version = 2;
   */
  moduleVersion?: ModuleVersion;

  /**
   * The app_id the ModuleVersion is installed into (not necessary where the ModuleVersion was
   * created). This doesn't have to be provided in requests to install, but will be returned in
   * responses.
   *
   * @generated from field: string app_id = 3;
   */
  appId = "";

  /**
   * The user that the app belongs to where the ModuleVersion is installed into (not necessary where
   * the ModuleVersion was created). This doesn't have to be provided in requests to install, but
   * will be returned in responses.
   *
   * @generated from field: string user_id = 4;
   */
  userId = "";

  /**
   * When the install was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * When the install was last modified.
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 6;
   */
  modifiedAt?: Timestamp;

  /**
   * The URL of where this app module version is deployed.
   * If you provide this deploy_url when creating the install then it will
   * be treated as a pre-deployed module. You can only use a pre-deployed module
   * in when installing to an app_id that you own as the creator of the module.
   * If you want to install someone elses module or to rely on Clarifai deploying
   * your module for you, leave deploy_url empty when creating the install.
   * If it is left empty, then deployment will occur when this module version is
   * installed into an app using the git_commit_url of the ModuleVersion.
   *
   * @generated from field: string deploy_url = 7;
   */
  deployUrl = "";

  /**
   * The visibility field represents whether this message is privately/publicly visible.
   * To be visible to the public the App that contains it AND the User that contains the App must
   * also be publicly visible. For the InstalledModuleVersion this allows the app owner who
   * installed the module version to decide if they want other users of their app to have
   * the added functionality that the modules version provides to their app.
   * Defaults to PRIVATE if not provided.
   *
   * @generated from field: clarifai.api.Visibility visibility = 8;
   */
  visibility?: Visibility;

  /**
   * The key ID to use for making requests to the API for this module.
   * This key is associated to this installed module version by PostInstalledModuleVersionsKey
   * request. The key is associated with the CALLER not the App Owner where this module is installed
   * nor the author of the module. This allows the module to act on behalf of the caller at all
   * times so we get proper permissions the caller has (such as if they are stranger, teammate or
   * collaborator). This key should be a personal access token to enable modules to work across apps
   * and have necessary abilities beyond what app-specific keys offer.
   *
   * @generated from field: string key_id = 9;
   */
  keyId = "";

  constructor(data?: PartialMessage<InstalledModuleVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InstalledModuleVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module_version", kind: "message", T: ModuleVersion },
    { no: 3, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "modified_at", kind: "message", T: Timestamp },
    { no: 7, name: "deploy_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "visibility", kind: "message", T: Visibility },
    { no: 9, name: "key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstalledModuleVersion {
    return new InstalledModuleVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstalledModuleVersion {
    return new InstalledModuleVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstalledModuleVersion {
    return new InstalledModuleVersion().fromJsonString(jsonString, options);
  }

  static equals(a: InstalledModuleVersion | PlainMessage<InstalledModuleVersion> | undefined, b: InstalledModuleVersion | PlainMessage<InstalledModuleVersion> | undefined): boolean {
    return proto3.util.equals(InstalledModuleVersion, a, b);
  }
}

/**
 * @generated from message clarifai.api.BulkOperation
 */
export class BulkOperation extends Message<BulkOperation> {
  /**
   * id of the Bulk Operation task
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Input Source could be list of input ids or a Search whose results will be a list of input ids.
   * InputIDs:
   *      List of input ids to which operation to be applied
   * clarifai.api.Search:
   *      A Search(either filter or rank with min value) to allow filtering down the entire app's
   *      sub-assets(image, region in image, frame in video, region in frame in video)
   *      and perform operation to only the results of this search query. See our search
   *      documentation for more details about the search Query message.
   *      For eg., filters the asset/sub-asset matching the search and performs specified operation.
   *
   * @generated from oneof clarifai.api.BulkOperation.input_source
   */
  inputSource: {
    /**
     * @generated from field: clarifai.api.InputIDs input_ids = 2;
     */
    value: InputIDs;
    case: "inputIds";
  } | {
    /**
     * @generated from field: clarifai.api.Search search = 10;
     */
    value: Search;
    case: "search";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Operation to perform
   *
   * @generated from field: clarifai.api.Operation operation = 3;
   */
  operation?: Operation;

  /**
   * Application ID that this Operation was created from
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * Status (pending, in-progress, completed, failed) of the operation
   *
   * @generated from field: clarifai.api.status.Status status = 5;
   */
  status?: Status;

  /**
   * Progress of an on-going Bulk Operation task
   *
   * @generated from field: clarifai.api.Progress progress = 6;
   */
  progress?: Progress;

  /**
   * User id that created this operation
   *
   * @generated from field: string created_by = 7;
   */
  createdBy = "";

  /**
   * When the operation was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * Last time the status got updated
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 9;
   */
  lastModifiedAt?: Timestamp;

  constructor(data?: PartialMessage<BulkOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.BulkOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input_ids", kind: "message", T: InputIDs, oneof: "input_source" },
    { no: 10, name: "search", kind: "message", T: Search, oneof: "input_source" },
    { no: 3, name: "operation", kind: "message", T: Operation },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "status", kind: "message", T: Status },
    { no: 6, name: "progress", kind: "message", T: Progress },
    { no: 7, name: "created_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "last_modified_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkOperation {
    return new BulkOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkOperation {
    return new BulkOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkOperation {
    return new BulkOperation().fromJsonString(jsonString, options);
  }

  static equals(a: BulkOperation | PlainMessage<BulkOperation> | undefined, b: BulkOperation | PlainMessage<BulkOperation> | undefined): boolean {
    return proto3.util.equals(BulkOperation, a, b);
  }
}

/**
 * @generated from message clarifai.api.InputIDs
 */
export class InputIDs extends Message<InputIDs> {
  /**
   * @generated from field: repeated string input_ids = 1;
   */
  inputIds: string[] = [];

  constructor(data?: PartialMessage<InputIDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InputIDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "input_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputIDs {
    return new InputIDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputIDs {
    return new InputIDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputIDs {
    return new InputIDs().fromJsonString(jsonString, options);
  }

  static equals(a: InputIDs | PlainMessage<InputIDs> | undefined, b: InputIDs | PlainMessage<InputIDs> | undefined): boolean {
    return proto3.util.equals(InputIDs, a, b);
  }
}

/**
 * @generated from message clarifai.api.Progress
 */
export class Progress extends Message<Progress> {
  /**
   * @generated from field: uint32 processed = 1;
   */
  processed = 0;

  /**
   * @generated from field: string last_processed_id = 2;
   */
  lastProcessedId = "";

  constructor(data?: PartialMessage<Progress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Progress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processed", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "last_processed_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Progress {
    return new Progress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Progress {
    return new Progress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Progress {
    return new Progress().fromJsonString(jsonString, options);
  }

  static equals(a: Progress | PlainMessage<Progress> | undefined, b: Progress | PlainMessage<Progress> | undefined): boolean {
    return proto3.util.equals(Progress, a, b);
  }
}

/**
 * @generated from message clarifai.api.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * Bulk Operations supported:
   * Concepts:
   *    Operations: add_concepts, delete_concepts
   *    AddConcepts:
   *        If new concepts are given, add concepts operation creates new concepts in the app and adds them to the given inputs' annotations.
   *        If the given concept already exist, the label value of the concept is updated with the given value.
   *    DeleteConcepts:
   *        Remove the matching concept(s) for all the inputs in input source (mentioned above).
   *    Input Source:
   *        Input ids of assets(images) (or) search on sub-assets(region in image, frame in video, region in frame in video)
   * Metadata:
   *    Operations: add_metadata, delete_metadata
   *    AddMetadata:
   *        Add the provided metadata to the input level annotation for all the inputs in input source (mentioned above).
   *        If the key(s) already exists, it will overwrite the key(s) with the corresponding new value(s).
   *    DeleteMetadata:
   *        Remove the key, value pairs that match the given metadata from the existing input level Annotations' metadata
   *        for all the inputs in input source (mentioned above).
   *    Input Source:
   *        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
   * Geo:
   *    Operations: overwrite_geo, delete_geo
   *    OverwriteGeo:
   *        Add the provided geo info for all the inputs in input source (mentioned above).
   *    DeleteGeo:
   *        Delete Geo info for all the inputs in input source (mentioned above).
   *    Input Source:
   *        Input ids of assets(images, videos) (or) search on sub-assets(region in image, frame in video, region in frame in video)
   *
   * @generated from oneof clarifai.api.Operation.operation
   */
  operation: {
    /**
     * @generated from field: clarifai.api.AddConcepts add_concepts = 1;
     */
    value: AddConcepts;
    case: "addConcepts";
  } | {
    /**
     * @generated from field: clarifai.api.DeleteConcepts delete_concepts = 2;
     */
    value: DeleteConcepts;
    case: "deleteConcepts";
  } | {
    /**
     * @generated from field: clarifai.api.AddMetadata add_metadata = 3;
     */
    value: AddMetadata;
    case: "addMetadata";
  } | {
    /**
     * @generated from field: clarifai.api.DeleteMetadata delete_metadata = 4;
     */
    value: DeleteMetadata;
    case: "deleteMetadata";
  } | {
    /**
     * @generated from field: clarifai.api.OverwriteGeo overwrite_geo = 5;
     */
    value: OverwriteGeo;
    case: "overwriteGeo";
  } | {
    /**
     * @generated from field: clarifai.api.DeleteGeo delete_geo = 6;
     */
    value: DeleteGeo;
    case: "deleteGeo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "add_concepts", kind: "message", T: AddConcepts, oneof: "operation" },
    { no: 2, name: "delete_concepts", kind: "message", T: DeleteConcepts, oneof: "operation" },
    { no: 3, name: "add_metadata", kind: "message", T: AddMetadata, oneof: "operation" },
    { no: 4, name: "delete_metadata", kind: "message", T: DeleteMetadata, oneof: "operation" },
    { no: 5, name: "overwrite_geo", kind: "message", T: OverwriteGeo, oneof: "operation" },
    { no: 6, name: "delete_geo", kind: "message", T: DeleteGeo, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * @generated from message clarifai.api.AddConcepts
 */
export class AddConcepts extends Message<AddConcepts> {
  /**
   * @generated from field: repeated clarifai.api.Concept concepts = 1;
   */
  concepts: Concept[] = [];

  constructor(data?: PartialMessage<AddConcepts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AddConcepts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concepts", kind: "message", T: Concept, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddConcepts {
    return new AddConcepts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddConcepts {
    return new AddConcepts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddConcepts {
    return new AddConcepts().fromJsonString(jsonString, options);
  }

  static equals(a: AddConcepts | PlainMessage<AddConcepts> | undefined, b: AddConcepts | PlainMessage<AddConcepts> | undefined): boolean {
    return proto3.util.equals(AddConcepts, a, b);
  }
}

/**
 * @generated from message clarifai.api.DeleteConcepts
 */
export class DeleteConcepts extends Message<DeleteConcepts> {
  /**
   * @generated from field: repeated clarifai.api.Concept concepts = 1;
   */
  concepts: Concept[] = [];

  constructor(data?: PartialMessage<DeleteConcepts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DeleteConcepts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "concepts", kind: "message", T: Concept, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteConcepts {
    return new DeleteConcepts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteConcepts {
    return new DeleteConcepts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteConcepts {
    return new DeleteConcepts().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteConcepts | PlainMessage<DeleteConcepts> | undefined, b: DeleteConcepts | PlainMessage<DeleteConcepts> | undefined): boolean {
    return proto3.util.equals(DeleteConcepts, a, b);
  }
}

/**
 * @generated from message clarifai.api.AddMetadata
 */
export class AddMetadata extends Message<AddMetadata> {
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 1;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<AddMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.AddMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddMetadata {
    return new AddMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddMetadata {
    return new AddMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddMetadata {
    return new AddMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AddMetadata | PlainMessage<AddMetadata> | undefined, b: AddMetadata | PlainMessage<AddMetadata> | undefined): boolean {
    return proto3.util.equals(AddMetadata, a, b);
  }
}

/**
 * @generated from message clarifai.api.DeleteMetadata
 */
export class DeleteMetadata extends Message<DeleteMetadata> {
  /**
   * To handle arbitrary json metadata you can use a struct field:
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
   *
   * @generated from field: google.protobuf.Struct metadata = 1;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<DeleteMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DeleteMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteMetadata {
    return new DeleteMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteMetadata {
    return new DeleteMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteMetadata {
    return new DeleteMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteMetadata | PlainMessage<DeleteMetadata> | undefined, b: DeleteMetadata | PlainMessage<DeleteMetadata> | undefined): boolean {
    return proto3.util.equals(DeleteMetadata, a, b);
  }
}

/**
 * @generated from message clarifai.api.OverwriteGeo
 */
export class OverwriteGeo extends Message<OverwriteGeo> {
  /**
   * Geo info
   *
   * @generated from field: clarifai.api.Geo geo = 1;
   */
  geo?: Geo;

  constructor(data?: PartialMessage<OverwriteGeo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.OverwriteGeo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "geo", kind: "message", T: Geo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverwriteGeo {
    return new OverwriteGeo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverwriteGeo {
    return new OverwriteGeo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverwriteGeo {
    return new OverwriteGeo().fromJsonString(jsonString, options);
  }

  static equals(a: OverwriteGeo | PlainMessage<OverwriteGeo> | undefined, b: OverwriteGeo | PlainMessage<OverwriteGeo> | undefined): boolean {
    return proto3.util.equals(OverwriteGeo, a, b);
  }
}

/**
 * @generated from message clarifai.api.DeleteGeo
 */
export class DeleteGeo extends Message<DeleteGeo> {
  constructor(data?: PartialMessage<DeleteGeo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.DeleteGeo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteGeo {
    return new DeleteGeo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteGeo {
    return new DeleteGeo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteGeo {
    return new DeleteGeo().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteGeo | PlainMessage<DeleteGeo> | undefined, b: DeleteGeo | PlainMessage<DeleteGeo> | undefined): boolean {
    return proto3.util.equals(DeleteGeo, a, b);
  }
}

/**
 * WaitlistEmail is an e-mail address on a feature waiting list.
 *
 * Note that 'created_at' is explicitly NOT included in the API resources
 * returned by unauthenticated PostWaitlistEmails requests. Otherwise, the
 * timestamp could be used to determine if the e-mail was already on the
 * feature waiting list, leaking the contents of the list.
 *
 * @generated from message clarifai.api.WaitlistEmail
 */
export class WaitlistEmail extends Message<WaitlistEmail> {
  /**
   * @generated from field: string email = 1;
   */
  email = "";

  constructor(data?: PartialMessage<WaitlistEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.WaitlistEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitlistEmail {
    return new WaitlistEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitlistEmail {
    return new WaitlistEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitlistEmail {
    return new WaitlistEmail().fromJsonString(jsonString, options);
  }

  static equals(a: WaitlistEmail | PlainMessage<WaitlistEmail> | undefined, b: WaitlistEmail | PlainMessage<WaitlistEmail> | undefined): boolean {
    return proto3.util.equals(WaitlistEmail, a, b);
  }
}

/**
 * @generated from message clarifai.api.InputsAddJob
 */
export class InputsAddJob extends Message<InputsAddJob> {
  /**
   * id of the job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Cloud storage url from which the inputs can be accessed.
   * Supported providers are AWS S3, Azure blob, GCP cloud storage.
   *
   * @generated from field: string cloud_storage_url = 2;
   */
  cloudStorageUrl = "";

  /**
   * If call back url is set, we will send a Post request to this endpoint with job status.
   *
   * @generated from field: string call_back_url = 3;
   */
  callBackUrl = "";

  /**
   * Personal Access Token to the application to which inputs are added
   *
   * @generated from field: string app_pat = 4;
   */
  appPat = "";

  /**
   * Application ID that this job was created from
   *
   * @generated from field: string app_id = 5;
   */
  appId = "";

  /**
   * Status (pending, in-progress, completed, failed) of the operation
   *
   * @generated from field: clarifai.api.status.Status status = 6;
   */
  status?: Status;

  /**
   * Progress of an on-going Input Ingestion task
   *
   * @generated from field: clarifai.api.InputsAddJobProgress progress = 7;
   */
  progress?: InputsAddJobProgress;

  /**
   * When the operation was created. We follow the XXXX timestamp
   * format. We use https://www.ietf.org/rfc/rfc3339.txt format:
   * "2006-01-02T15:04:05.999999Z" so you can expect results like
   * the following from the API:
   * "2017-04-11T21:50:50.223962Z"
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * Last time the status got updated
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 9;
   */
  lastModifiedAt?: Timestamp;

  constructor(data?: PartialMessage<InputsAddJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InputsAddJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cloud_storage_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "call_back_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "app_pat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "status", kind: "message", T: Status },
    { no: 7, name: "progress", kind: "message", T: InputsAddJobProgress },
    { no: 8, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "last_modified_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputsAddJob {
    return new InputsAddJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputsAddJob {
    return new InputsAddJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputsAddJob {
    return new InputsAddJob().fromJsonString(jsonString, options);
  }

  static equals(a: InputsAddJob | PlainMessage<InputsAddJob> | undefined, b: InputsAddJob | PlainMessage<InputsAddJob> | undefined): boolean {
    return proto3.util.equals(InputsAddJob, a, b);
  }
}

/**
 * @generated from message clarifai.api.InputsAddJobProgress
 */
export class InputsAddJobProgress extends Message<InputsAddJobProgress> {
  constructor(data?: PartialMessage<InputsAddJobProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.InputsAddJobProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InputsAddJobProgress {
    return new InputsAddJobProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InputsAddJobProgress {
    return new InputsAddJobProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InputsAddJobProgress {
    return new InputsAddJobProgress().fromJsonString(jsonString, options);
  }

  static equals(a: InputsAddJobProgress | PlainMessage<InputsAddJobProgress> | undefined, b: InputsAddJobProgress | PlainMessage<InputsAddJobProgress> | undefined): boolean {
    return proto3.util.equals(InputsAddJobProgress, a, b);
  }
}

/**
 * @generated from message clarifai.api.Upload
 */
export class Upload extends Message<Upload> {
  /**
   * ID of upload, name of uploaded file
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * When the upload was started.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Most recent time when the upload was updated.
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp modified_at = 3;
   */
  modifiedAt?: Timestamp;

  /**
   * When the upload will expire and be deleted
   * The format is https://www.ietf.org/rfc/rfc3339.txt.
   * Example: "2006-01-02T15:04:05.999999Z".
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 4;
   */
  expiresAt?: Timestamp;

  /**
   * Status of the upload
   *
   * @generated from field: clarifai.api.status.Status status = 5;
   */
  status?: Status;

  /**
   * Total size of the upload content
   *
   * @generated from field: uint64 content_length = 6;
   */
  contentLength = protoInt64.zero;

  /**
   * Url of uploaded content
   *
   * @generated from field: string content_url = 7;
   */
  contentUrl = "";

  constructor(data?: PartialMessage<Upload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.Upload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "modified_at", kind: "message", T: Timestamp },
    { no: 4, name: "expires_at", kind: "message", T: Timestamp },
    { no: 5, name: "status", kind: "message", T: Status },
    { no: 6, name: "content_length", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "content_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Upload {
    return new Upload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Upload {
    return new Upload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Upload {
    return new Upload().fromJsonString(jsonString, options);
  }

  static equals(a: Upload | PlainMessage<Upload> | undefined, b: Upload | PlainMessage<Upload> | undefined): boolean {
    return proto3.util.equals(Upload, a, b);
  }
}

/**
 * @generated from message clarifai.api.UploadContentPart
 */
export class UploadContentPart extends Message<UploadContentPart> {
  /**
   * @generated from field: uint64 range_start = 1;
   */
  rangeStart = protoInt64.zero;

  /**
   * @generated from field: int64 part_number = 2;
   */
  partNumber = protoInt64.zero;

  /**
   * @generated from field: bytes data = 3;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<UploadContentPart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "clarifai.api.UploadContentPart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range_start", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "part_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadContentPart {
    return new UploadContentPart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadContentPart {
    return new UploadContentPart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadContentPart {
    return new UploadContentPart().fromJsonString(jsonString, options);
  }

  static equals(a: UploadContentPart | PlainMessage<UploadContentPart> | undefined, b: UploadContentPart | PlainMessage<UploadContentPart> | undefined): boolean {
    return proto3.util.equals(UploadContentPart, a, b);
  }
}

