/////////////////////////////////////////////// WARNING ///////////////////////////////////////////////
// Be aware that if you decide to add comments to this or any other non-private file, they could     //
// end up in our *public* auto-generated swagger documentation. In order to ensure that your         //
// comments are not included in our swagger docs, put one line of whitespace between your comment    //
// and any proto definitions.                                                                        //
///////////////////////////////////////////////////////////////////////////////////////////////////////


syntax = "proto3";

import "proto/clarifai/api/resources.proto";
import "proto/clarifai/api/status/status.proto";
import "proto/clarifai/api/utils/extensions.proto";
import "proto/clarifai/auth/scope/scope.proto";
import "proto/clarifai/auth/util/extension.proto";
import "proto/clarifai/commands/commands.proto";
import "proto/clarifai/api/status/status_code.proto";


import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";


package clarifai.api;

option go_package = "clarifai/api";
option java_multiple_files = true;
option java_package = "com.clarifai.grpc.api";
option objc_class_prefix = "CAIP";

/*
  Note: this is based on the google api format defined here. Please
  read this before contributing to this file and other *.proto files
  for the API.
  https://cloud.google.com/service-management/reference/rpc/google.api#google.api.HttpRule

  For the cl_depending_scopes in this file, see the docstring that explains the two types of
  scope dependencies in clarifai/auth/scope/scope.proto

  For new endpoints you should typically only add the fully qualified url that includes the user_id
  and app_id.

  You should typicaly use KeyAuth (the most restricted auth type) for new endpoints unless they are
  for resources not contained in an app or need access from things across apps. See more about the
  auth types here:
  https://clarifai.atlassian.net/wiki/spaces/TT/pages/1821409336/API+Authorizers+and+Resource+Access

 */

message TestMessage {
  clarifai.api.status.Status status = 1;
  string value = 2;
  bytes byts = 3;
  uint32 int_32 = 4;
  uint64 int_64 = 5;
  float f_32 = 6;
  double f_64 = 7;

  // To handle arbitrary json you can use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  google.protobuf.Struct s = 8;
}

// V2
service V2 {

  // Common echo example.
  rpc Echo (TestMessage) returns (TestMessage) {
    option (google.api.http) = {
      post: "/v2/example/echo"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List concept relations between concepts in the platform.
  // MUST be above ListConcepts so that if concept_id is empty this will still match
  // /concepts/relations to list all the concept relations in the app.
  rpc ListConceptRelations (ListConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/relations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }


  // Post concept relations to create relations between concepts in the platform.
  rpc PostConceptRelations (PostConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept relations to create relations between concepts in the platform.
  rpc DeleteConceptRelations (DeleteConceptRelationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts with their positive and negative counts
  rpc GetConceptCounts (GetConceptCountsRequest) returns (MultiConceptCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/status"
      additional_bindings {
        get: "/v2/concepts/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific concept from an app.
  rpc GetConcept (GetConceptRequest) returns (SingleConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts.
  rpc ListConcepts (ListConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      additional_bindings {
        get: "/v2/concepts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Search over the concepts to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostConceptsSearches (PostConceptsSearchesRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/searches"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Add a concept to an app.
  rpc PostConcepts (PostConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        post: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more concepts.
  rpc PatchConcepts (PatchConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Get a specific vocab from an app.
  rpc GetVocab (GetVocabRequest) returns (SingleVocabResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}"
      additional_bindings {
        get: "/v2/vocabs/{vocab_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the vocabs.
  rpc ListVocabs (ListVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      additional_bindings {
        get: "/v2/vocabs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a vocab to an app.
  rpc PostVocabs (PostVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings {
        post: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more vocabs.
  rpc PatchVocabs (PatchVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings {
        patch: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete a single vocab.
  rpc DeleteVocab (DeleteVocabRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}"
      additional_bindings {
        delete: "/v2/vocabs/{vocab_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete multiple vocabs in one request.
  rpc DeleteVocabs (DeleteVocabsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings {
        delete: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the vocabs.
  rpc ListVocabConcepts (ListVocabConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      additional_bindings {
        get: "/v2/vocabs/{vocab_id}/concepts"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a vocab to an app.
  rpc PostVocabConcepts (PostVocabConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      body: "*"
      additional_bindings {
        post: "/v2/vocabs/{vocab_id}/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete a single concept from a vocab.
  rpc DeleteVocabConcept (DeleteVocabConceptRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts/{concept_id}"
      additional_bindings {
        delete: "/v2/vocabs/{vocab_id}/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete multiple concepts from a vocab in one request.
  rpc DeleteVocabConcepts (DeleteVocabConceptsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      body: "*"
      additional_bindings {
        delete: "/v2/vocabs/{vocab_id}/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Get a specific concept from an app.
  rpc GetConceptLanguage (GetConceptLanguageRequest) returns (SingleConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages/{language}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List the concept in all the translated languages.
  rpc ListConceptLanguages (ListConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/languages"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a new translation for this concept.
  rpc PostConceptLanguages (PostConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch the name for a given language names by passing in a list of concepts with the new names
  // for the languages.
  rpc PatchConceptLanguages (PatchConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings {
        patch: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // TODO(zeiler): we don't have a way to delete the languages currently. This should be rare
  // anyways as users should just patch translations to the right naming.
  // // Delete a single concept translation.
  // rpc DeleteConceptLanguage(DeleteConceptLanguageRequest) returns (clarifai.api.status.BaseResponse) {
  //   option (google.api.http) = {
  //     delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
  //     additional_bindings {
  //       delete: "/v2/concepts/{concept_id}/languages/{language}"
  //     }
  //   };
  // }

  // // Delete multiple concept translations in one request.
  // rpc DeleteConceptLanguages(DeleteConceptLanguagesRequest) returns (clarifai.api.status.BaseResponse) {
  //   option (google.api.http) = {
  //     delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
  //     body: "*"
  //     additional_bindings {
  //       delete: "/v2/concepts/{concept_id}/languages"
  //       body: "*"
  //     }
  //   };
  // }

  // List the concept in all the outside sources where we found these concepts.
  rpc ListConceptReferences (ListConceptReferencesRequest) returns (MultiConceptReferenceResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/references"
      additional_bindings {
        get: "/v2/concepts/{concept_id}/references"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all domain graphs.
  rpc ListKnowledgeGraphs (ListKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      additional_bindings {
        get: "/v2/concepts/knowledge_graphs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post domain graphs.
  rpc PostKnowledgeGraphs (PostKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/knowledge_graphs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Start concept mapping jobs.
  rpc PostConceptMappingJobs (PostConceptMappingJobsRequest) returns (MultiConceptMappingJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/mappings/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all concept mappings for a given concept id.
  rpc ListConceptMappings (ListConceptMappingsRequest) returns (MultiConceptMappingResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings"
      additional_bindings {
        get: "/v2/concepts/mappings"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept mappings.
  rpc PostConceptMappings (PostConceptMappingsRequest) returns (MultiConceptMappingResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings"
      body: "*"
      additional_bindings {
        post: "/v2/concepts/mappings"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Get a specific annotation from an app.
  rpc GetAnnotation (GetAnnotationRequest) returns (SingleAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // List all the annotation.
  rpc ListAnnotations (ListAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      additional_bindings {
        get: "/v2/annotations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Post annotations.
  rpc PostAnnotations (PostAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        post: "/v2/annotations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
  }

  // Patch one or more annotations.
  rpc PatchAnnotations (PatchAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings {
        patch: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Patch annotations status by worker id and task id.
  rpc PatchAnnotationsStatus (PatchAnnotationsStatusRequest) returns (PatchAnnotationsStatusResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{task_id}/annotations/status"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single annotation.
  rpc DeleteAnnotation (DeleteAnnotationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete multiple annotations in one request.
  rpc DeleteAnnotations (DeleteAnnotationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/annotations"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
          body: "*"
      }
      additional_bindings {
        delete: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Patch saved annotations searches by ids.
  rpc PatchAnnotationsSearches (PatchAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a search over annotations
  rpc PostAnnotationsSearches(PostAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get input count per status.
  rpc GetInputCount (GetInputCountRequest) returns (SingleInputCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/status"
      additional_bindings {
        get: "/v2/inputs/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Streams all the inputs starting from oldest assets.
  rpc StreamInputs (StreamInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/stream"
      additional_bindings {
        get: "/v2/inputs/stream"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInputSamples (GetInputSamplesRequest) returns (MultiInputAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/samples"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/samples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInput (GetInputRequest) returns (SingleInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        get: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the inputs.
  rpc ListInputs (ListInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      additional_bindings {
        get: "/v2/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add an input (or set of inputs) to an app.
  // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
  // it is asynchronous.
  rpc PostInputs (PostInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add an input (or set of inputs) to an app via a file.
  // This is asynchronous.
  rpc PostInputsFile (PostInputsFileRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/file"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/file"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Add an input or set of inputs to an app designed for NiFi integration.
  rpc PostInputsNiFi (PostInputsNiFiRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vendors/nifi/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/vendors/nifi/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Add an input or set of inputs to an app designed for Document integration.
  rpc PostInputsDocument (PostInputsDocumentRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vendors/document/inputs"
      body: "body"
      additional_bindings {
        post: "/v2/vendors/document/inputs"
        body: "body"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Patch one or more inputs.
  rpc PatchInputs (PatchInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single input asynchronously.
  rpc DeleteInput (DeleteInputRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings {
        delete: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple inputs in one request.
  // This call is asynchronous.
  rpc DeleteInputs (DeleteInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings {
        delete: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch saved inputs searches by ids.
  rpc PatchInputsSearches (PatchInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a search over inputs
  rpc PostInputsSearches(PostInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get predicted outputs from the model.
  rpc PostModelOutputs (PostModelOutputsRequest) returns (MultiOutputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/outputs"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs"
        body: "*"
      }
      additional_bindings {
        post: "/v2/models/{model_id}/outputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
  }

  // List all the datasets.
  rpc ListDatasets (ListDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      additional_bindings {
        get: "/v2/datasets"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific dataset.
  rpc GetDataset (GetDatasetRequest) returns (SingleDatasetResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Add datasets to an app.
  // The process is atomic, i.e. either all or no datasets are added.
  // If there is an error for one dataset,
  // the process will stop, revert the transaction and return the error.
  rpc PostDatasets (PostDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        post: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Patch one or more datasets.
  // The process is atomic, i.e. either all or no datasets are patched.
  // If there is an error for one dataset,
  // the process will stop, revert the transaction and return the error.
  rpc PatchDatasets (PatchDatasetsRequest) returns (MultiDatasetResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        patch: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Delete one or more datasets in a single request.
  rpc DeleteDatasets (DeleteDatasetsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
  }

  // List all the dataset inputs in a dataset.
  rpc ListDatasetInputs (ListDatasetInputsRequest) returns (MultiDatasetInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Get a specific dataset input.
  rpc GetDatasetInput (GetDatasetInputRequest) returns (SingleDatasetInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs/{input_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add dataset inputs to a dataset.
  // The process is not atomic, i.e. if there are errors with some dataset
  // inputs, others might still be added. The response reports
  //   - SUCCESS if all dataset inputs were added,
  //   - MIXED_STATUS if only some dataset inputs were added, and
  //   - FAILURE if no dataset inputs were added.
  // Each individual dataset input in the response has the status set to
  // indicate if it was successful or if there was an error.
  rpc PostDatasetInputs (PostDatasetInputsRequest) returns (MultiDatasetInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      body: "*"
      additional_bindings {
        post: "/v2/datasets/{dataset_id}/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete one or more dataset inputs in a single request.
  rpc DeleteDatasetInputs (DeleteDatasetInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets/{dataset_id}/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the dataset versions.
  rpc ListDatasetVersions (ListDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific dataset version.
  rpc GetDatasetVersion (GetDatasetVersionRequest) returns (SingleDatasetVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  rpc ListDatasetVersionMetricsGroups (ListDatasetVersionMetricsGroupsRequest) returns (MultiDatasetVersionMetricsGroupResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}/metrics"
      additional_bindings {
        get: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add dataset versions to a dataset.
  rpc PostDatasetVersions (PostDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        post: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more dataset versions.
  rpc PatchDatasetVersions (PatchDatasetVersionsRequest) returns (MultiDatasetVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        patch: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
  }

  // Delete one or more dataset versions in a single request.
  rpc DeleteDatasetVersions (DeleteDatasetVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions"
      body: "*"
      additional_bindings {
        delete: "/v2/datasets/{dataset_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Delete;
  }

  // Create export of a dataset version.
  rpc PutDatasetVersionExports (PutDatasetVersionExportsRequest) returns (MultiDatasetVersionExportResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/versions/{dataset_version_id}/exports"
      body: "*"
      additional_bindings {
        put: "/v2/datasets/{dataset_id}/versions/{dataset_version_id}/exports"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Add;
  }

  ////////////////////////////////////////
  // Models
  ////////////////////////////////////////

  // Get a specific model type.
  rpc GetModelType (GetModelTypeRequest) returns (SingleModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types/{model_type_id}"
      additional_bindings {
        get: "/v2/models/types/{model_type_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the supported open source licenses in the platform.
  rpc ListOpenSourceLicenses (ListOpenSourceLicensesRequest) returns (ListOpenSourceLicensesResponse) {
    option (google.api.http) = {
      get: "/v2/open_source_licenses"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List all the model types available in the platform.
  // This MUST be above ListModels so that the /models/types endpoint takes precedence.
  rpc ListModelTypes (ListModelTypesRequest) returns (MultiModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types"
      additional_bindings {
        get: "/v2/models/types"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModel (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        get: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a the output info for a given model_id or model_id/version_id
  // combo.
  rpc GetModelOutputInfo (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/output_info"
      additional_bindings {
        get: "/v2/models/{model_id}/output_info"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/output_info"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/output_info"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModels (ListModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/models"
      }
      additional_bindings {
        get: "/v2/models"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }


  // Search over the models to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostModelsSearches (PostModelsSearchesRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/searches"
      body: "*"
      additional_bindings {
        post: "/v2/models/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Add a models to an app.
  rpc PostModels (PostModelsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        post: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;  // Train is needed because it creates a new version.
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
  }

  // Patch one or more models.
  rpc PatchModels (PatchModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        patch: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Patch one or more models.
  rpc PatchModelIds (PatchModelIdsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/ids"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single model.
  rpc DeleteModel (DeleteModelRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple models in one request.
  rpc DeleteModels (DeleteModelsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings {
        delete: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Update model check consents
  rpc PatchModelCheckConsents (PatchModelCheckConsentsRequest) returns (MultiModelCheckConsentResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/check_consents"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/check_consents"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model toolkits tags
  rpc PatchModelToolkits (PatchModelToolkitsRequest) returns (MultiModelToolkitResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/toolkits"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/toolkits"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model use_cases tags
  rpc PatchModelUseCases (PatchModelUseCasesRequest) returns (MultiModelUseCaseResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/usecases"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/usecases"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Update model languages tags
  rpc PatchModelLanguages (PatchModelLanguagesRequest) returns (MultiModelLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/languages"
      body: "*"
      additional_bindings {
        patch: "/v2/models/{model_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the inputs.
  rpc ListModelInputs (ListModelInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputs"
      additional_bindings {
        get: "/v2/models/{model_id}/inputs"
      }
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inputs"
      }
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModelVersion (GetModelVersionRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModelVersions (ListModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      additional_bindings {
        get: "/v2/models/{model_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  rpc PostWorkflowVersionsUnPublish (PostWorkflowVersionsUnPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/unpublish"
      body: "*"
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/unpublish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowPublications_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  rpc PostWorkflowVersionsPublish (PostWorkflowVersionsPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/publish"
      body: "*"
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/publish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowPublications_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PostModelVersionsPublish
  rpc PostModelVersionsPublish (PostModelVersionsPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/publish"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/publish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = ModelVersionPublications_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PostModelVersionsUnPublish
  rpc PostModelVersionsUnPublish (PostModelVersionsUnPublishRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/unpublish"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/unpublish"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = ModelVersionPublications_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // NOTE: inconsistency: do we want this to return a SingleModelResponse?

  // Create a new model version to trigger training of the model.
  rpc PostModelVersions (PostModelVersionsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // PatchModelVersions
  rpc PatchModelVersions (PatchModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModelVersion (DeleteModelVersionRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings {
        delete: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get the evaluation metrics for a model version.
  rpc GetModelVersionMetrics (GetModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Run the evaluation metrics for a model version.
  rpc PostModelVersionMetrics (PostModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{version_id}/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  // Lists model references tied to a particular model id.
  rpc ListModelReferences (ListModelReferencesRequest) returns (MultiModelReferenceResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/references"
      additional_bindings {
        get: "/v2/models/{model_id}/references"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Add new reference(s) to a particular model
  rpc PostModelReferences (PostModelReferencesRequest) returns (MultiModelReferenceResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/references"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/references"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
  }

  // Delete model references tied to a model id by reference id.
  rpc DeleteModelReferences (DeleteModelReferencesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/references"
      body: "*"
      additional_bindings {
        delete: "/v2/models/{model_id}/references"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
  }

  // GetModelVersionInputExample
  rpc GetModelVersionInputExample (GetModelVersionInputExampleRequest) returns (SingleModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples/{example_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // ListModelVersionInputExamples
  rpc ListModelVersionInputExamples (ListModelVersionInputExamplesRequest) returns (MultiModelVersionInputExampleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples"
      additional_bindings {
        get: "/v2/models/{model_id}/versions/{model_version_id}/input_examples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // PostModelVersionInputExamples
  rpc PostModelVersionInputExamples (PostModelVersionInputExamplesRequest) returns (MultiModelVersionInputExampleResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples"
      body: "*"
      additional_bindings {
        post: "/v2/models/{model_id}/versions/{model_version_id}/input_examples"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // DeleteModelVersionInputExamples
  rpc DeleteModelVersionInputExamples (DeleteModelVersionInputExamplesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_id}/input_examples"
      body: "*"
      additional_bindings {
        delete: "/v2/models/{model_id}/versions/{model_version_id}/input_examples"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
  }

  // Star a model
  rpc PostModelStars (PostModelStarsRequest) returns (MultiModelStarResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/model_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  //Un-star a model
  rpc DeleteModelStars (DeleteModelStarsRequest) returns (DeleteModelStarsResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/model_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Star a user
  rpc PostUserStars (PostUserStarsRequest) returns (MultiUserStarResponse) {
    option (google.api.http) = {
      post: "/v2/user_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Un-star a user
  rpc DeleteUserStars (DeleteUserStarsRequest) returns (DeleteUserStarsResponse) {
    option (google.api.http) = {
      delete: "/v2/user_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Star a workflow
  rpc PostWorkflowStars (PostWorkflowStarsRequest) returns (MultiWorkflowStarResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflow_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Un-star a workflow
  rpc DeleteWorkflowStars (DeleteWorkflowStarsRequest) returns (DeleteWorkflowStarsResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflow_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Star an app
  rpc PostAppStars (PostAppStarsRequest) returns (MultiAppStarResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/app_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Un-star an app
  rpc DeleteAppStars (DeleteAppStarsRequest) returns (DeleteAppStarsResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/app_stars"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflows
  ////////////////////////////////////////

  // Get a specific workflow from an app.
  rpc GetWorkflow (GetWorkflowRequest) returns (SingleWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the workflows.
  rpc ListWorkflows (ListWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/workflows"
      }
      additional_bindings {
        get: "/v2/workflows"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all public workflows.
  rpc ListPublicWorkflows (ListPublicWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/public_workflows"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a workflow to an app.
  rpc PostWorkflows (PostWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        post: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more workflows.
  rpc PatchWorkflows (PatchWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        patch: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete a single workflow.
  rpc DeleteWorkflow (DeleteWorkflowRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings {
        delete: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple workflows in one request.
  rpc DeleteWorkflows (DeleteWorkflowsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings {
        delete: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Predict using a workflow.
  rpc PostWorkflowResults (PostWorkflowResultsRequest) returns (PostWorkflowResultsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Compare embeddings distances using a workflow
  rpc PostWorkflowResultsSimilarity(PostWorkflowResultsSimilarityRequest) returns (PostWorkflowResultsSimilarityResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_id}/results/similarity"
      body: "*"
      additional_bindings {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List workflow versions.
  rpc ListWorkflowVersions (ListWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get single workflow version.
  rpc GetWorkflowVersion (GetWorkflowVersionRequest) returns (SingleWorkflowVersionResponse) {
      option (google.api.http) = {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{workflow_version_id}"
        additional_bindings {
          get: "/v2/workflows/{workflow_id}/versions/{workflow_version_id}"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete workflow versions.
  rpc DeleteWorkflowVersions (DeleteWorkflowVersionsRequest) returns (clarifai.api.status.BaseResponse) {
      option (google.api.http) = {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
        body: "*"
        additional_bindings {
          delete: "/v2/workflows/{workflow_id}/versions"
          body: "*"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
  }

  // Patch workflow versions.
  rpc PatchWorkflowVersions (PatchWorkflowVersionsRequest) returns (MultiWorkflowVersionResponse) {
      option (google.api.http) = {
        patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions"
        body: "*"
        additional_bindings {
          patch: "/v2/workflows/{workflow_id}/versions"
          body: "*"
        }
      };
      option (clarifai.auth.util.cl_auth_type) = KeyAuth;
      option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
      option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }

  // Evaluate all the nodes in the workflow.
  rpc PostWorkflowMetrics (PostWorkflowMetricsRequest) returns (MultiWorkflowMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/workflows/{workflow_id}/metrics"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Add;
  }

  // Get workflow evaluation data.
  rpc GetWorkflowMetrics (GetWorkflowMetricsRequest) returns (SingleWorkflowMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics/{metrics_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/metrics/{metrics_id}"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  // GetWorkflowNodeMetrics
  rpc GetWorkflowNodeMetrics (GetWorkflowNodeMetricsRequest) returns (SingleWorkflowNodeMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics/{metrics_id}/nodes/{node_id}"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/metrics/{metrics_id}/nodes/{node_id}"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  // ListWorkflowMetrics
  rpc ListWorkflowMetrics (ListWorkflowMetricsRequest) returns (MultiWorkflowMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      additional_bindings {
        get: "/v2/workflows/{workflow_id}/metrics"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  // Delete one or more workflow metrics.
  rpc DeleteWorkflowMetrics (DeleteWorkflowMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      body: "*"
      additional_bindings {
        delete: "/v2/workflows/{workflow_id}/metrics"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  // Get a specific key from an app.
  rpc GetKey (GetKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List all the keys.
  rpc ListKeys (ListKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List keys by app_id
  rpc ListAppKeys (ListAppKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Search over the keys to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteKey (DeleteKeyRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Add a key to an app.
  rpc PostKeys (PostKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Patch one or more keys.
  rpc PatchKeys (PatchKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // API Keys in the public API -- request is itself Key authorized, and will tell
  // the user the scopes/access of the key/credential they're providing, as computed by
  // our authorizer:
  rpc MyScopes (MyScopesRequest) returns (MultiScopeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopes"
      additional_bindings {
        get: "/v2/myscopes"
      }
      additional_bindings {
        get: "/v2/my_scopes"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  rpc MyScopesUser (MyScopesUserRequest) returns (MultiScopeUserResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/myscopes"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  rpc MyScopesRoot (MyScopesRootRequest) returns (MultiScopeRootResponse) {
    option (google.api.http) = {
      get: "/v2/myscopesroot"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // List all auth scopes available to me as a user.
  rpc ListScopes (ListScopesRequest) returns (MultiScopeDepsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/scopes"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get a specific app from an app.
  rpc GetApp (GetAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the apps.
  rpc ListApps (ListAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps"
      additional_bindings {
        get: "/v2/apps"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the apps to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteApp (DeleteAppRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add a app to an app.
  // This needs to load the default workflow to make a copy, validating all the models in it, and
  // then writing the new workflow back to this new app.
  rpc PostApps (PostAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }

  // Patch one or more apps.
  rpc PatchApps (PatchAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Patch apps ids.
  rpc PatchAppsIds (PatchAppsIdsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/ids"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Patch one app.
  rpc PatchApp (PatchAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Search over the applications to find one or more you're looking for.
  rpc PostAppsSearches (PostAppsSearchesRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/searches"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get current user information
  rpc GetUser (GetUserRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // List users
  rpc ListUsers (ListUsersRequest) returns (MultiUserResponse) {
    option (google.api.http) = {
      get: "/v2/users"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Update gdpr fields of current user.
  rpc PostUserConsent (PostUserConsentRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/consent"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Patch information of current user or another user in the same organisation
  rpc PatchUser (PatchUserRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Post user access request
  rpc PostUserAccess (PostUserAccessRequest) returns (MultiUserAccessResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/access"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get user access request
  rpc GetUserAccess (GetUserAccessRequest) returns (SingleUserAccessResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/access"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Email
  ////////////////////////////////////////
  // Add Email
  rpc PostEmails (PostEmailsRequest) returns (MultipleEmailResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/emails"
      body: "*"
      additional_bindings {
        post: "/v2/emails"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List emails
  rpc ListEmails (ListEmailsRequest) returns (MultipleEmailResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/emails"
      additional_bindings: {
        get: "/v2/emails"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // For sending another verification email.
  rpc PostResendVerifyEmail (PostResendVerifyRequest) returns (SingleResendVerifyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/resend_verification"
      body: "*"
      additional_bindings {
        post: "/v2/resend_verification"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Deleting an email.
  rpc DeleteEmail (DeleteEmailRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/emails/{email}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Create primate email.
  rpc PostPrimaryEmail (PostPrimaryEmailRequest) returns (SingleEmailResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/emails/primary"
      body: "*"
      additional_bindings {
        post: "/v2/emails/primary"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Validate new password in real-time for a user
  rpc PostValidatePassword (PostValidatePasswordRequest) returns (SinglePasswordValidationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/validate_password"
      body: "*"
      additional_bindings {
        post: "/v2/validate_password"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get global policy
  rpc ListGlobalPasswordPolicies (ListGlobalPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      get: "/v2/password_policies/global"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get a specific set of password policies attached to a user.
  rpc ListPasswordPolicies (ListPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/password_policies"
      additional_bindings {
        get: "/v2/password_policies"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Create a specific set of password policies attached to a user or an organization.
  rpc PostPasswordPolicies (PostPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/password_policies"
      body: "*"
      additional_bindings {
        post: "/v2/password_policies"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update a specific set of password policies attached to a user or an organization.
  rpc PatchPasswordPolicies (PatchPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/password_policies"
      body: "*"
      additional_bindings {
        patch: "/v2/password_policies"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // DeletePasswordPolicies
  rpc DeletePasswordPolicies (DeletePasswordPoliciesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/password_policies"
      additional_bindings {
        delete: "/v2/password_policies"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Add;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  // Get user feature config
  rpc GetUserFeatureConfig (UserFeatureConfigRequest) returns (SingleUserFeatureConfigResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/feature_flags"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = UserFeatureConfigs_Get;
  }

  // Add organizations
  rpc PostOrganizations (PostOrganizationsRequest) returns (MultiOrganizationResponse) {
    option (google.api.http) = {
      post: "/v2/organizations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // List the provided user's organizations with their roles
  rpc ListUsersOrganizations (ListUsersOrganizationsRequest) returns (MultiUsersOrganizationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/organizations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = UserOrganizations_Get;
  }

  // List multiple organizations
  rpc ListOrganizations (ListOrganizationsRequest) returns (MultiOrganizationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Get single organization
  rpc GetOrganization (GetOrganizationRequest) returns (SingleOrganizationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Patch an organization
  rpc PatchOrganization (PatchOrganizationRequest) returns (SingleOrganizationResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Delete an organization
  rpc DeleteOrganization (DeleteOrganizationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // List organization members
  rpc ListOrganizationMembers (ListOrganizationMembersRequest) returns (MultiOrganizationMemberResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/members"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_List;
  }

  // ListOrganizationAppMembers
  rpc ListOrganizationAppMembers (ListOrganizationAppMembersRequest) returns (MultiOrganizationMemberResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/apps/{user_app_id.app_id}/members"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_List;
  }

  // Add new member to organization
  rpc PostOrganizationMember (PostOrganizationMemberRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/members"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Add;
  }

  // PatchOrganizationMember
  rpc PatchOrganizationMember (PatchOrganizationMembersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/members"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Add;
  }

  // Remove a member from organization
  rpc DeleteOrganizationMember (DeleteOrganizationMemberRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/members/{member_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Delete;
  }

  // Organization invites
  rpc PostOrganizationInvitations (PostOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/invitations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Add;
  }

  // PatchOrganizationInvitations
  rpc PatchOrganizationInvitations (PatchOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/invitations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Add;
  }

  // ListOrganizationInvitations
  rpc ListOrganizationInvitations (ListOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/invitations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Get;
  }

  // GetOrganizationInvitation
  rpc GetOrganizationInvitation (GetOrganizationInvitationRequest) returns (SingleOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/invitations/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Get;
  }

  // PostDeclineOrganizationInvitation
  rpc PostDeclineOrganizationInvitation (PostDeclineOrganizationInvitationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/organization_invitation_decline/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // PostAcceptOrganizationInvitation
  rpc PostAcceptOrganizationInvitation (PostAcceptOrganizationInvitationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/organization_invitation_accept/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // GetOrganizationInvitationPublic
  rpc GetOrganizationInvitationPublic (GetOrganizationInvitationPublicRequest) returns (SingleOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organization_invitation/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Leave an organization
  rpc DeleteRequestingUserFromOrganization (DeleteRequestingUserFromOrganizationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/leave"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Add IdentityProviders
  rpc PostIdentityProviders (PostIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // List multiple IdentityProviders
  rpc ListIdentityProviders (ListIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/identity_providers"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Get single IdentityProvider
  rpc GetIdentityProvider (GetIdentityProviderRequest) returns (SingleIdentityProviderResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/identity_providers/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Patch multiple IdentityProviders
  rpc PatchIdentityProviders (PatchIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Delete multiple IdentityProviders
  rpc DeleteIdentityProviders (DeleteIdentityProvidersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Add teams
  rpc PostTeams (PostTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // List multiple teams
  rpc ListTeams (ListTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Get single team
  rpc GetTeam (GetTeamRequest) returns (SingleTeamResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Patch multiple teams
  rpc PatchTeams (PatchTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Delete multiple teams
  rpc DeleteTeams (DeleteTeamsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Add users to a team
  rpc PostTeamUsers (PostTeamUsersRequest) returns (MultiTeamUserResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Add;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // List team users
  rpc ListTeamUsers (ListTeamUsersRequest) returns (MultiTeamUserResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Delete users from a team
  rpc DeleteTeamUsers (DeleteTeamUsersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Add;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Add applications to team
  rpc PostTeamApps(PostTeamAppsRequest) returns(clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // List team applications
  rpc ListTeamApps(ListTeamAppsRequest) returns(MultiTeamAppsResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Remove applications from team
  rpc DeleteTeamApps(DeleteTeamAppsRequest) returns(clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // List multiple roles
  rpc ListRoles (ListRolesRequest) returns (MultiRoleResponse) {
    option (google.api.http) = {
      get: "/v2/roles"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
  }

  // Get single role
  rpc GetRole (GetRoleRequest) returns (SingleRoleResponse) {
    option (google.api.http) = {
      get: "/v2/roles/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
  }

  // Get a saved legacy search.
  rpc GetSearch (GetSearchRequest) returns (SingleSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        get: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // List all saved legacy searches.
  rpc ListSearches (ListSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      additional_bindings {
        get: "/v2/searches"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Patch saved legacy searches by ids.
  rpc PatchSearches (PatchSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings {
        patch: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Execute a new search and optionally save it.
  rpc PostSearches (PostSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings {
        post: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Execute a previously saved legacy search.
  rpc PostSearchesByID (PostSearchesByIDRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      body: "*"
      additional_bindings {
        post: "/v2/searches/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Evaluate the results of two search requests
  rpc PostAnnotationSearchMetrics(PostAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/searches/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Get the evaluation results between two search requests
  rpc GetAnnotationSearchMetrics(GetAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        get: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }


  // List the evaluation results between two search requests
  rpc ListAnnotationSearchMetrics(ListAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      additional_bindings {
        get: "/v2/annotations/searches/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // DeleteAnnotationSearchMetrics
  rpc DeleteAnnotationSearchMetrics (DeleteAnnotationSearchMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings {
        delete: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Delete;
  }

  // Delete a saved search.
  rpc DeleteSearch (DeleteSearchRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings {
        delete: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Delete;
  }

  // Execute an attribute search.
  rpc PostAttributeSearch (PostAttributeSearchRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/attribute_searches"
      body: "*"
      additional_bindings {
        post: "/v2/attribute_searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // List all the annotation filters.
  rpc ListAnnotationFilters (ListAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      additional_bindings {
        get: "/v2/annotation_filters"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Get a specific annotation filter.
  rpc GetAnnotationFilter (GetAnnotationFilterRequest) returns (SingleAnnotationFilterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters/{annotation_filter_id}"
      additional_bindings {
        get: "/v2/annotation_filters/{annotation_filter_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
  }

  // Add annotation filters.
  rpc PostAnnotationFilters (PostAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        post: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }

  // Patch one or more annotation filters.
  rpc PatchAnnotationFilters (PatchAnnotationFiltersRequest) returns (MultiAnnotationFilterResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        patch: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }

  // Delete one or more annotation filters in a single request.
  rpc DeleteAnnotationFilters (DeleteAnnotationFiltersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters"
      body: "*"
      additional_bindings {
        delete: "/v2/annotation_filters"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Add;
  }

  // Get a list of clusters in an app
  rpc ListClusters (ListClustersRequest) returns (MultiClusterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters"
      additional_bindings {
        get: "/v2/clusters"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all the annotations for a given cluster.
  rpc ListAnnotationsForCluster (ListAnnotationsForClusterRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters/{cluster_id}/annotations"
      additional_bindings {
        get: "/v2/clusters/{cluster_id}/annotations"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all the annotations for a given cluser.
  rpc PostClustersSearches (PostClustersSearchesRequest) returns (MultiClusterResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters/searches"
          body: "*"
      additional_bindings {
        post: "/v2/clusters/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Verify email
  rpc PostVerifyEmail (PostVerifyEmailRequest) returns (SingleVerifyEmailResponse) {
    option (google.api.http) = {
      post: "/v2/verify_email"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Request for password reset email
  rpc PostRequestResetPassword (RequestResetPasswordRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
        post: "/v2/request_password_reset"
        body:"*"
        };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Complete reset password
  rpc PostCompleteResetPassword (CompleteResetPasswordRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/complete_password_reset"
        body:"*"
        };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Login with user/pass
  rpc PostLogin (PostLoginRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/login"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Signup with account.
  rpc PostSignup (PostSignupRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/signup"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Logout use
  rpc PostLogout (PostLogoutRequest) returns (SingleLogoutResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/logout"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List available authentication methods, e.g.
  // * standard auth method - login using user & password
  // * SAML auth methods - SSO using SAML Identity Providers like Okta, Github, Google GSuite, LinkedIn, etc.
  rpc ListAuthMethods (ListAuthMethodsRequest) returns (ListAuthMethodsResponse) {
    option (google.api.http) = {
      get: "/v2/auth/methods"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // ListOrgAuthMethods
  rpc ListOrgAuthMethods (ListAuthMethodsRequest) returns (ListAuthMethodsResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/auth/methods"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // ListOrgAuthMethods
  rpc PostIdLoginFinalizer (PostIdLoginFinalizerRequest) returns (PostIdLoginFinalizerResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/idloginfinalizer"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // PostLinkIdpUser
  rpc PostLinkIdpUser (PostLinkIdpUserRequest) returns (PostLinkIdpUserResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/idpusers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // GetLoginInfo
  rpc GetLoginInfo (GetLoginInfoRequest) returns (GetLoginInfoResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/login/{login_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List available 2FA methods in current environment, e.g.
  // * TOTP auth method - login layer using time synced  codes
  rpc ListAuth2FAMethods (List2FAMethodsRequest) returns (List2FAMethodsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/auth/2fa/methods"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Enable Clarifai TOTP 2FA
  rpc PostAuth2FATotpRegisterEnable (PostAuth2FATotpRegisterEnableRequest) returns (PostAuth2FATotpRegisterEnableResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/register/enable"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Verify Clarifai TOTP 2FA activation
  rpc PostAuth2FATotpRegisterVerify (PostAuth2FATotpRegisterVerifyRequest) returns (PostAuth2FATotpRegisterVerifyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/register/verify",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Disable Clarifai TOTP 2FA
  rpc PostAuth2FATotpDisable (PostAuth2FATotpDisableRequest) returns (PostAuth2FATotpDisableResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/disable",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Login with Clarifai TOTP 2FA activation
  rpc PostAuth2FATotpLogin (PostAuth2FATotpLoginRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/auth/2fa/totp/login",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Recover users Clarifai TOTP 2FA activation through sending an email confirmation.
  rpc PostAuth2FATotpRecover (PostAuth2FATotpRecoverRequest) returns (PostAuth2FATotpRecoverResponse) {
    option (google.api.http) = {
      post: "/v2/auth/2fa/totp/recover",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Confirm the recovery of users Clarifai TOTP 2FA. Will be called by user from email link (via portal).
  rpc GetAuth2FATotpRecoverConfirm (GetAuth2FATotpRecoverConfirmRequest) returns (GetAuth2FATotpRecoverConfirmResponse) {
    option (google.api.http) = {
      get: "/v2/auth/2fa/totp/recover/confirm"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List the subscriptions.
  rpc GetSubscription (GetSubscriptionRequest) returns (SingleSubscriptionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/subscriptions"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a new subscription.
  rpc PostSubscription (PostSubscriptionRequest) returns (SingleSubscriptionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/subscriptions"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List all credit cards.
  rpc ListCreditCards (ListCreditCardsRequest) returns (MultipleCreditCardResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/credit_cards"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a new credit card.
  rpc PostCreditCard (PostCreditCardRequest) returns (SingleCreditCardResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Delete a credit card.
  rpc DeleteCreditCard (DeleteCreditCardRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update a credit card.
  rpc PatchCreditCards (PatchCreditCardsRequest) returns (MultipleCreditCardResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get the shipping address.
  rpc GetShippingAddress(GetShippingAddressRequest) returns (SingleShippingAddressResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/shipping_address"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update shipping address.
  rpc PutShippingAddress(PutShippingAddressRequest) returns (SingleShippingAddressResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/shipping_address"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // ListPlans
  rpc ListPlans(ListPlansRequest) returns (MultiPlanResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/plans"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List all status codes.
  rpc ListStatusCodes (ListStatusCodesRequest) returns (MultiStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get more details for a status code.
  rpc GetStatusCode (GetStatusCodeRequest) returns (SingleStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes/{status_code_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Health check endpoint
  rpc GetHealthz (GetHealthzRequest) returns (GetHealthzResponse) {
    option (google.api.http) = {
      get: "/v2/healthz"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List all billing  cycles - old billing
  rpc ListUserBillingCycles (ListUserBillingCyclesRequest) returns (ListUserBillingCyclesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/billing_cycles"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List user usage.cycles.
  rpc ListUserCycles (ListUserCyclesRequest) returns (ListUserCyclesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/usage_cycles"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Gets the billing cycle start and end date as well as invoice items.
  rpc GetBillingUsage (GetBillingUsageRequest) returns (GetBillingUsageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/billing_usage"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add historical usage. - Billing 1
  rpc PostHistoricalUsage (PostHistoricalUsageRequest) returns (PostHistoricalUsageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/historical_usage"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get historical usage. - Billing 2
  rpc GetHistoricalUsage (GetHistoricalUsageRequest) returns (GetHistoricalUsageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/historical_usage"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = HistoricalUsage_Get;
  }

  // Get a list of valid usage intervals
  rpc ListUsageIntervals (ListUsageIntervalsRequest) returns (ListUsageIntervalsResponse) {
    option (google.api.http) = {
      get: "/v2/usage_intervals"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get realtime usage.
  rpc GetRealtimeUsage (GetRealtimeUsageRequest) returns (GetRealtimeUsageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/realtime_usage"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Post usage to platform. Only called by on prem now.
  rpc PostUsage (PostUsageRequest) returns (PostUsageResponse) {
    // HTTP endpoint should be DELETED after testing.
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/usage"
      body: "*"
      additional_bindings {
        post: "/v2/usage"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // owner list users who the app is shared with
  rpc ListCollaborators (ListCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // add collaborators to an app.
  rpc PostCollaborators (PostCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // Patch existing collaborators.
  rpc PatchCollaborators (PatchCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
  }

  // Delete existing collaborators.
  rpc DeleteCollaborators (DeleteCollaboratorsRequest) returns (clarifai.api.status.BaseResponse){
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add; // when deleting a collaborator, we also delete task workers associated to this collaborator
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Collaboration includes the app user are invitied to work on
  rpc ListCollaborations (ListCollaborationsRequest) returns (MultiCollaborationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/collaborations"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get the license with crypto security.
  rpc FetchLicense (FetchLicenseRequest) returns (FetchLicenseResponse) {
    option (google.api.http) = {
    post: "/v2/licenses/{license_id}"
    body: "*"
  };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // List all licenses.
  rpc ListLicenses (ListLicensesRequest) returns (MultipleLicensesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/licenses"
      additional_bindings {
        get: "/v2/licenses"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Get a license
  rpc GetLicense (GetLicenseRequest) returns (SingleLicenseResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/licenses/{license_id}"
      additional_bindings {
        get: "/v2/licenses/{license_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Check that a license is still valid.
  rpc ValidateLicense (ValidateLicenseRequest) returns (ValidateLicenseResponse) {
    option (google.api.http) = {
      post: "/v2/licenses/{license_id}/validate"
        body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
  // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
  rpc PostAppDuplications (PostAppDuplicationsRequest) returns (MultiAppDuplicationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplications"
        body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // list all the app duplications user triggers
  rpc ListAppDuplications (ListAppDuplicationsRequest) returns (MultiAppDuplicationsResponse){
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // get the app duplication status
  rpc GetAppDuplication (GetAppDuplicationRequest) returns (SingleAppDuplicationResponse) {
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications/{app_duplication_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add tasks to an app.
  rpc PostTasks (PostTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        post: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Task annotation count
  rpc GetTaskAnnotationCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotations/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/annotations/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Task Input count
  rpc GetTaskInputCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/count"
      additional_bindings {
        get: "/v2/tasks/{task_id}/inputs/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Get a specific task from an app.
  rpc GetTask (GetTaskRequest) returns (SingleTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}"
      additional_bindings {
        get: "/v2/tasks/{task_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // List tasks from an app.
  rpc ListTasks (ListTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      additional_bindings {
        get: "/v2/tasks"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Patch one or more tasks.
  rpc PatchTasks (PatchTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        patch: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Delete multiple tasks in one request.
  rpc DeleteTasks (DeleteTasksRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings {
        delete: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }

  // Rollup annotation count for task.
  rpc PatchAnnotationCountsRollup (PatchAnnotationCountsRollupRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotations/count/rollup"
      body: "*"
      additional_bindings {
        patch: "/v2/tasks/{task_id}/annotations/count/rollup"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
  }

  ////////////////////////////////////////
  // Label Order
  ////////////////////////////////////////

  // Add Label orders.
  rpc PostLabelOrders (PostLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        post: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = SavedSearch_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Get a label order.
  rpc GetLabelOrder (GetLabelOrderRequest) returns (SingleLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders/{label_order_id}"
      additional_bindings {
        get: "/v2/label_orders/{label_order_id}"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // List label orders.
  rpc ListLabelOrders (ListLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      additional_bindings {
        get: "/v2/label_orders"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // Patch one or more label orders.
  rpc PatchLabelOrders (PatchLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        patch: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }

  // Delete multiple label orders in one request.
  // this do not change task status
  rpc DeleteLabelOrders (DeleteLabelOrdersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings {
        delete: "/v2/label_orders"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Add a list of Collectors to an app.
  // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
  // endpoint.
  // Those current scopes are listed here as a hard requirement.
  // They are needed when adding the collectors just so we now that you have permission with
  // that key at least to do the writing to this app with POST /inputs.
  rpc PostCollectors (PostCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        post: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get a specific collector from an app.
  rpc GetCollector (GetCollectorRequest) returns (SingleCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{collector_id}"
      additional_bindings {
        get: "/v2/collectors/{collector_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // List all the collectors.
  rpc ListCollectors (ListCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      additional_bindings {
        get: "/v2/collectors"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // Patch one or more collectors.
  rpc PatchCollectors (PatchCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        patch: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }


  // Delete multiple collectors in one request.
  // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
  rpc DeleteCollectors (DeleteCollectorsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings {
        delete: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // PostStatValues
  rpc PostStatValues (PostStatValuesRequest) returns (MultiStatValueResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // PostStatValuesAggregate
  rpc PostStatValuesAggregate (PostStatValuesAggregateRequest) returns (MultiStatValueAggregateResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggregate"
      body: "*"
      additional_bindings {
        post: "/v2/stats/values/aggregate"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // Add a new analytics entry into our database
  rpc PostAnalytics (PostAnalyticsRequest) returns (PostAnalyticsResponse) {
    option (google.api.http) = {
            post: "/v2/analytics"
            body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Add a new sdk_billing entry into our database
  rpc PostSDKBilling (PostSDKBillingRequest) returns (PostSDKBillingResponse) {
    option (google.api.http) = {
        post: "/v2/sdkbilling"
        body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Find annotations duplicates based on an specified attribute of different annotations
  rpc PostFindDuplicateAnnotationsJobs(PostFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      body: "*"
      additional_bindings {
        post: "/v2/annotations/find_duplicates/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }

  // Get annotations find duplicates jobs results by id
  rpc GetFindDuplicateAnnotationsJobs (GetFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs/{id}"
      additional_bindings {
        get: "/v2/annotations/find_duplicates/jobs/{id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }


  // List all the annotations find duplicates jobs results
  rpc ListFindDuplicateAnnotationsJobs(ListFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      additional_bindings {
        get: "/v2/annotations/find_duplicates/jobs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }

  // DeleteFindDuplicateAnnotationsJobs
  rpc DeleteFindDuplicateAnnotationsJobs (DeleteFindDuplicateAnnotationsJobsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      additional_bindings {
        delete: "/v2/annotations/find_duplicates/jobs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Delete;
  }

  // Increase the view metric for a detail view
  rpc PostTrendingMetricsView (PostTrendingMetricsViewRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}/{object_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List the view metrics for a detail view
  rpc ListTrendingMetricsViews (ListTrendingMetricsViewsRequest) returns (MultiTrendingMetricsViewResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}"
      additional_bindings {
        get: "/v2/trending_metrics/views/{view_type}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // Validates the ids (app and user supported), returns validation errors and recommendations
  rpc PostIdValidation (PostIdValidationRequest) returns (MultiIdValidationResponse) {
    option (google.api.http) = {
      post: "/v2/validate_id"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List all the available tags for specified object_type grouped by category
  rpc ListTagCategories (ListTagCategoriesRequest) returns (MultiTagCategoryResponse) {
    option (google.api.http) = {
      get: "/v2/tags/{object_type}/categories"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // List users web notifications
  rpc ListWebNotifications (ListWebNotificationsRequest) returns (MultiWebNotificationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/notifications"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get a web notification
  rpc GetWebNotification (GetWebNotificationRequest) returns (SingleWebNotificationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/notifications/{notification_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update users web notifications
  rpc PatchWebNotifications (PatchWebNotificationsRequest) returns (MultiWebNotificationResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/notifications"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Delete users web notifications
  rpc DeleteWebNotifications (DeleteWebNotificationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/notifications"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }


  // Get a specific module from an app.
  rpc GetModule (GetModuleRequest) returns (SingleModuleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // List all the modules in community, by user or by app.
  rpc ListModules (ListModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      additional_bindings {
        get: "/v2/users/{user_app_id.user_id}/modules"
      }
      additional_bindings {
        get: "/v2/modules"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Add a modules to an app.
  rpc PostModules (PostModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Patch one or more modules.
  rpc PatchModules (PatchModulesRequest) returns (MultiModuleResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Delete multiple modules in one request.
  rpc DeleteModules (DeleteModulesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Get a specific module version for a module.
  rpc GetModuleVersion (GetModuleVersionRequest) returns (SingleModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/module_versions/{module_version_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // List all the modules versions for a given module.
  rpc ListModuleVersions (ListModuleVersionsRequest) returns (MultiModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/module_versions"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Create a new module version to trigger training of the module.
  rpc PostModuleVersions (PostModuleVersionsRequest) returns (MultiModuleVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
  }

  // Delete a multiple module version.
  rpc DeleteModuleVersions (DeleteModuleVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    // We have this so that we can check if this module version is installed anywhere before
    // deleting it. TT-2559
    // option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
  }

  // Get installed modules vesrions for an app.
  rpc GetInstalledModuleVersion (GetInstalledModuleVersionRequest) returns (SingleInstalledModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_module_version_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List installed modules vesrions for an app.
  rpc ListInstalledModuleVersions (ListInstalledModuleVersionsRequest) returns (MultiInstalledModuleVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Install a new module version which will deploy the specific ModuleVersion to the app in the url.
  rpc PostInstalledModuleVersions (PostInstalledModuleVersionsRequest) returns (MultiInstalledModuleVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get; // since adding Keys needs that.
  }

  // Uninstall an installed module version which will deploy the specific ModuleVersion to the app
  // in the url.
  // This cleaned up any associated caller keys so needs the Keys_Delete scope.
  rpc DeleteInstalledModuleVersions (DeleteInstalledModuleVersionsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Assign a key that the caller owns to be used when accessing this installed module version
  // If this endpoint is called with a different key then it overwrites what is there.
  rpc PostInstalledModuleVersionsKey (PostInstalledModuleVersionsKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/installed_module_versions/{installed_module_version_id}/key"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InstalledModuleVersions_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Modules_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get; // since adding Keys needs that.
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Perform bulk operations on a list of inputs based on input source.
  // Operation include add, update, delete of concepts, metadata and geo data.
  // This is an Asynchronous process. Use ListBulkOperations or GetBulkOperation to check the status.
  rpc PostBulkOperations (PostBulkOperationsRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        post: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
  }

  // List all the bulk operations
  rpc ListBulkOperations (ListBulkOperationsRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      additional_bindings {
        get: "/v2/bulk_operations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // Get the bulk operation details by ID
  rpc GetBulkOperation (GetBulkOperationRequest) returns (SingleBulkOperationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations/{id}"
      additional_bindings {
        get: "/v2/bulk_operations/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // Cancel one or more bulk operations
  rpc CancelBulkOperations (CancelBulkOperationRequest) returns (MultiBulkOperationsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        patch: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
  }

  // delete one or more terminated bulk operations
  rpc DeleteBulkOperations (DeleteBulkOperationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations"
      body: "*"
      additional_bindings {
        delete: "/v2/bulk_operations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Add;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Get;
    option (clarifai.auth.util.cl_depending_scopes) = BulkOperation_Delete;
  }

  // Get a specific job.
  rpc GetDatasetInputsSearchAddJob (GetDatasetInputsSearchAddJobRequest) returns (SingleDatasetInputsSearchAddJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/inputs/search_add/jobs/{job_id}"
      additional_bindings {
        get: "/v2/datasets/inputs/search_add/jobs/{job_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }

  // List next non-labeled and unassigned inputs from task's dataset
  rpc ListNextTaskAssignments (ListNextTaskAssignmentsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/assignments"
      additional_bindings {
        get: "/v2/tasks/{task_id}/assignments"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }

  // PutTaskAssignments evaluates all the annotations by labeler (authenticated user) for given task (task_id) and input (input_id).
  rpc PutTaskAssignments (PutTaskAssignmentsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/assignments"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Datasets_Get;
  }

  // PostWaitlistEmails adds new e-mail addresses to a feature waiting list.
  rpc PostWaitlistEmails (PostWaitlistEmailsRequest) returns (MultiWaitlistEmailResponse) {
    option (google.api.http) = {
      post: "/v2/waitlists/{feature}/emails"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // GetSampledPredictResults get sampled prediction metrics by model id
  rpc GetSampledPredictMetrics(GetSampledPredictMetricsRequest) returns (MultiSampledPredictMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/sampled_predict_metrics"
      additional_bindings {
        get: "/v2/sampled_predict_metrics"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // Create a job to add inputs from a cloud storage to an app on the clarifai platform
  // This is an Asynchronous process. Use ListInputsAddJobs or GetInputsJob to check the status.
  rpc PostInputsAddJobs (PostInputsAddJobsRequest) returns (MultiInputsAddJobsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add"
      body: "*"
      additional_bindings {
        post: "/v2/inputs/jobs/add"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Add;
    option (clarifai.auth.util.cl_private_rpc) = true;
  }

  // List all the inputs add jobs
  rpc ListInputsAddJobs (ListInputsAddJobsRequest) returns (MultiInputsAddJobsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add"
      additional_bindings {
        get: "/v2/inputs/jobs/add"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Get;
    option (clarifai.auth.util.cl_private_rpc) = true;
  }

  // Get the input add job details by ID
  rpc GetInputsAddJob (GetInputsAddJobRequest) returns (SingleInputsAddJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add/{id}"
      additional_bindings {
        get: "/v2/inputs/jobs/add/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Get;
    option (clarifai.auth.util.cl_private_rpc) = true;
  }

  // cancel the input add job by ID
  rpc CancelInputsAddJob (CancelInputsAddJobRequest) returns (SingleInputsAddJobResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/add/{id}"
      body: "*"
      additional_bindings {
        patch: "/v2/inputs/jobs/add/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = InputsAddJobs_Get;
    option (clarifai.auth.util.cl_private_rpc) = true;
  }

  rpc PostUploads (PostUploadsRequest) returns (MultiUploadResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      body: "*"
      additional_bindings {
        post: "/v2/uploads"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc PutUploadContentParts (PutUploadContentPartsRequest) returns (SingleUploadResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}/content_parts"
      additional_bindings {
        put: "/v2/uploads/{upload_id}/content_parts"
      }
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc GetUpload (GetUploadRequest) returns (SingleUploadResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}"
      additional_bindings {
        get: "/v2/uploads/{upload_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc ListUploads (ListUploadsRequest) returns (MultiUploadResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      additional_bindings {
        get: "/v2/uploads"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
  }

  rpc DeleteUploads (DeleteUploadsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads"
      body: "*"
      additional_bindings {
        delete: "/v2/uploads"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Uploads_Delete;
  }
}



// Split the results into pages.
message Pagination {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
  uint32 per_page = 2;
}

// GetAnnotationRequest
message GetAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string annotation_id = 2;
  string input_id = 3;
}

// ListAnnotationsRequest
message ListAnnotationsRequest {
  reserved 4;

  clarifai.api.UserAppIDSet user_app_id = 1;

  // List annotations for these IDs
  repeated string ids = 2;

  // List annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specify 'ids' all the annotations for 'input_ids' are returned
  // If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
  repeated string input_ids = 3;

  // Only return the annotations that has one of these user IDs, effectively operating as an
  // OR among them to filter down the results.
  // If model_version_ids are also provided these user_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no user_ids are provided then annotations from all users are returned.
  repeated string user_ids = 9;

  // Only return the annotations that has one of these model version IDs, effectively operating as an
  // OR among them to filter down the results.
  // If user_ids are also provided these model_versions_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no model_version_ids are provided then annotations from all model versions are returned.
  repeated string model_version_ids = 10;

  // Set status to filter by a list of statuses
  // If not statuses are provided then annotations with any status will be returned.
  repeated clarifai.api.status.Status statuses = 5;

  // Set this flag to list both trusted and not trusted annotations
  // by default it's listing only trusted annotations
  bool list_all_annotations = 6;

  // Set this flag to return the model output for model annotations in the response.
  bool return_model_output = 12;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 7;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 8;
  // Flag to filter annotations by task_id
  string task_id = 11;
}

// PostAnnotationsRequest
message PostAnnotationsRequest {

  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;
}

// PatchAnnotationsRequest
message PatchAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// PatchAnnotationsStatusRequest
message PatchAnnotationsStatusRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Annotation Status code
  clarifai.api.status.StatusCode status_code = 2;
  repeated string user_ids = 3;
  string task_id = 4;
  // 'overwrite' is supported
  string action = 5;

}

// PatchAnnotationsStatusResponse
message PatchAnnotationsStatusResponse {
  clarifai.api.status.Status status = 1;
  repeated string user_ids = 2;
  uint32 updated_count = 3;
}

// DeleteAnnotationRequest
message DeleteAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string input_id = 2;

  string annotation_id = 3;
}

// Request to delete several things by the list of ids.
message DeleteAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Delete annotations with IDs
  repeated string ids = 2;

  // Delete annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
  // However you need to specify at least one value for 'input_ids'
  // i.e. this API does not support deleting all annotations
  repeated string input_ids = 3;
}

// SingleAnnotationResponse
message SingleAnnotationResponse {
  clarifai.api.status.Status status = 1;
  Annotation annotation = 2;
}

// MultiAnnotationResponse
message MultiAnnotationResponse {
  clarifai.api.status.Status status = 1;

  repeated Annotation annotations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetAppRequest
message GetAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 2;
}

// ListAppsRequest
message ListAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Sorting opitons:
   // Whether to sort in ascending order. If false, will order in descending order.
   bool sort_ascending = 5;
   oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 6;
    // Whether to order by the modified_at time.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;
   }

  // Filtering options:
  // Query various text fields that can contain the words in the query string
  string query = 8;
  // Filter by the name of the app. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated in favor of query
  string name = 4 [deprecated = true];
  // If true, we only return apps that are handpicked by clarifai staff
  bool featured_only = 9;
  // If true, we only return apps that are starred by the requesting user
  bool starred_only = 11;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 10;
}

// PostAppsRequest
message PostAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;
}

// DeleteAppRequest
message DeleteAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PatchAppsRequest
message PatchAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;

  // The action to perform on the patched App objects except App.Metadata
  // For now only action 'overwrite' is supported
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}

// PatchAppRequest
message PatchAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  App app = 2;

  // The action to perform on the patched App object except App.Metadata
  // For now only action 'overwrite' is supported
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}

// PatchAppsIdsRequest
message PatchAppsIdsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Array containing 1 entry
  repeated IdUpdateSource ids = 3;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 4;
}

// Search over the available applications.
message PostAppsSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  AppQuery app_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

// SingleAppResponse
message SingleAppResponse {
  clarifai.api.status.Status status = 1;
  App app = 2;
}

// MultiAppResponse
message MultiAppResponse {
  clarifai.api.status.Status status = 1;
  repeated App apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListCollaboratorsRequest
message ListCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Set this flag to list both deleted and not deleted collaborators
  // by default it's listing only not deleted collaborators
  bool list_all_collaborators = 2;
}

// PostCollaboratorsRequest
message PostCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;
}

// PatchCollaboratorsRequest
message PatchCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// DeleteCollaboratorsRequest
message DeleteCollaboratorsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string collaborator_ids = 2;
  repeated string user_emails = 3;
}

// MultiCollaboratorsResponse
message MultiCollaboratorsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaborator collaborators = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListCollaborationsRequest
message ListCollaborationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// MultiCollaborationsResponse
message MultiCollaborationsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaboration collaborations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostVerifyEmailRequest
message PostVerifyEmailRequest {
  string key = 1;
}

// SingleVerifyEmailResponse
message SingleVerifyEmailResponse {
  clarifai.api.status.Status status = 1;
}

// ListAuthMethodsRequest
message ListAuthMethodsRequest {
  reserved 5;
  // (optional URL parameter) Recovery path that the user will be redirected back to after login
  string recovery_path = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;

  // this applies to org auth only. when true sso flows will redirect to 'recovery_path' upon successful redirect from idp (instead of doing additional actiosn to support id_login)
  bool dry_run = 3;

  // this applies to org auth only. when present finalizer will associate PAT with IDP
  string authorize_pat = 4;
}

// PostLinkIdpUserRequest
message PostLinkIdpUserRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string login_id = 2;
}

// GetLoginInfoRequest
message GetLoginInfoRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string login_id = 2;
}

// GetLoginInfoResponse
message GetLoginInfoResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;

  string subject_email = 2;
  string idp_name = 3;
  string idp_id = 4;
  //this will be true if caller is linked to the authenticated subject from idp
  //if true then the idp linking step should be skipped and proceed to PostIdLoginFinalizer directly
  bool is_linked_to_subject = 5;
  bool subject_authorized_at_idp = 6;
}

// PostLinkIdpUserResponse
message PostLinkIdpUserResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// PostIdLoginFinalizerRequest
message PostIdLoginFinalizerRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string login_id = 2;
}

// PostIdLoginFinalizerResponse
message PostIdLoginFinalizerResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  string recovery_path = 2;
}

// ListAuthMethodsResponse
message ListAuthMethodsResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  // List of authentication methods.
  repeated AuthMethod auth_methods = 2;
}

// 2FA (Two factor authentication)
message List2FAMethodsRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// List2FAMethodsResponse
message List2FAMethodsResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  // List of authentication methods.
  repeated TwoFactorAuthMethod two_factor_auth_methods = 2;
}

// PostAuth2FATotpRegisterEnableRequest
message PostAuth2FATotpRegisterEnableRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PostAuth2FATotpRegisterEnableResponse
message PostAuth2FATotpRegisterEnableResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  string secret = 2;
  string qr_code = 3;
  string state = 4;
}

// PostAuth2FATotpDisableRequest
message PostAuth2FATotpDisableRequest {
  string passcode = 1;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// PostAuth2FATotpDisableResponse
message PostAuth2FATotpDisableResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// PostAuth2FATotpRegisterVerifyRequest
message PostAuth2FATotpRegisterVerifyRequest {
  string passcode = 1;
  string state = 2;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// PostAuth2FATotpRegisterVerifyResponse
message PostAuth2FATotpRegisterVerifyResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  string recovery_key = 2;
}

// PostAuth2FATotpLoginRequest
message PostAuth2FATotpLoginRequest {
  string passcode = 1;
  string state = 2;
  string user_id = 3;
  bool long_lived = 4;
}

// PostAuth2FATotpRecoverRequest
message PostAuth2FATotpRecoverRequest {
  string state = 1;
  string recovery_code = 2;
  string user_id = 3;
}

// PostAuth2FATotpRecoverResponse
message PostAuth2FATotpRecoverResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// GetAuth2FATotpRecoverConfirmRequest
message GetAuth2FATotpRecoverConfirmRequest {
  // (required URL parameter) Confirmation secret for validation
  string state = 1;
}

// GetAuth2FATotpRecoverConfirmResponse
message GetAuth2FATotpRecoverConfirmResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// Reset Password
message RequestResetPasswordRequest {
  //To find associated account.
  string email = 1;
}

// CompleteResetPasswordRequest
message CompleteResetPasswordRequest {
  //key to retrieve user
  string key = 1;
  //new password to set.
  string new_password = 2;
}

// Login and Signup
message PostLoginRequest {
  string email = 1;
  string password = 2;
  bool long_lived = 3;
}

// PostSignupRequest
message PostSignupRequest {
  string email = 1;
  string password = 2;
  string first_name = 3;
  string last_name = 4;
  string company_name = 5;
  string captcha_response_token = 6;
  // same as captcha_response_token but for callers that are opted-in to v3 captcha
  string captcha_response_token_v3 = 14;

  // This field is only for registrations that come from the AWS marketplace
  string aws_registration_token = 7;
  bool gdpr_consent = 8;
  bool tos_consent = 9;
  bool marketing_consent = 10;
  string job_title = 11;
  string job_role = 12;
  Utm utm = 13;
}

// Utm
message Utm {
    string source = 1;
    string medium = 2;
    string campaign = 3;
    string term = 4;
    string content = 5;
}

// SingleLoginResponse
message SingleLoginResponse {
  clarifai.api.status.Status status = 1;
  string email = 2;
  string first_name = 3;
  string last_name = 4;
  string company_name = 5;
  string date_joined = 6;
  repeated EmailAddress email_addresses = 8;
  string session_token = 9;
  string token_expires = 10;
  // This is deprecated in favor of user_id
  string v2_user_id = 11 [deprecated = true];
  string date_gdpr_consent = 12;
  string date_tos_consent = 13;
  string date_marketing_consent = 14;
  // For checking if password expired
  string password_expired_at = 15;
  bool is_new_user = 16;
  bool two_factor_auth_enabled = 17;
  string state = 18;
  // User id
  string user_id = 19;
}

// PostLogoutRequest
message PostLogoutRequest {
  // Contains the user_id to logout. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// SingleLogoutResponse
message SingleLogoutResponse {
  clarifai.api.status.Status status = 1;
}

// Billing Usage
message GetBillingUsageRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// GetBillingUsageResponse
message GetBillingUsageResponse {
  clarifai.api.status.Status status = 1;
  repeated InvoiceItem invoice_items = 2;
  BillingCycle billing_cycle = 3;
}

// GetStatusCodeRequest
message GetStatusCodeRequest {
  string status_code_id = 1;
}

// ListStatusCodesRequest
message ListStatusCodesRequest {
}

// SingleStatusCodeResponse
message SingleStatusCodeResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

// MultiStatusCodeResponse
message MultiStatusCodeResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.status.Status statuses = 2;
}

// GetConceptRequest
message GetConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept's id.
  string concept_id = 2;
}

// ListConceptsRequest
message ListConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostConceptsSearchesRequest
message PostConceptsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ConceptQuery concept_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

// PostConceptsRequest
message PostConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to add.
  repeated Concept concepts = 2;
}

// PatchConceptsRequest
message PatchConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to patch.
  repeated Concept concepts = 2;

  // The action to perform on the patched objects
  // For now ony action 'overwrite' is supported
  string action = 3;
}

// GetConceptCountsRequest
message GetConceptCountsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// SingleConceptResponse
message SingleConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept.
  Concept concept = 2;
}

// MultiConceptResponse
message MultiConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concepts.
  repeated Concept concepts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiConceptCountResponse
message MultiConceptCountResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept counts.
  repeated ConceptCount concept_counts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GET all relations such that the concept_id refers to the subject of the relation
message ListConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id in your app to get all the relationships for.
  // Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
  //
  // When listing all the relations it will only return one direction of the relationship
  // with the predicate acting on the subject and not the inverse like is done when providing a
  // concept_id so that we can return a reliable page size always.
  //
  // When providing a concept_id, if a hyponym is present in the DB such as:
  // 'honey' (subject), 'hyponym' (predict for "is a kind of"), 'food' (object)
  // then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
  // object.
  // But you can also list the concept relations for 'food' and it will return the same hyponym
  // relationship with 'honey' as subject and 'food' as predicate.
  // Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
  // when listing the relations.
  string concept_id = 2;
  // This is part of the url so we can extend to multiple link types in the future.
  // Valid predicates are:
  // 'hypernyms'
  // 'hyponyms'
  string predicate = 3;
  // If knowledge_graph_id is provided then just list relations from that knowledge graph.
  // If not provided then list relations from all knowledge graphs including the global one for this
  // app one (ie. knowledge_graph "") and any specific ones in the app.
  string knowledge_graph_id = 4;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 5;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 6;
}

// POST new concept relations
message PostConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id you're going to add relations for.
  string concept_id = 2;
  // The relationships you're going to add.
  repeated ConceptRelation concept_relations = 3;
}

// DELETE concept relations
message DeleteConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept to delete relationship for.
  string concept_id = 2;
  // The concept relationship ids to delete.
  repeated string ids = 3;
}

// GET all knowledge graphs
message ListKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// POST new knowledge graphs
message PostKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated KnowledgeGraph knowledge_graphs = 2;
}

// GET all concept mappings for the app
message ListConceptMappingsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// POST concept mappings
message PostConceptMappingsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mappings that are being added
  repeated ConceptMapping concept_mappings = 2;
  // The knowledge graph that is being used for these concept mappings
  KnowledgeGraph knowledge_graph = 3;
}

// Start concept mapping jobs
message PostConceptMappingJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mapping jobs that are being started
  repeated ConceptMappingJob concept_mapping_jobs = 2;
}

// SingleConceptRelationResponse
message SingleConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relation.
  ConceptRelation concept_relation = 2;
}

// MultiConceptRelationResponse
message MultiConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relations.
  repeated ConceptRelation concept_relations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleKnowledgeGraphResponse
message SingleKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graph.
  KnowledgeGraph knowledge_graph = 2;
}

// MultiKnowledgeGraphResponse
message MultiKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graphs.
  repeated KnowledgeGraph knowledge_graphs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleConceptMappingResponse
message SingleConceptMappingResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned mapped concept.
  ConceptMapping concept_mapping = 2;
}

// MultiConceptMappingResponse
message MultiConceptMappingResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned mapped concepts.
  repeated ConceptMapping concept_mappings = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleConceptMappingJobResponse
message SingleConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The id of the concept mapping job underway.
  string id = 2;
}

// MultiConceptMappingJobResponse
message MultiConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The ids of the concept mapping jobs underway.
  repeated string ids = 2;
}

// GET single concept language for the given concept.
message GetConceptLanguageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // This is the language identifier.
  string language = 3;
}

// List multiple concept languages for the given concept.
message ListConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PATCH multiple concept languages for the given concept.
message PatchConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
  // The action to perform with the objects in the PATCH.
  string action = 4;
}

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguageRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code to delete.
//   string language = 3;
// }

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguagesRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code(s) to delete.
//   string ids = 3;
//   bool delete_all = 4;
// }

// POST multiple concept languages for the given concept.
message PostConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
}

// SingleConceptLanguageResponse
message SingleConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  ConceptLanguage concept_language = 2;
}

// MultiConceptLanguageResponse
message MultiConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptLanguage concept_languages = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListConceptReferencesRequest
message ListConceptReferencesRequest {
  // The user id and app id set in the url.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept id you want to list translations for.
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// SingleConceptReferenceResponse
message SingleConceptReferenceResponse {
  clarifai.api.status.Status status = 1;
  ConceptReference concept_reference = 2;
}

// MultiConceptReferenceResponse
message MultiConceptReferenceResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptReference concept_references = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetHealthzRequest
message GetHealthzRequest {
}

// GetHealthzResponse
message GetHealthzResponse {
  clarifai.api.status.Status status = 1;
  string time = 2;
}

// GetInputRequest
message GetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// GetInputSamplesRequest
message GetInputSamplesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  // URL param. If zero ids provided, returns for all task labelers
  repeated string user_ids = 3;
}

// ListInputsRequest
message ListInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Set status to filter by status
  clarifai.api.status.Status status = 5;

  repeated string ids = 4;
}

// StreamInputsRequest
message StreamInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  string last_id = 3;

  // By default, the endpoint return inputs by the time when it is added.
  // If this is set to true, we will return inputs by id.
  bool order_by_id = 5;
  bool descending = 4;
}

// PostInputsRequest
message PostInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of inputs to post.
  // For each input, the following fields are used:
  // * id
  // * data
  // * dataset_ids
  repeated Input inputs = 2;
}

// PostInputsFileRequest
message PostInputsFileRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // url to the file.
  string url = 2;

  // type of the file. Currently only support `csv`
  string filetype = 3;
}

// PostInputsNiFiRequest
message PostInputsNiFiRequest {
  option (clarifai.auth.util.cl_private_message) = true;

  clarifai.api.UserAppIDSet user_app_id = 1;
  google.protobuf.ListValue urls = 2;
  // For arbitrary JSON input, use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  // The metadata contains info about the provenance of the files. The provenance info allows user
  // locate the original source files after ingestion. Metadata should be searchable and displayed
  // in output.
  google.protobuf.Struct metadata = 3;
  // The params contains key/value pairs sent by NiFi in case we need certain parameters to be set
  // to successfully ingest inputs.
  google.protobuf.Struct params = 4;
}

// PostInputsDocumentRequest
message PostInputsDocumentRequest {
  option (clarifai.auth.util.cl_private_message) = true;

  clarifai.api.UserAppIDSet user_app_id = 1;
  // Body of the request
  PostInputsDocumentRequestBody body = 2;
  // Query parameter: send the status of the inputs to 3rd party using this url.
  // If empty, the status will not be sent.
  string statusCallbackUrl = 3;
  // Query parameter: send the prediction of the inputs (i.e. entities) to 3rd party using this url.
  // If empty, the entities will not be sent.
  string entityCallbackUrl = 4;
}

// PostInputsDocumentRequestBody
message PostInputsDocumentRequestBody {
  option (clarifai.auth.util.cl_private_message) = true;

  // Track batch status using this batch identifier.
  // 3rd party calls sent to statusCallbackUrl and entityCallbackUrl will use this batch id.
  string batchId_t = 1;
  // List of documents which contain inputs.
  google.protobuf.ListValue document = 2;
  // Not used, but needs to be supported.
  google.protobuf.Struct complete = 3;
  // Not used, but needs to be supported.
  google.protobuf.Struct metadata = 4;
}

// PatchInputsRequest
message PatchInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of inputs to patch.
  // Inputs are identified by id field.
  // For each input, the following fields are patchable:
  // * data
  repeated Input inputs = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// DeleteInputRequest
message DeleteInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteInputsRequest {
  reserved 3;

  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleInputResponse
message SingleInputResponse {
  clarifai.api.status.Status status = 1;
  Input input = 2;
}

// MultiInputResponse
message MultiInputResponse {

  clarifai.api.status.Status status = 1;
  repeated Input inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiInputAnnotationResponse
message MultiInputAnnotationResponse {

  clarifai.api.status.Status status = 1;
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleInputCountResponse
message SingleInputCountResponse {
  clarifai.api.status.Status status = 1;

  InputCount counts = 2;
}

// GetInputCountRequest
message GetInputCountRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// ListDatasetsRequest
message ListDatasetsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    // Defaults to 1.
    uint32 page = 2;
    // (optional URL parameter) The number of results that will be contained in each page. Defaults
    // to 128.
    uint32 per_page = 3;
}

// GetDatasetRequest
message GetDatasetRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;
}

// Request to add one or more datasets.
message PostDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of datasets that are requested to be added.
  repeated Dataset datasets = 2;
}

// Request to patch several datasets.
message PatchDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of datasets that are requested to be updated.
  repeated Dataset datasets = 2;

  // The action to perform on the patched objects
  // Supported values: 'overwrite' and 'merge'
  string action = 3;
}

// Request to delete several datasets by list of ids.
message DeleteDatasetsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string dataset_ids = 2;
}

// MultiDatasetResponse
message MultiDatasetResponse {
  clarifai.api.status.Status status = 1;
  repeated Dataset datasets = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleDatasetResponse
message SingleDatasetResponse {
  clarifai.api.status.Status status = 1;
  Dataset dataset = 2;
}

// ListDatasetInputsRequest
message ListDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Identify dataset by id.
  string dataset_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetDatasetInputRequest
message GetDatasetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset input by id.
  string input_id = 3;
}

// Request to add one or more datasets.
message PostDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of inputs that are requested to be added to this dataset.
  // Identify each input by id field. All other inputs fields are ignored.
  repeated DatasetInput dataset_inputs = 3;

  // Query to search inputs to be added to this dataset.
  Search search = 4;
}

// Request to delete several dataset inputs by list of ids.
message DeleteDatasetInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Specify which inputs to delete from dataset.
  repeated string input_ids = 3;
}

// MultiDatasetInputResponse
message MultiDatasetInputResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetInput dataset_inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  DatasetInputsSearchAddJob dataset_inputs_search_add_job = 3;
}

// SingleDatasetInputResponse
message SingleDatasetInputResponse {
  clarifai.api.status.Status status = 1;
  DatasetInput dataset_input = 2;
}

// ListDatasetVersionsRequest
message ListDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetDatasetVersionRequest
message GetDatasetVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;
}

// ListDatasetVersionMetricsGroupsRequest
message ListDatasetVersionMetricsGroupsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;

  // Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
  repeated string parent_paths = 6;

  // Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
  repeated DatasetVersionMetricsGroupType types = 7;

  // Filter by value. Multiple values are OR-ed. Empty list results in no filter.
  repeated google.protobuf.Value values = 8;
}

// Request to add one or more dataset versions.
message PostDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of dataset versions that are requested to be added.
  repeated DatasetVersion dataset_versions = 3;
}

// Request to patch several dataset versions.
message PatchDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // List of dataset versions that are requested to be updated.
  repeated DatasetVersion dataset_versions = 3;

  // The action to perform on the patched objects
  // For now, only 'overwrite' action is supported
  string action = 4;
}

// Request to delete several dataset versions by list of ids.
message DeleteDatasetVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  repeated string dataset_version_ids = 3;
}

// Request to create exports of a dataset version.
message PutDatasetVersionExportsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify dataset by id.
  string dataset_id = 2;

  // Identify dataset version by id.
  string dataset_version_id = 3;

  // exports is the list of requested dataset version exports.
  // Only setting the 'format' field of the export is supported.
  repeated DatasetVersionExport exports = 4;
}

message MultiDatasetVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersion dataset_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiDatasetVersionExportResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersionExport exports = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiDatasetVersionMetricsGroupResponse {
  clarifai.api.status.Status status = 1;
  repeated DatasetVersionMetricsGroup dataset_version_metrics_groups = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleDatasetVersionResponse {
  clarifai.api.status.Status status = 1;
  DatasetVersion dataset_version = 2;
}

message GetDatasetInputsSearchAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string job_id = 2;
}

message SingleDatasetInputsSearchAddJobResponse {
  clarifai.api.status.Status status = 1;

  DatasetInputsSearchAddJob job = 2;
}

////////////////////////////////////////////////////
// Model prediction related stuff needs inputs and produces outputs.
////////////////////////////////////////////////////
// Model prediction.
message PostModelOutputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  repeated Input inputs = 4;
  // This allows you to specify config options for the model such as
  // the language which appear's in the model's output_info.
  Model model = 5;
}

// Listing the inputs that went into training this model.
message ListModelInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

// GetKeyRequest
message GetKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

// ListKeysRequest
message ListKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// ListAppKeysRequest
message ListAppKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostKeysRequest
message PostKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;
}

// DeleteKeyRequest
message DeleteKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

// PatchKeysRequest
message PatchKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// SingleKeyResponse
message SingleKeyResponse {
  clarifai.api.status.Status status = 1;
  Key key = 2;
}

// MultiKeyResponse
message MultiKeyResponse {
  clarifai.api.status.Status status = 1;
  repeated Key keys = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// FetchLicenseRequest
message FetchLicenseRequest {
  string license_id = 1;
  string public_key = 2; // public key generated in client side, per-activation scope (only created when client first fetches license file, but it is decided by client)
  bytes signature = 3;
}

// FetchLicenseResponse
message FetchLicenseResponse {
  clarifai.api.status.Status status = 1;
  bytes encrypted_bytes = 2;
  google.protobuf.Timestamp activated_at = 3; // Date and time the deployment was activated
  string public_key = 4;
  bytes signature = 5;
}

// ValidateLicenseRequest
message ValidateLicenseRequest {
  string license_id = 1;
  string request_id = 2; // used to prevent users providing faked but valid response
  //for example, returned by previous successful validation
  google.protobuf.Timestamp activated_at = 3;
  string public_key = 4; // public key generated in client side
  bytes signature = 5;
}

// ValidateLicenseResponse
message ValidateLicenseResponse {
  clarifai.api.status.Status status = 1;
  string request_id = 2; // mapping to the request_id in request
  repeated LicenseLimit limits = 3;
  bytes signature = 4;
}

// ListLicensesRequest
message ListLicensesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// GetLicenseRequest
message GetLicenseRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string license_id = 2;
}

// SingleLicenseResponse
message SingleLicenseResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.License license = 2;
}

// MultipleLicensesResponse
message MultipleLicensesResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.License licenses = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetModelRequest
message GetModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // This is included so that we can re-use this request for multiple
  // rpcs with and without the version_id.
  string version_id = 3;
  string language = 4;
  bool trained_before = 5;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
  repeated string additional_fields = 19;
}

// ListModelsRequest
message ListModelsRequest {
  reserved 4;
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 10;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_name = 11;
    // Whether to order by the number of training inputs
    bool sort_by_num_inputs = 12;
    // Whether to order by the modified_at time of the latest model version.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 13;
  }

  // Filtering options:
  // Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
  string query = 14;
  // Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
  string name = 5;
  // Extends the name filter to include the user_id of the application owner that the model belongs to.
  bool filter_by_user_id = 22;
  // Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
  // supported.
  string model_type_id = 6;
  // If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
  bool trained_only = 7;
  // The list of input fields to the model.
  // For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
  repeated string input_fields = 8;
  // The list of output fields to the model.
  // For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
  repeated string output_fields = 9;
  // Filter by the license of the model version
  string license = 15;
  // If true, we only return models that are handpicked by clarifai staff
  bool featured_only = 16;
  // If true, we only return models that are starred by the requesting user
  bool starred_only = 20;
  // List of toolkit tags to filter by
  repeated string toolkits = 17;
  // List of use_case tags to filter by
  repeated string use_cases = 18;
  // List of language tags to filter by
  repeated string languages = 21;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
  repeated string additional_fields = 19;
}

message PatchModelToolkitsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string toolkits = 3;
  //overwrite supported
  string action = 4;
}

// PatchModelCheckConsentsRequest
message PatchModelCheckConsentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the model id
  string model_id = 2;
  // the consents
  repeated string check_consents = 3;
  //overwrite supported
  string action = 4;
}

message PatchModelUseCasesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string usecases = 3;
  //overwrite supported
  string action = 4;
}

message PatchModelLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  repeated string languages = 3;
  // Only overwrite supported
  string action = 4;
}


message MultiModelToolkitResponse {
  clarifai.api.status.Status status = 1;
  repeated string toolkits = 2;
}

message MultiModelCheckConsentResponse {
  clarifai.api.status.Status status = 1;
  repeated string check_consents = 2;
}

message MultiModelUseCaseResponse {
  clarifai.api.status.Status status = 1;
  repeated string usecases = 2;
}

message MultiModelLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated string languages = 2;
}

// PostModelsRequest
message PostModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // NOTE: inconsistent since "model" is not plural, please use "models" below.
  // Previously you could only create one model at a time.
  // We still support this but you should pass it as models=[model] so
  // that this endpoint is consistent with the rest of our API.
  Model model = 2 [deprecated = true];
  // This allows you to create one or more model by posting it to the API.
  repeated Model models = 3;
}

// PatchModelsRequest
message PatchModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Model models = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message IdUpdateSource {
  //old id
  string id = 1;
  //new id
  string new_id = 2;
}

// PatchModelIdRequest
message PatchModelIdsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Array containing 1 entry
  repeated IdUpdateSource ids = 3;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 4;
}

// DeleteModelRequest
message DeleteModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Search over the available models.
message PostModelsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ModelQuery model_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

// SingleModelResponse
message SingleModelResponse {
  clarifai.api.status.Status status = 1;
  Model model = 2;
}

// MultiModelResponse
message MultiModelResponse {
  clarifai.api.status.Status status = 1;
  repeated Model models = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PatchModelVersionsRequest
message PatchModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersion model_versions = 3;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 4;
}

// request for different endpoints currently.
message GetModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
}

// ListModelVersionsRequest
message ListModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
  // To list only the model versions that have these concept ids present in them.
  repeated string concept_ids = 5;
}

// DeleteModelVersionRequest
message DeleteModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 3;
  string version_id = 4;
}

// SingleModelVersionResponse
message SingleModelVersionResponse {
  clarifai.api.status.Status status = 1;
  ModelVersion model_version = 2;
}

// MultiModelVersionResponse
message MultiModelVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelVersion model_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Create (train) a new model version.
message PostModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;

  // This lets you post an existing model version rather than training a new one.
  // For internal Clarifai use only to start.
  repeated ModelVersion model_versions = 3;

  // Use this to filter inputs that are used in training
  // Alternatively, use train_search & test_search fields OR dataset_version field.
  clarifai.api.Search search = 4 [deprecated = true];
  //train_search is used to specify what data to train on.
  // Alternatively, use dataset_version field.
  clarifai.api.Search train_search = 5;
  //test_search is used to specify what data to test on.
  // Alternatively, use dataset_version field.
  clarifai.api.Search test_search = 6;

  // whether to evaluate the transfer trained model after training
  bool evaluate_after_training = 7;

  // Description about this training run
  string description = 8;

  // Use the data from this dataset version for training.
  // Set dataset_version.dataset_id to identify the dataset that you would like to use.
  // When dataset_version.id field is set,
  // the system will reuse the data from provided dataset version.
  // When dataset_version.id is not set,
  // a new dataset version will be created in the dataset using provided dataset_version fields.
  DatasetVersion dataset_version = 9;

  // When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
  // We will merge this with default_eval_info.
  EvalInfo eval_info = 10;
}

message PostWorkflowVersionsUnPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  repeated WorkflowVersionUnPublishRequest publications = 3;
}


message PostWorkflowVersionsPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  repeated WorkflowVersionPublishRequest publications = 3;
}

message WorkflowVersionPublishRequest {
  string version_id = 1;
}

message WorkflowVersionUnPublishRequest {
  string version_id = 1;
}

// ModelVersionPublishRequest
message ModelVersionPublishRequest {
  string version_id = 1;
}

// PostModelVersionsPublishRequest
message PostModelVersionsPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersionPublishRequest publications = 3;
}

// ModelVersionUnpublishRequest
message ModelVersionUnpublishRequest {
  string version_id = 1;
}

// PostModelVersionsUnPublishRequest
message PostModelVersionsUnPublishRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersionUnpublishRequest publications = 3;
}


// Evaluate this model version.
message PostModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  uint32 max_examples = 4;

  // Use this to filter inputs that are used in evaluation
  clarifai.api.Search test_search = 5;

  // evaluation info. Such as dataset used for evaluation.
  EvalInfo eval_info = 10;
}

// Get the already computed evaluation metrics for this model
// version.
message GetModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;

  // Any of the fields you wish to return from multiclass_metrics
  FieldsValue fields = 4;
}


// // Request to delete several things by the list of ids.
// message DeleteModelVersionsRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   repeated string ids = 2;
//   bool delete_all = 3;
// }

// GetModelTypeRequest
message GetModelTypeRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The specific ModelType.Id you want to retrieve.
  string model_type_id = 2;
}

// ListModelTypesRequest
message ListModelTypesRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// ListOpenSourceLicensesRequest
message ListOpenSourceLicensesRequest {}

// ListOpenSourceLicensesResponse
message ListOpenSourceLicensesResponse {
  clarifai.api.status.Status status = 1;
  repeated string licenses = 2;
}

// SingleModelTypeResponse
message SingleModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // The retrieved ModelType object. .
  ModelType model_type = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiModelTypeResponse
message MultiModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // List of ModelType objects.
  repeated ModelType model_types = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  // List of model importers
  ModelTypeField model_importers = 3;
}

// GetModelVersionInputExampleRequest
message GetModelVersionInputExampleRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Id of example to fetch
  string example_id = 4;
}

// ListModelVersionInputExamplesRequest
message ListModelVersionInputExamplesRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // Optional, defaults to 1.
  uint32 page = 4;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 5;
}

// PostModelVersionInputExamplesRequest
message PostModelVersionInputExamplesRequest {
  // authorization field  (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // examples to add
  repeated ModelVersionInputExample model_version_input_examples = 4;
}

// DeleteModelVersionInputExamplesRequest
message DeleteModelVersionInputExamplesRequest {
  // authorization field (contains app/user id info)
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of model the example belongs to
  string model_id = 2;
  // specific version the example belongs to
  string model_version_id = 3;
  // examples to delete
  repeated string example_ids = 4;
}

// SingleModelVersionInputExampleResponse
message SingleModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example message
  ModelVersionInputExample model_version_input_example = 2;
}

// MultiModelVersionInputExampleResponse
message MultiModelVersionInputExampleResponse {
  // status of response
  clarifai.api.status.Status status = 1;
  // model input example messages
  repeated ModelVersionInputExample model_version_input_examples = 2;
}

// ListModelReferencesRequest
message ListModelReferencesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;
  // Optional, defaults to 1.
  uint32 page = 3;
  // Optional, defaults to 128 references per page.
  uint32 per_page = 4;
}

// PostModelReferencesRequest
message PostModelReferencesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;
  // examples to add
  repeated ModelReference model_references = 3;
}

// DeleteModelReferencesRequest
message DeleteModelReferencesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string model_id = 2;

  // examples to delete
  repeated string ids = 3;
}

// MultiModelReferenceResponse
message MultiModelReferenceResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelReference model_references = 2;
}

// MultiOutputResponse
message MultiOutputResponse {
  clarifai.api.status.Status status = 1;
  repeated Output outputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListScopesRequest
message ListScopesRequest {
  // If "personal_access_token" include scopes and endpoints available to personal access tokens.
  // If "api_key" include scopes and endpoints available to app-specific keys. (default)
  string key_type = 1;

  // For all user specific information we include user_app_id to get the user_id in a consistent way
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// MyScopesRequest
message MyScopesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MyScopesUserRequest
message MyScopesUserRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MyScopesRootRequest
message MyScopesRootRequest {
}

// MultiScopeDepsResponse
message MultiScopeDepsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // scopes is a list of low-level scopes and their dependencies.
  repeated ScopeDeps scope_deps = 2;
  // endpoint_scopes is a listof all the publicly available endponts which can be
  // used as scopes as well. A call to each of those endpoint depends on a subset
  // of the above "scopes"
  repeated EndpointDeps endpoint_deps = 3;
}

// MultiScopeResponse
message MultiScopeResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // The app that the key has access to.
  App app = 3;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// MultiScopeUserResponse
message MultiScopeUserResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// MultiScopeRootResponse
message MultiScopeRootResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
  string user_feature_flags = 5;
}

// GetSearchRequest
message GetSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// ListSearchesRequest
message ListSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostSearchesRequest
message PostSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The query; this specifies how the data to be searched
  // this will be replaced by "Searches"
  Query query = 2 [deprecated=true];

  // The searched to be executed or saved
  // Eventually the request level fields will be deprecated in favor of this object
  repeated Search searches = 3;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 4;
}

message PatchInputsSearchesRequest{
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message PatchAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// PatchSearchesRequest
message PatchSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searches to be patched
  repeated Search searches = 2;

  // The action to perform on the patched Search objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// PostSearchesByIDRequest performs returns results of a saved search given its ID
message PostSearchesByIDRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // ID for saves search to be executed
  string id = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// DeleteSearchRequest
message DeleteSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// PostAttributeSearchRequest
message PostAttributeSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  Pagination pagination = 3;
  // Perform a brute force search visual search
  bool brute_force = 4;
  AttributeQuery attribute_query = 5;

  // Minimum value of confidence threshold score in result.
  // Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  // likely be > 0.0.
  float min_value = 6;
}

// Execute a new annotation search and optionally save it
// annotation search over annotations using rank and filter proto
message PostAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// DeleteAnnotationSearchMetricsRequest
message DeleteAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// Execute a new input search and optionally save it
message PostInputsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// SingleSearchResponse returns saved search in response to GetSearchRequest
message SingleSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;
  Search search = 5;
}

// MultiSearchResponse
message MultiSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;

  // A unique id which uniquely identifies a search
  string id = 2;

  // The list of search result Hits.
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original query provided in the request.
  Query query = 4;

  // The original Searches provided in the request.
  repeated Search searches = 5;
}

// PostAnnotationSearchMetricsRequest
message PostAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // A unique customer facing id to identify this eval request
  string id = 2;

  // The ground truth we are evaluating against
  clarifai.api.Search ground_truth = 3;

  // The set we are evaluating
  clarifai.api.Search search_to_eval = 4;

  // List of concepts to evaluate are expected to be in data.concepts
  // If nil, then all app concepts are used
  Data data = 5;

  // The type of evaluation to use
  EvaluationType evaluation_type = 6;
}

// GetAnnotationSearchMetricsRequest
message GetAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Unique custom facing id that identifies the eval to get
  string id = 2;
}

// ListAnnotationSearchMetricsRequest
message ListAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MultiAnnotationSearchMetricsResponse
message MultiAnnotationSearchMetricsResponse {
  // Status of the request
  clarifai.api.status.Status status = 1;
  repeated AnnotationSearchMetrics annotation_search_metrics = 2;
}

// ListAnnotationFiltersRequest
message ListAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// GetAnnotationFilterRequest
message GetAnnotationFilterRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify annotation filter by id.
  string annotation_filter_id = 2;
}

// Request to add one or more annotation filters.
message PostAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of annotation filters that are requested to be added.
  repeated AnnotationFilter annotation_filters = 2;
}

// Request to patch several annotation filters.
message PatchAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // List of annotation filters that are requested to be updated.
  repeated AnnotationFilter annotation_filters = 2;

  // The action to perform on the patched objects
  // For now, only 'overwrite' action is supported
  string action = 3;
}

// Request to delete several annotation filters by list of ids.
message DeleteAnnotationFiltersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Specify which filters to delete.
  repeated string annotation_filter_ids = 2;
}

// MultiAnnotationFilterResponse
message MultiAnnotationFilterResponse {
  clarifai.api.status.Status status = 1;

  repeated AnnotationFilter annotation_filters = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleAnnotationFilterResponse
message SingleAnnotationFilterResponse {
  clarifai.api.status.Status status = 1;

  AnnotationFilter annotation_filter = 2;
}

// ListClustersRequest returns a page of clusters sorted but their count in the app along with some
// statistics on usage of each cluster.
// Note each annotation is assigned to a cluster by a cluster model.
// It also retruns the most recent annotation for each cluster a representative for that cluster.
message ListClustersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // restrict listing to these cluster ids
  repeated string ids = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;

  // number of annotations per cluster returned
  uint32 annotations_per_cluster = 5;
}

// ListAnnotationsForClusterRequest returns a page of annotations sorted by created_at timestamp for a cluster
message ListAnnotationsForClusterRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Cluster ID to get annotations for
  string cluster_id = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PostClustersSearchesRequest
message PostClustersSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// MultiClusterResponse
message MultiClusterResponse {
  clarifai.api.status.Status status = 1;

  // Cluster statistics and represetatives
  repeated Cluster clusters = 2 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original Search provided in the request (if any).
  repeated Search searches = 3;
}

// Gets a the current subscription based on your session token.
message GetSubscriptionRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PostSubscriptionRequest
message PostSubscriptionRequest {
  string signup_code = 1;
  Plan plan = 2;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// SingleSubscriptionResponse
message SingleSubscriptionResponse {
  clarifai.api.status.Status status = 1;
  Plan plan = 2;
  string signup_code = 3;
}

// ListCreditCardsRequest
message ListCreditCardsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MultipleCreditCardResponse
message MultipleCreditCardResponse {
  clarifai.api.status.Status status = 1;
  repeated CreditCard cards = 2;
}

// PostCreditCardRequest
message PostCreditCardRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string source = 2;
  CreditCard card = 3;
}

// SingleCreditCardResponse
message SingleCreditCardResponse {
  clarifai.api.status.Status status = 1;
  CreditCard card = 2;
}

// DeleteCreditCardRequest
message DeleteCreditCardRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  CreditCard card = 2;
}

// PatchCreditCardsRequest
message PatchCreditCardsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated CreditCard cards = 2;
  clarifai.api.PatchAction action = 3;
}

// GetShippingAddressRequest
message GetShippingAddressRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PutShippingAddressRequest
message PutShippingAddressRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  ShippingAddress shipping_address = 2;
  clarifai.api.PatchAction action = 3;
}

// SingleShippingAddressResponse
message SingleShippingAddressResponse {
  clarifai.api.status.Status status = 1;
  ShippingAddress shipping_address = 2;
}

// ListPlansRequest
message ListPlansRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MultiPlanResponse
message MultiPlanResponse {
  clarifai.api.status.Status status = 1;
  repeated Plan plans = 2;
}

// GetHistoricalUsageRequest - billing 2
message GetHistoricalUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // start date of the historical usage
  google.protobuf.Timestamp start_date = 2;
  // end date of the historical usage
  google.protobuf.Timestamp end_date = 3;
  // If true, the usage is broken down per app
  // Default to false
  bool broken_down_per_app = 4;
}

// GetHistoricalUsageResponse - billing 2
message GetHistoricalUsageResponse {
  clarifai.api.status.Status status = 1;
  repeated OpCountByDate usage = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostHistoricalUsageRequest - billing 1
message PostHistoricalUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // NOTE: add plotting parameters here as we expand the usage-dashboard functionality
}

// PostHistoricalUsageResponse - billing 1
message PostHistoricalUsageResponse {
  clarifai.api.status.Status status = 1;

  // in the future, we will also have an optional field for billing cycle:
  google.protobuf.Duration interval = 2;
  repeated DimensionList usage = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetRealtimeUsageRequest
message GetRealtimeUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// GetRealtimeUsageResponse
message GetRealtimeUsageResponse {
  clarifai.api.status.Status status = 1;
  repeated RealtimeCount realtime_usage = 4;
}

// ListUsageIntervalsRequest
message ListUsageIntervalsRequest {
}

// ListUsageIntervalsResponse
message ListUsageIntervalsResponse {
  clarifai.api.status.Status status = 1;
  repeated UsageInterval usage_intervals = 2;
}

// ListUserBillingCyclesRequest - old billing
message ListUserBillingCyclesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// ListUserCyclesRequest
message ListUserCyclesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The number of cycles that will be contained in the response
  // Defaults to 12.
  uint32 cycle_number = 2;
  // (optional URL parameter) Get the cycles before and including this date
  // Defaults to now
  google.protobuf.Timestamp before_date = 3;
}

// ListUserBillingCyclesResponse - old billing
message ListUserBillingCyclesResponse {
  clarifai.api.status.Status status = 1;
  repeated BillingCycle billing_cycles = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListUserCyclesResponse
message ListUserCyclesResponse {
  clarifai.api.status.Status status = 1;
  repeated UsageCycle usage_cycles = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostUsageRequest
message PostUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated EventsCollection events_collections = 2;
  string public_key = 3; // public key generated in client side
  bytes signature = 4;
}

// PostUsageResponse
message PostUsageResponse {
  clarifai.api.status.Status status = 1;
}

// GetUserRequest
message GetUserRequest {
  // we used to have user_id but moved to the standard convention. Since this endpoint
  // hasn't been exposed and only used by portal as a url this won't effect anything external.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 2;
}

// List all the publicly visible users in the platform.
// On the first page the caller user will always be returned in the first result for the page.
message ListUsersRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 2;

  // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 4;

  oneof sort_by {
    // Whether to order by the user ids
    bool sort_by_id = 5;
    // Whether to order by the user first names
    bool sort_by_first_name = 6;
      // Whether to order by the user last names
    bool sort_by_last_name = 7;
    // Whether to order by when the user was created.
    // If neither sort option is set to true, we will sort by created_at.
    bool sort_by_created_at = 8;
  }

  // Filtering options:
  // Query various text fields that can contain the words in the query string.
  // These include id, first name and last name.
  string query = 3;
  // If true, we only return users that are starred by the requesting user
  bool starred_only = 10;

  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 9;
}

// PostUserConsentRequest
message PostUserConsentRequest {
  // This can be the special user_id "me" as well.
  clarifai.api.UserAppIDSet user_app_id = 1;
  bool consent = 2;
  repeated string fields = 3;
}

// SingleUserResponse
message SingleUserResponse {
  clarifai.api.status.Status status = 1;
  User user = 2;
}

// MultiUserResponse
message MultiUserResponse {
  clarifai.api.status.Status status = 1;
  repeated User users = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// This is how you to patch the user object.
// If info.user_id is set then no other field can be set because it's an expensive and dangerous operation.
// All other top level and nested fields can be set separately together.
message PatchUserRequest {
  reserved 1, 6;

  // Provide user id to update.
  // An organization user can update only their own information.
  // An organization admin can update the information of any user in the organization.
  clarifai.api.UserAppIDSet user_app_id = 7;

  // Request to update user information.
  UserInfo info = 2;

  // Request to update password
  UserPassword pass = 3;

  // To handle arbitrary json metadata you can use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  google.protobuf.Struct metadata = 4;

  clarifai.api.PatchAction action = 5;
}

// PostUserAccessRequest
message PostUserAccessRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
  // User access
  repeated UserAccess access = 2;
}

// GetUserAccessRequest
message GetUserAccessRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// MultiUserAccessResponse
message MultiUserAccessResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // User access
  repeated UserAccess access = 2;
}

// SingleUserAccessResponse
message SingleUserAccessResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // User access
  UserAccess access = 2;
}

// PostEmailsRequest
message PostEmailsRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Emails to add
  repeated string emails = 2;
}

// SingleEmailResponse
message SingleEmailResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // Returns the targeted email.
  EmailAddress email = 2;
}

// MultipleEmailResponse
message MultipleEmailResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // Returns the targeted emails.
  repeated EmailAddress emails = 2;
}

// ListEmailsRequest
message ListEmailsRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PostResendVerifyRequest
message PostResendVerifyRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Email to verify
  string email = 2;
}

// SingleResendVerifyResponse
message SingleResendVerifyResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
}

// DeleteEmailRequest
message DeleteEmailRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // email address to delete
  string email = 2;
}

// PostPrimaryEmailRequest
message PostPrimaryEmailRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // email address to set as primary
  string email = 2;
}

// PostValidatePasswordRequest
message PostValidatePasswordRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // password to be validated
  Password password = 2;
}

// SinglePasswordValidationResponse
message SinglePasswordValidationResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  PasswordViolations password_violations = 2;
}

// ListGlobalPasswordPoliciesRequest
message ListGlobalPasswordPoliciesRequest {}

// ListPasswordPoliciesRequest
message ListPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The list of target user id.
  // Defaults to empty list
  repeated string user_ids = 2;
  // (optional URL parameter) The list of target organization id.
  // Defaults to empty list
  repeated string organization_ids = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

// PostPasswordPoliciesRequest
message PostPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated PasswordPolicy password_policies = 2;
}

// PatchPasswordPoliciesRequest
message PatchPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated PasswordPolicy password_policies = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// DeletePasswordPoliciesRequest
message DeletePasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Request to delete several things by the list of ids.
  repeated string ids = 2;
}

// MultiplePasswordPoliciesResponse
message MultiplePasswordPoliciesResponse {
  clarifai.api.status.Status status = 1;
  repeated PasswordPolicy password_policies = 2;
}




// UserFeatureConfigRequest
message UserFeatureConfigRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// SingleUserFeatureConfigResponse
message SingleUserFeatureConfigResponse {
  clarifai.api.status.Status status = 1;
  string config = 2;
}

// PostOrganizationsRequest
message PostOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Organization organizations = 2;
}

// ListOrganizationsRequest
message ListOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// ListUsersOrganizationsRequest
message ListUsersOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 3;
}

// DeleteRequestingUserFromOrganizationRequest
message DeleteRequestingUserFromOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PostAcceptOrganizationInvitationRequest
message PostAcceptOrganizationInvitationRequest {
  string id = 1;
  // The user_id you're calling with.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// PostDeclineOrganizationInvitationRequest
message PostDeclineOrganizationInvitationRequest {
  string id = 1;
  // The user_id you're calling with.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// GetOrganizationRequest
message GetOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// PatchOrganizationRequest
message PatchOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Array that has exactly one organization for patching
  repeated Organization organizations = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// DeleteOrganizationRequest
message DeleteOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// SingleOrganizationResponse
message SingleOrganizationResponse {
  clarifai.api.status.Status status = 1;
  Organization organization = 2;
}

// MultiOrganizationResponse
message MultiOrganizationResponse {
  clarifai.api.status.Status status = 1;
  repeated Organization organizations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// MultiUsersOrganizationsResponse
message MultiUsersOrganizationsResponse {
  clarifai.api.status.Status status = 1;

  message UserOrganization {
    //wrapper because might need to add role id etc in here in the future
    Organization organization = 1;
    Role role = 2;
    string feature_flag_configs = 3;
  }

  repeated UserOrganization organizations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListOrganizationAppMembersRequest
message ListOrganizationAppMembersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated clarifai.auth.scope.S  required_scopes = 2;

    // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 4;
}

// ListOrganizationMembersRequest
message ListOrganizationMembersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
      // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 3;
}

// PostOrganizationInvitationsRequest
message PostOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated OrganizationInvitation invitations = 2;
}

// PatchOrganizationInvitationsRequest
message PatchOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string action = 2;
  repeated OrganizationInvitation invitations = 3;
}

// OrganizationInvitationStatus
enum OrganizationInvitationStatus {
  NOT_SET = 0;
  PENDING = 1;
  ACCEPTED = 2;
  CANCELLED = 3;
  DECLINED = 4;
  EXPIRED = 5;
}

// ListOrganizationInvitationsRequest
message ListOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  OrganizationInvitationStatus status = 4;
}

// GetOrganizationInvitationRequest
message GetOrganizationInvitationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// GetOrganizationInvitationPublicRequest
message GetOrganizationInvitationPublicRequest {
  string id = 1;
}

// SingleOrganizationInvitationResponse
message SingleOrganizationInvitationResponse {
  clarifai.api.status.Status status = 1;
  OrganizationInvitation invitation = 2;
}

// MultiOrganizationInvitationResponse
message MultiOrganizationInvitationResponse {
  clarifai.api.status.Status status = 1;
  repeated OrganizationInvitation invitations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PatchOrganizationMembersRequest
message PatchOrganizationMembersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The action to perform on the patched objects
  // For now, only action 'overwrite' is supported
  string action = 2;
  message PatchOrganizationMember {
    string id = 1;
    string role_id = 2;
  }
  repeated PatchOrganizationMember organization_members = 3;
}

// PostOrganizationMemberRequest
message PostOrganizationMemberRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string member_id = 2;
  string role_id = 3;
}

// DeleteOrganizationMemberRequest
message DeleteOrganizationMemberRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string member_id = 2;
}

// MultiOrganizationMemberResponse
message MultiOrganizationMemberResponse {
  clarifai.api.status.Status status = 1;

  repeated OrganizationMember organization_members = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostIdentityProvidersRequest
message PostIdentityProvidersRequest {
  repeated IdentityProvider identity_providers = 1;

  clarifai.api.UserAppIDSet user_app_id = 2;
}

// ListIdentityProvidersRequest
message ListIdentityProvidersRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// GetIdentityProviderRequest
message GetIdentityProviderRequest {
  string id = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// PatchIdentityProvidersRequest
message PatchIdentityProvidersRequest {
  repeated IdentityProvider identity_providers = 1;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
  clarifai.api.UserAppIDSet user_app_id = 4;
}

// DeleteIdentityProvidersRequest
message DeleteIdentityProvidersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleIdentityProviderResponse
message SingleIdentityProviderResponse {
  clarifai.api.status.Status status = 1;
  IdentityProvider identity_provider = 2;
}

// MultiIdentityProviderResponse
message MultiIdentityProviderResponse {
  clarifai.api.status.Status status = 1;
  repeated IdentityProvider identity_providers = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostTeamsRequest
message PostTeamsRequest {

  message PostTeam {
    // Identify the team (unique).
    string id = 1;

    // When the team was created.
    // The format is https://www.ietf.org/rfc/rfc3339.txt.
    // Example: "2006-01-02T15:04:05.999999Z".
    google.protobuf.Timestamp created_at = 2;

    // Most recent time when the team was updated.
    // The format is https://www.ietf.org/rfc/rfc3339.txt.
    // Example: "2006-01-02T15:04:05.999999Z".
    google.protobuf.Timestamp modified_at = 3;

  // Name the team.
    string name = 4;
  }

  repeated PostTeam teams = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// ListTeamsRequest
message ListTeamsRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;

  // Provide a search query to filter teams by name and id.
  // This supports wildcard queries.
  //   For example, the value "*foo*" will match any team whose name or id contains "foo".
  // The search is case-insensitive.
  string query = 3;
  clarifai.api.UserAppIDSet user_app_id = 4;

}

// GetTeamRequest
message GetTeamRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// PatchTeamsRequest
message PatchTeamsRequest {
  repeated Team teams = 1;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// DeleteTeamsRequest
message DeleteTeamsRequest {
  repeated string ids = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

// SingleTeamResponse
message SingleTeamResponse {
  clarifai.api.status.Status status = 1;
  Team team = 2;
}

// MultiTeamResponse
message MultiTeamResponse {
  clarifai.api.status.Status status = 1;
  repeated Team teams = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// AppIdentity
message AppIdentity {
  string user_id = 1;
  string app_id = 2;
}

// ListTeamAppsRequest
message ListTeamAppsRequest {
  string team_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Provide a search query to filter apps by id and name.
  // This supports wildcard queries.
  // For example, the value "*foo*" will match any app whose id or name contains "foo".
  // The search is case-insensitive.
  string query = 4;
  clarifai.api.UserAppIDSet user_app_id = 5;

}

// PostTeamAppsRequest
message PostTeamAppsRequest {
  message TeamApp {
    //removing the AppIdentity, this was only needed when you could add any app to a team, rn only apps from the same org can be added so we implicitly already
    //know which user the app belongs that is added. It's a breaking change but it's OK since this was never public.
    //AppIdentity app = 1;
    string app_id = 1;
    string role_id = 2;
  }

  string team_id = 1;
  repeated TeamApp apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// DeleteTeamAppsRequest
message DeleteTeamAppsRequest {
  string team_id = 1;
  repeated string app_ids = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// MultiTeamAppsResponse
message MultiTeamAppsResponse {
  message TeamApp {
    string team_id = 1;
    string role_id = 2;

    //todo(margus) should we get rid of this AppIdentity message? it made sense when teams was global but now that is is org scoped it kind of could be removed
    AppIdentity app = 3;

    string app_name = 4;
    string role_name = 5;
  }

  clarifai.api.status.Status status = 1;
  repeated TeamApp apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// PostTeamUsersRequest
message PostTeamUsersRequest {
  string team_id = 1;
  repeated string user_ids = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// ListTeamUsersRequest
message ListTeamUsersRequest {
  string team_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 3;
  // Provide a search query to filter team users by id, first name and last name.
  // This supports wildcard queries.
  //   For example, the value "*foo*" will match any team user whose id, first name or last name contains "foo".
  // The search is case-insensitive.
  string query = 4;
  clarifai.api.UserAppIDSet user_app_id = 5;
}

// DeleteTeamUsersRequest
message DeleteTeamUsersRequest {
  string team_id = 1;
  repeated string user_ids = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

// MultiTeamUserResponse
message MultiTeamUserResponse {
  clarifai.api.status.Status status = 1;
  repeated TeamUser team_users = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListRolesRequest
message ListRolesRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  // Optional query parameter that will add filter by type. Possible values 'ORG' or 'TEAM'.
  repeated RoleType types = 3;
}

// GetRoleRequest
message GetRoleRequest {
  string id = 1;
}

// SingleRoleResponse
message SingleRoleResponse {
  clarifai.api.status.Status status = 1;
  Role role = 2;
}

// MultiRoleResponse
message MultiRoleResponse {
  clarifai.api.status.Status status = 1;
  repeated Role roles = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GET single vocab by id.
message GetVocabRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
}

// List multiple vocabs.
message ListVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// POST new vocabs with this.
message PostVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Vocab vocabs = 2;
}

// PATCH one or more vocabs with this endpoint.
message PatchVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The list of updates fields for the vocabs. Must have the "id" field set so that it can match on
  // of the existing vocabs.
  repeated Vocab vocabs = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

// DeleteVocabRequest
message DeleteVocabRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// List concepts in a vocab. There is
message ListVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// Add a concept(s) to the END of the vocab list.
message PostVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  repeated Concept concepts = 3;
}

// This lets you delete a specific concept from the vocab (not from your app).
message DeleteVocabConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  string concept_id = 3;
}

// Request to delete several concepts from vocab by the list of ids.
// The delete_all in this case will empty the vocab to start over.
// In either case the concepts will remain in your app.
message DeleteVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  repeated string ids = 3;
  bool delete_all = 4;
}

// A single vocab to return.
message SingleVocabResponse {
  clarifai.api.status.Status status = 1;
  Vocab vocab = 2;
}

// Multiple vocabs to return.
message MultiVocabResponse {
  clarifai.api.status.Status status = 1;
  repeated Vocab vocabs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// GetWorkflowRequest
message GetWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 3;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 4;

  // if true will not expand search to clarifai workflows
  bool exclude_clarifai_workflows = 5;
}

// ListWorkflowsRequest
message ListWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

    // Sorting options:
  // Whether to sort in ascending order. If false, will order in descending order.
  bool sort_ascending = 5;
  oneof sort_by {
    // Whether to order by the name
    bool sort_by_id = 6;
    // Whether to order by the modified_at time.
    // If neither sort option is set to true, will sort by modified_at.
    bool sort_by_modified_at = 7;
  }

  // Query various text fields that can contain the words in the query string.
  string query = 8;
  // Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
  // Deprecated in favor of query
  string id = 4 [deprecated = true];
  // If true, we only return workflows that are handpicked by clarifai staff
  bool featured_only = 9;
  // If true, we only return workflows that are starred by the requesting user
  bool starred_only = 11;
  // (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
  repeated string additional_fields = 10;
}

// ListPublicWorkflowsRequest
message ListPublicWorkflowsRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page.
  // Defaults to 128.
  uint32 per_page = 2;
  // Return only base workflows.
  bool only_base = 3;
  // The caller user_id
  clarifai.api.UserAppIDSet user_app_id = 4;
}

// PostWorkflowsRequest
message PostWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;
}

// PatchWorkflowsRequest
message PatchWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// DeleteWorkflowRequest
message DeleteWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// SingleWorkflowResponse
message SingleWorkflowResponse {
  clarifai.api.status.Status status = 1;
  Workflow workflow = 2;
}

// MultiWorkflowResponse
message MultiWorkflowResponse {
  clarifai.api.status.Status status = 1;
  repeated Workflow workflows = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostWorkflowResultsRequest
message PostWorkflowResultsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;

  repeated Input inputs = 3;
  // FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
  // to be within models. This is not consistent with setting this on the request for post model
  // outputs where it is inside a model object. To make this consistent we would send in the
  // workflow object so that each model can have it's own output config. If nobody is setting
  // this OutputConfig it would probably be easier to just remove it for now to keep things simpler
  // and then it's more consistent we just don't support the OutputConfig on workflows.
  OutputConfig output_config = 4;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 5;

  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // If it is not sent in the initial request with workflow_state.id = "init" then no
  // state will be saved or returned in PostWorkflowResultsResponse.
  WorkflowState workflow_state = 6;
}

// PostWorkflowResultsResponse
message PostWorkflowResultsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // The workflow that was used in predictions with PostWorkflowResults
  Workflow workflow = 2;
  // The resulting predictions of all models in the workflow.
  repeated WorkflowResult results = 3;
  // A workflow state to be maintained across PostWorkflowResults requests/responses.
  // This WorkflowState should be passed in to subsequent PostWorkflowResults calls
  // if you want to keep track of state across requests.
  // If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
  // response.
  WorkflowState workflow_state = 4;
}

// PostWorkflowResultsSimilarityRequest
message PostWorkflowResultsSimilarityRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  // Workflow version ID to retrieve
  // If no ID is specified, latest workflow version is used
  string version_id = 7;
  // The specific model version whose outputs we are comparing
  string model_version_id = 3;
  // Each probe is compared against every pool input
  repeated Input probe_inputs = 4;
  // Each pool input is compared against ever probe input
  repeated Input pool_inputs = 5;
  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 6;
}

// PostWorkflowResultsSimilarityResponse
message PostWorkflowResultsSimilarityResponse {
  clarifai.api.status.Status status = 1;
  repeated WorkflowResultsSimilarity results = 2;
}

// ListWorkflowVersionsRequest
message ListWorkflowVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List versions for the workflow identified by this id
  string workflow_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetWorkflowVersionRequest
message GetWorkflowVersionRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested version.
    string workflow_id = 2;
    // Get the identified by this id
    string workflow_version_id = 3;
}

// DeleteWorkflowVersionsRequest
message DeleteWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to delete.
    string workflow_id = 2;
    // Delete the versions identified by these ids
    repeated string workflow_version_ids = 3;
}

// PatchWorkflowVersionsRequest
message PatchWorkflowVersionsRequest {
    clarifai.api.UserAppIDSet user_app_id = 1;
    // The id of the workflow that has the requested versions to patch.
    string workflow_id = 2;
    // Patch these versions.
    repeated WorkflowVersion workflow_versions = 3;
    // The action to perform on the patched objects
    // For now actions 'merge', 'overwrite', and 'remove' are supported
    string action = 4;
}

// MultiWorkflowVersionResponse
message MultiWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    repeated WorkflowVersion workflow_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// SingleWorkflowVersionResponse
message SingleWorkflowVersionResponse {
    clarifai.api.status.Status status = 1;
    WorkflowVersion workflow_version = 2;
}

// PostWorkflowMetricsRequest
message PostWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Specify list of workflow metrics data to add.
  // All fields are optional.
  // Allowed fields to set:
  // * id
  // - provide custom id for the evaluation
  // - if empty, then an id is automatically generated
  // * data
  // - provide concepts to be used for this evaluation
  // - if empty, then all app concepts are used
  // - Example: "data": {
  //                "concepts": [{"id": "{{concept_id}}"}]
  //            }
  // * node_metrics
  // - provide the workflow nodes to be evaluated
  // - if empty, then all evaluable workflow nodes will be evaluated
  // - Example: "node_metrics": {
  //               "node_1": {},
  //               "node_2": {},
  //            }
  // * ground_truth
  // - provide the ground truth data set to search for
  // - if not set, then ground truth is retrieved from current app's inputs and annotations
  // - Example: "ground_truth": {
  //                "query": {
  //                    "ands": {
  //                        "annotation": {
  //                            "data": {
  //                                "concepts": [{"id": "concept"}]
  //                            }
  //                        }
  //                     }
  //                },
  //            }
  repeated WorkflowMetrics workflow_metrics = 3;
}

// GetWorkflowMetricsRequest
message GetWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the workflow metrics.
  string metrics_id = 3;
}

// GetWorkflowNodeMetricsRequest
message GetWorkflowNodeMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the workflow metrics.
  string metrics_id = 3;

  // Identify the workflow node.
  string node_id = 4;
}

// ListWorkflowMetricsRequest
message ListWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Identify the workflow.
  string workflow_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// DeleteWorkflowMetricsRequest
message DeleteWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the list workflow metrics to delete.
  repeated string ids = 3;
}

// SingleWorkflowMetricsResponse
message SingleWorkflowMetricsResponse {
  clarifai.api.status.Status status = 1;

  // Workflow metrics data.
  WorkflowMetrics workflow_metrics = 2;
}

// SingleWorkflowNodeMetricsResponse
message SingleWorkflowNodeMetricsResponse {
  clarifai.api.status.Status status = 1;

  // Workflow node metrics data.
  EvalMetrics node_metrics = 2;
}

// MultiWorkflowMetricsResponse
message MultiWorkflowMetricsResponse {
  clarifai.api.status.Status status = 1;

  // List of workflow metrics.
  repeated WorkflowMetrics workflow_metrics = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

//Request to start a app duplication process
message PostAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated AppDuplication app_duplications = 2;
}

//Request to check app duplication status
message GetAppDuplicationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The app duplication id
  string app_duplication_id = 2;
}

//Request to list all the app duplication that user triggered.
message ListAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// MultiAppDuplicationsResponse
message MultiAppDuplicationsResponse {
  clarifai.api.status.Status status = 1;
  repeated AppDuplication app_duplications = 2;
}

// SingleAppDuplicationResponse
message SingleAppDuplicationResponse {
  clarifai.api.status.Status status = 1;
  AppDuplication app_duplication = 2;
}

// Request to create Tasks.
message PostTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
}

// Request to get one task.
message GetTaskRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;

  // (optional URL parameter) List of additional fields to be included in the response.
  // Currently supported: all, worker.users, review.users.
  repeated string additional_fields = 3;
}

// Request to list multiple tasks.
message ListTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // Get tasks that have ANY user from this list assigned as worker.
  repeated string worker_user_ids = 4;
  // Get tasks that have ANY user from this list assigned as reviewer.
  repeated string review_user_ids = 5;
  // Get tasks that are associated to ANY label order from this list.
  repeated string label_order_ids = 8;

  // Get label order tasks as well
  // It is automatically set to true if label_order_ids is set.
  bool including_label_order_tasks = 6;

  // (optional URL parameter) List of additional fields to be included in the response.
  // Currently supported: all, worker.users, review.users.
  repeated string additional_fields = 7;
}

// Request to patch a list of tasks.
message PatchTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of tasks.
message DeleteTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple Tasks.
message MultiTaskResponse {
  clarifai.api.status.Status status = 1;
  repeated Task tasks = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a single Task.
message SingleTaskResponse {
  clarifai.api.status.Status status = 1;
  Task task = 2;
}

// GetTaskCountRequest can be used for fetching -
// 1. Task annotation count per user, per status
// 1. Task input (anchor annotations) count per user, per status
message GetTaskCountRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;

  // task_id for which count per user per status is needed
  string task_id = 2;

  // for given task_id, user_ids to filter on (optional)
  repeated string user_ids= 3;
}


// SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
message SingleTaskCountResponse {
  clarifai.api.status.Status status = 1;
  string app_id = 2;
  string task_id = 3;
  repeated TaskStatusCountPerUser counts = 4;
}

// Request to force annotation count rollup
message PatchAnnotationCountsRollupRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Label Orders
////////////////////////////////////////////////////////////////////////////////

// Request to create label orders.
message PostLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated LabelOrder label_orders = 2;
}

// Request to get one label order.
message GetLabelOrderRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string label_order_id = 2;
}

// Request to list multiple label orders.
message ListLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Request to patch a list of label orders.
message PatchLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated LabelOrder label_orders = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of label orders.
message DeleteLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple label order.
message MultiLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  repeated LabelOrder label_orders = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a label order.
message SingleLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  LabelOrder label_order = 2;
}

// Request to create Collectors.
message PostCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collector collectors = 2;
}

// PatchCollectorsRequest
message PatchCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Collector collectors = 2;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Request to GET a single Collector.
message GetCollectorRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The collecgtor id
  string collector_id = 2;
}

// Request to GET all the Collectors.
message ListCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Response with multiple Collectors.
message MultiCollectorResponse {
  clarifai.api.status.Status status = 1;
  repeated Collector collectors = 2;
}

// Response with a single Collector.
message SingleCollectorResponse {
  clarifai.api.status.Status status = 1;
  Collector collector = 2;
}

// PostStatValuesRequest
message PostStatValuesRequest {
  // The user and app information for the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The stats to post, can post more than one at a time.
  repeated StatValue stat_values = 2;
}

// MultiStatValueResponse
message MultiStatValueResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned stats values.
  repeated StatValue stat_values = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// PostStatValuesAggregateRequest
message PostStatValuesAggregateRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Query to retrieve aggregate values.
  repeated StatValueAggregateQuery stat_value_aggregate_queries = 2;
}

// MultiStatValueAggregateResponse
message MultiStatValueAggregateResponse {
  // The response status.
  clarifai.api.status.Status status = 1;

  // The aggregate results for each query passedin.
  repeated StatValueAggregateResult stat_value_aggregate_results = 2;
}

// PostAnalyticsRequest
message PostAnalyticsRequest {
  // Unique identifier for this data packet, in order to avoid duplicates on the server side
  string batch_unique_identifier = 1;
  DeviceInfo device_info = 2;
  repeated SDKEventsCollection events_collection = 3;
  HostAppInfo host_app_info = 4;
  OperatingSystem operating_system = 5;
  State state = 6;
  string system_uuid = 7;                   // System unique identifier for the combination user + device
  google.protobuf.Timestamp timestamp = 8;  // Timestamp the data was persisted on the device
  SDK sdk = 9;
}

// PostAnalyticsResponse
message PostAnalyticsResponse {
  clarifai.api.status.Status status = 1;
}

// PostSDKBillingRequest
message PostSDKBillingRequest {
  string batch_unique_identifier = 1; // Unique identifier for this data packet, in order to avoid duplicates on the server side
  DeviceInfo device_info = 2;
  SDKBillingCycle cycle = 3;
  HostAppInfo host_app_info = 4;
  OperatingSystem operating_system = 5;
  State state = 6;
  string system_uuid = 7; // System unique identifier for the combination user + device
  SDK sdk = 8;
}

// PostSDKBillingResponse
message PostSDKBillingResponse {
  clarifai.api.status.Status status = 1;
  clarifai.commands.Commands commands = 2;
}

// MultiFindDuplicateAnnotationsJobResponse
message MultiFindDuplicateAnnotationsJobResponse {
  clarifai.api.status.Status status = 1;
  // The find duplicate annotation jobs that were started
  repeated FindDuplicateAnnotationsJob find_duplicate_annotations_jobs = 2;
}

// PostFindDuplicateAnnotationsJobsRequest
message PostFindDuplicateAnnotationsJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The find duplicate annotation jobs that are being started
  repeated FindDuplicateAnnotationsJob find_duplicate_annotations_jobs = 2;
}

// GetFindDuplicateAnnotationsJobsRequest
message GetFindDuplicateAnnotationsJobsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// ListFindDuplicateAnnotationsJobsRequest
message ListFindDuplicateAnnotationsJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// DeleteFindDuplicateAnnotationsJobsRequest
message DeleteFindDuplicateAnnotationsJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// PostTrendingMetricsViewRequest
message PostTrendingMetricsViewRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // ID of the views object.
  string object_id = 3;
}

// ListTrendingMetricsViewsRequest
message ListTrendingMetricsViewsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // For now view types 'apps', 'workflows', and 'models' are supported.
  string view_type = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// MultiTrendingMetricsViewResponse
message MultiTrendingMetricsViewResponse {
  clarifai.api.status.Status status = 1;
  repeated TrendingMetric metrics = 2;
}

// PostIdValidationRequest
message PostIdValidationRequest {
  // List of validations to parse
  repeated Validation validations = 1;
}

// MultiIdValidationResponse
message MultiIdValidationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // Results of validation
  repeated ValidationResult validation_results = 2;
}

// ListTagCategoriesRequest
message ListTagCategoriesRequest {
  // Type of object. 'model' is supported
  string object_type = 1;
}

// MultiTagCategoryResponse
message MultiTagCategoryResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // Categories of tags with all valid tags
  repeated TagCategory categories = 2;
}

// PostModelStarsRequest
message PostModelStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Model stars to create (supports 1)
  repeated ModelStar model_stars = 2;
}

// MultiModelStarResponse
message MultiModelStarResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // Model stars
  repeated ModelStar model_stars = 2;
}

// DeleteModelStarsRequest
message DeleteModelStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // ModelIds of model stars to delete (supports 1)
  repeated string model_ids = 2;
}

// DeleteModelStarsResponse
message DeleteModelStarsResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // List of deleted model stars model_ids
  repeated string model_ids = 2;
}

// PostUserStarsRequest
message PostUserStarsRequest {
  // User stars to create (supports 1)
  repeated UserStar user_stars = 1;
}

// MultiUserStarResponse
message MultiUserStarResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // User stars
  repeated UserStar user_stars = 2;
}

// DeleteUserStarsRequest
message DeleteUserStarsRequest {
  // UserIds of user stars to delete (supports 1)
  repeated string user_ids = 1;
}

// DeleteUserStarsResponse
message DeleteUserStarsResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // List of deleted user stars user_ids
  repeated string user_ids = 2;
}

// PostAppStarsRequest
message PostAppStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // App stars to create (supports 1)
  repeated AppStar app_stars = 2;
}

// MultiAppStarResponse
message MultiAppStarResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // App stars
  repeated AppStar app_stars = 2;
}

// DeleteAppStarsRequest
message DeleteAppStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // AppIds of app stars to delete (supports 1)
  repeated string app_ids = 2;
}

// DeleteAppStarsResponse
message DeleteAppStarsResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // List of deleted app stars app_ids
  repeated string app_ids = 2;
}

// PostWorkflowStarsRequest
message PostWorkflowStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Workflow stars to create (supports 1)
  repeated WorkflowStar workflow_stars = 2;
}

// MultiWorkflowStarResponse
message MultiWorkflowStarResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // Workflow stars
  repeated WorkflowStar workflow_stars = 2;
}

// DeleteWorkflowStarsRequest
message DeleteWorkflowStarsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // WorkflowIds of workflow stars to delete (supports 1)
  repeated string workflow_ids = 2;
}

// DeleteWorkflowStarsResponse
message DeleteWorkflowStarsResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // List of deleted workflow stars workflow_ids
  repeated string workflow_ids = 2;
}

// ListWebNotificationsRequest
message ListWebNotificationsRequest {
  // The user_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) Return only unread notifications
  bool unread_only = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// GetWebNotificationRequest
message GetWebNotificationRequest {
  // The user_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Id of the notification to fetch
  string notification_id = 2;
}

// DeleteNotificationsRequest
message DeleteWebNotificationsRequest {
  // The user_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Ids of notifications to delete
  repeated string ids = 2;
}

// PatchWebNotificationsRequest
message PatchWebNotificationsRequest {
  // The user_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Notifications to patch
  repeated PatchWebNotification notifications = 2;

  // The action to perform on the patched objects
  // Only 'overwrite' is supported
  string action = 3;
}

// MultiNotificationResponse
message MultiWebNotificationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // List of notifications
  repeated WebNotification notifications = 2;
}

// SingleNotificationResponse
message SingleWebNotificationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // Notification
  WebNotification notification = 2;
}










// GetModuleRequest
message GetModuleRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
}

// ListModulesRequest
message ListModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostModulesRequest
message PostModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // This allows you to create one or more module by posting it to the API.
  repeated Module modules = 3;
}

// PatchModulesRequest
message PatchModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Module modules = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteModulesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleModuleResponse
message SingleModuleResponse {
  clarifai.api.status.Status status = 1;
  Module module = 2;
}

// MultiModuleResponse
message MultiModuleResponse {
  clarifai.api.status.Status status = 1;
  repeated Module modules = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// request for different endpoints currently.
message GetModuleVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  string module_version_id = 3;
}

// ListModuleVersionsRequest
message ListModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PostModuleVersionsRequest
message PostModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  // This allows you to create one or more module by posting it to the API.
  repeated ModuleVersion module_versions = 3;
}

// Request to delete several module versions by the list of ids.
message DeleteModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string module_id = 2;
  repeated string ids = 3;
}

// SingleModuleVersionResponse
message SingleModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  ModuleVersion module_version = 2;
}

// MultiModuleVersionResponse
message MultiModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModuleVersion module_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


// GetInstalledModuleVersionRequest
message GetInstalledModuleVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the ID to get of the install module version.
  string installed_module_version_id = 2;
}

// ListInstalledModuleVersionsRequest
message ListInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// PostInstalledModuleVersionsRequest to install a module version into the app in the URL
message PostInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // This allows you to create one or more module by posting it to the API.
  repeated InstalledModuleVersion installed_module_versions = 2;
}

// PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
// version.
message PostInstalledModuleVersionsKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // the ID to get of the install module version.
  string installed_module_version_id = 2;
  // Note(zeiler): we don't provide a key to create since it's always deterministic.
  // we'll create a PAT, owned by the caller with the scopes that the module requests.
  // in the future if we want we can pass in a Key key = 3; field so that the caller
  // can adjust the scopes, but for now that doesn't seem necessary.
}

// Request to delete several installed module versions by the list of ids.
message DeleteInstalledModuleVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// SingleInstalledModuleVersionResponse
message SingleInstalledModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  InstalledModuleVersion installed_module_version = 2;
}

// MultiInstalledModuleVersionResponse
message MultiInstalledModuleVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated InstalledModuleVersion installed_module_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// ListNextTaskAssignmentsRequest
message ListNextTaskAssignmentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
}

// Request to perform bulk operations on a list of inputs based on input source.
message PostBulkOperationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
  repeated clarifai.api.BulkOperation bulk_operations = 2;
}

// Request to list all the bulk operations.
message ListBulkOperationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Request to get the details of a bulk operation by ID.
message GetBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The bulk operation id
  string id = 2;
}

// Cancel a list of bulk operation ids
message CancelBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation ids to be cancelled
  repeated string ids = 2;
}

// Request to delete the terminated bulk operations by ID
// Only operations in terminated state can be deleted.
message DeleteBulkOperationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // List of bulk operation ids to be deleted
  repeated string ids = 2;
}

// SingleBulkOperationsResponse
message SingleBulkOperationsResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.BulkOperation bulk_operation = 2;
}

// MultiBulkOperationsResponse
message MultiBulkOperationsResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.BulkOperation bulk_operation = 2;
}



// PutTaskAssignmentsRequest
message PutTaskAssignmentsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  string input_id = 3;
}

// PostWaitlistEmailsRequest is the request for adding new e-mail addresses to
// a feature waiting list.
message PostWaitlistEmailsRequest {
  // Name of the feature waiting list where to add the emails.
  string feature = 1;

  // E-mail addresses to add to the feature waiting list.
  repeated WaitlistEmail waitlist_emails = 2;

  // CAPTCHA user response token to verify that the request was made by a human.
  string captcha_response_token = 3;
  // same as captcha_response_token but for callers that are opted-in to v3 captcha
  string captcha_response_token_v3 = 4;
}

// MultiWaitlistEmailResponse returns multiple e-mail addresses on a feature waiting list.
message MultiWaitlistEmailResponse {
  clarifai.api.status.Status status = 1;
  repeated WaitlistEmail waitlist_emails = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message GetSampledPredictMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // id of the model. Required field.
  string model_id = 2;

  // requests sent after this timestamp. Optional field.
  google.protobuf.Timestamp start_date = 3;

  // requests sent before this timestamp. Optional field.
  google.protobuf.Timestamp end_date = 4;

  // min predicted score of the concept
  float min_score = 5;
  // max predicted score of the concept
  float max_score = 6;

  Pagination pagination = 7;
}

message MultiSampledPredictMetricsResponse {
  clarifai.api.status.Status status = 1;
  repeated SamplePredictMetric metrics = 2;
}

message SamplePredictMetric {
  string concept_id = 1;
  string concept_name = 2;
  uint32 count = 3;
}

// Request to initiate ingestion of inputs from Cloud storage
message PostInputsAddJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated clarifai.api.InputsAddJob inputs_add_jobs = 2;
}

// List all the input ingestion jobs
message ListInputsAddJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message GetInputsAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of add inputs job
  string id = 2;
}

message CancelInputsAddJobRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // id of add inputs job to be cancelled
  string id = 2;
}

// MultiInputsAddJobsResponse
message MultiInputsAddJobsResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.InputsAddJob inputs_add_jobs = 2;
}

// SingleInputsAddJobResponse
message SingleInputsAddJobResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.InputsAddJob inputs_add_job = 2;
}

// Start a multipart upload
message PostUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated clarifai.api.Upload uploads = 2;
}

// Stops or deletes multipart upload
message DeleteUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

message ListUploadsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message GetUploadRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Upload ID
  string upload_id = 2;
}

message SingleUploadResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.Upload upload = 2;
}

message MultiUploadResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.Upload uploads = 2;
}

// Upload part of multipart upload
message PutUploadContentPartsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string upload_id = 2;
  repeated UploadContentPart content_parts = 3;
}
